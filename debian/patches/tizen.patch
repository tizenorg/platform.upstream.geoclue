Index: geoclue/example/Makefile.am
===================================================================
--- geoclue.orig/example/Makefile.am	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/example/Makefile.am	2011-12-29 16:40:38.930428900 +0900
@@ -8,14 +8,14 @@
 	revgeocode-example \
 	common-example
 
-common_example_SOURCES = common-example.c
 position_example_SOURCES = position-example.c
 position_async_example_SOURCES = position-async-example.c
+master_example_SOURCES = master-example.c
+master_pos_example_SOURCES = master-pos-example.c
 address_example_SOURCES = address-example.c
 geocode_example_SOURCES = geocode-example.c
 revgeocode_example_SOURCES = revgeocode-example.c
-master_example_SOURCES = master-example.c
-master_pos_example_SOURCES = master-pos-example.c
+common_example_SOURCES = common-example.c
 
 AM_CFLAGS = $(GEOCLUE_CFLAGS)
 LDADD = \
Index: geoclue/example/master-pos-example.c
===================================================================
--- geoclue.orig/example/master-pos-example.c	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/example/master-pos-example.c	2011-12-29 16:40:38.930428900 +0900
@@ -25,7 +25,7 @@
  */
 
 
-/* This example shows typical GPS-like usage. Following params are 
+/* This example shows typical GPS-like usage. Following params are
  * given to geoclue_master_client_set_requirements():
  * 	min_accuracy = GEOCLUE_ACCURACY_LEVEL_DETAILED
  * 		We require the highest level of accuracy
@@ -36,13 +36,13 @@
  * 		We need position-changed signals
  * 	allowed_resources = GEOCLUE_RESOURCE_ALL
  * 		Any available resource can be used
- * 
+ *
  * Geoclue master will try to select a suitable provider based on these
- * requirements -- currently only Gypsy and Gpsd providers fulfill 
- * the above requiremens. Gpsd-provider should work out-of-the-box as 
- * long as gpsd is running in the default port. Gypsy provider requires 
+ * requirements -- currently only Gypsy and Gpsd providers fulfill
+ * the above requiremens. Gpsd-provider should work out-of-the-box as
+ * long as gpsd is running in the default port. Gypsy provider requires
  * that you set device name in the options: see README for details.
- * 
+ *
  */
 
 #include <string.h>
@@ -54,7 +54,7 @@
 provider_changed_cb (GeoclueMasterClient *client,
                      char *iface,
                      char *name,
-                     char *description, 
+                     char *description,
                      gpointer userdata)
 {
 	if (strlen (name) == 0) {
@@ -65,35 +65,6 @@
 }
 
 static void
-position_callback (GeocluePosition      *pos,
-		   GeocluePositionFields fields,
-		   int                   timestamp,
-		   double                latitude,
-		   double                longitude,
-		   double                altitude,
-		   GeoclueAccuracy      *accuracy,
-		   GError               *error,
-		   gpointer              userdata)
-{
-	if (error) {
-		g_printerr ("Error getting initial position: %s\n", error->message);
-		g_error_free (error);
-	} else {
-		if (fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
-		    fields & GEOCLUE_POSITION_FIELDS_LONGITUDE) {
-			GeoclueAccuracyLevel level;
-			
-			geoclue_accuracy_get_details (accuracy, &level, NULL, NULL);
-			g_print ("Initial position (accuracy %d):\n", level);
-			g_print ("\t%f, %f\n", latitude, longitude);
-		} else {
-			g_print ("Initial position not available.\n");
-		}
-	}
-}
-
-
-static void
 position_changed_cb (GeocluePosition      *position,
 		     GeocluePositionFields fields,
 		     int                   timestamp,
@@ -106,11 +77,11 @@
 	if (fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
 	    fields & GEOCLUE_POSITION_FIELDS_LONGITUDE) {
 		GeoclueAccuracyLevel level;
-		
+
 		geoclue_accuracy_get_details (accuracy, &level, NULL, NULL);
 		g_print ("got position (accuracy level %d):\n", level);
 		g_print ("\t%f, %f\n", latitude, longitude);
-		
+
 	} else {
 		g_print ("position emitted, but latitude and longitude are not valid.\n");
 	}
@@ -125,20 +96,20 @@
 	GeoclueMaster *master;
 	GeoclueMasterClient *client;
 	GeocluePosition *position;
-	
+
 	g_type_init ();
-	
+
 	master = geoclue_master_get_default ();
 	client = geoclue_master_create_client (master, NULL, NULL);
 	g_object_unref (master);
-	
+
 	g_signal_connect (G_OBJECT (client), "position-provider-changed",
 	                  G_CALLBACK (provider_changed_cb), NULL);
-	
+
 	/* We want provider that has detailed accuracy and emits signals.
 	 * The provider is allowed to use any resources available. */
-	if (!geoclue_master_client_set_requirements (client, 
-	                                             GEOCLUE_ACCURACY_LEVEL_LOCALITY,
+	if (!geoclue_master_client_set_requirements (client,
+	                                             GEOCLUE_ACCURACY_LEVEL_DETAILED,
 	                                             0, TRUE,
 	                                             GEOCLUE_RESOURCE_ALL,
 	                                             NULL)){
@@ -146,7 +117,7 @@
 		g_object_unref (client);
 		return 1;
 	}
-	
+
 	position = geoclue_master_client_create_position (client, &error);
 	if (!position) {
 		g_warning ("Creating GeocluePosition failed: %s", error->message);
@@ -154,20 +125,16 @@
 		g_object_unref (client);
 		return 1;
 	}
-	
+
 	g_signal_connect (G_OBJECT (position), "position-changed",
 			  G_CALLBACK (position_changed_cb), NULL);
 
-	geoclue_position_get_position_async (position, 
-	                                     (GeocluePositionCallback) position_callback,
-	                                     NULL);
-    
 	mainloop = g_main_loop_new (NULL, FALSE);
 	g_main_loop_run (mainloop);
-	
+
 	g_main_loop_unref (mainloop);
 	g_object_unref (client);
 	g_object_unref (position);
-	
+
 	return 0;
 }
Index: geoclue/example/position-example.c
===================================================================
--- geoclue.orig/example/position-example.c	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/example/position-example.c	2011-12-29 16:40:38.930428900 +0900
@@ -37,27 +37,20 @@
 {
 	if (fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
 	    fields & GEOCLUE_POSITION_FIELDS_LONGITUDE) {
-		
+
 		GeoclueAccuracyLevel level;
 		double horiz_acc;
-		
+
 		geoclue_accuracy_get_details (accuracy, &level, &horiz_acc, NULL);
 		g_print ("Current position:\n");
 		g_print ("\t%f, %f\n", latitude, longitude);
 		g_print ("\tAccuracy level %d (%.0f meters)\n", level, horiz_acc);
-		
+
 	} else {
 		g_print ("Latitude and longitude not available.\n");
 	}
 }
 
-static void
-unset_and_free_gvalue (gpointer val)
-{
-        g_value_unset (val);
-        g_free (val);
-}
-
 static GHashTable *
 parse_options (int    argc,
                char **argv)
@@ -65,14 +58,9 @@
         GHashTable *options;
         int i;
 
-        options = g_hash_table_new_full (g_str_hash, g_str_equal,
-                                         NULL, unset_and_free_gvalue);
-
+        options = g_hash_table_new (g_str_hash, g_str_equal);
         for (i = 2; i < argc; i += 2) {
-                GValue *val = g_new0(GValue, 1);
-                g_value_init (val, G_TYPE_STRING);
-                g_value_set_string(val, argv[i + 1]);
-                g_hash_table_insert (options, argv[i], val);
+                g_hash_table_insert (options, argv[i], argv[i + 1]);
         }
 
         return options;
@@ -88,20 +76,20 @@
 	GeoclueAccuracy *accuracy = NULL;
 	GMainLoop *mainloop;
 	GError *error = NULL;
-	
+
 	g_type_init();
-	
+
 	if (argc < 2 || argc % 2 != 0) {
-		g_printerr ("Usage:\n  position-example <provider_name> [option value]\n");
+		g_printerr ("Usage:\n  position-example <provider_name> [option,value]\n");
 		return 1;
 	}
 
 	g_print ("Using provider '%s'\n", argv[1]);
 	service = g_strdup_printf ("org.freedesktop.Geoclue.Providers.%s", argv[1]);
 	path = g_strdup_printf ("/org/freedesktop/Geoclue/Providers/%s", argv[1]);
-	
+
 	mainloop = g_main_loop_new (NULL, FALSE);
-	
+
 	/* Create new GeocluePosition */
 	pos = geoclue_position_new (service, path);
 	if (pos == NULL) {
@@ -111,25 +99,25 @@
 
 	g_free (service);
 	g_free (path);
-	
+
         if (argc > 2) {
                 GHashTable *options;
 
                 options = parse_options (argc, argv);
                 if (!geoclue_provider_set_options (GEOCLUE_PROVIDER (pos), options, &error)) {
-                        g_printerr ("Error setting options: %s\n", 
+                        g_printerr ("Error setting options: %s\n",
                                     error->message);
                         g_error_free (error);
                         error = NULL;
                 }
                 g_hash_table_destroy (options);
         }
-	
-	/* Query current position. We're not interested in altitude 
+
+	/* Query current position. We're not interested in altitude
 	   this time, so leave it NULL. Same can be done with all other
 	   arguments that aren't interesting to the client */
-	fields = geoclue_position_get_position (pos, &timestamp, 
-	                                        &lat, &lon, NULL, 
+	fields = geoclue_position_get_position (pos, &timestamp,
+	                                        &lat, &lon, NULL,
 	                                        &accuracy, &error);
 	if (error) {
 		g_printerr ("Error getting position: %s\n", error->message);
@@ -137,19 +125,19 @@
 		g_object_unref (pos);
 		return 1;
 	}
-	
+
 	/* Print out coordinates if they are valid */
 	if (fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
 	    fields & GEOCLUE_POSITION_FIELDS_LONGITUDE) {
-		
+
 		GeoclueAccuracyLevel level;
 		double horiz_acc;
-		
+
 		geoclue_accuracy_get_details (accuracy, &level, &horiz_acc, NULL);
 		g_print ("Current position:\n");
 		g_print ("\t%f, %f\n", lat, lon);
 		g_print ("\tAccuracy level %d (%.0f meters)\n", level, horiz_acc);
-		
+
 	} else {
 		g_print ("Latitude and longitude not available.\n");
 	}
@@ -161,5 +149,5 @@
 
 	g_main_loop_run (mainloop);
 	return 0;
-	
+
 }
Index: geoclue/packaging/geoclue.spec
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/packaging/geoclue.spec	2011-12-29 16:40:38.930428900 +0900
@@ -0,0 +1,116 @@
+Name:       geoclue
+Summary:    Geoinformation service
+Version:    0.12.0
+Release:    1
+Group:      TO_BE/FILLED_IN
+License:    TO BE FILLED IN
+Source0:    geoclue-%{version}.tar.gz
+BuildRequires:  which
+BuildRequires:  pkgconfig(glib-2.0)
+BuildRequires:  pkgconfig(dbus-glib-1)
+BuildRequires:  pkgconfig(libxml-2.0)
+BuildRequires:  pkgconfig(gconf-2.0)
+BuildRequires:  pkgconfig(libgps)
+BuildRequires:  pkgconfig(libxslt)
+
+
+%description
+Geographic information framework GeoClue provides applications access to various geographical information
+ sources using a D-Bus API or a C library.
+ .
+ This package contains the master server for GeoClue.
+
+
+
+%package -n libgeoclue
+Summary:    C API for GeoClue
+Group:      TO_BE/FILLED
+Requires:   %{name} = %{version}-%{release}
+Requires(post): /sbin/ldconfig
+Requires(postun): /sbin/ldconfig
+
+%description -n libgeoclue
+libgeoclue is a convenience wrapper for the GeoClue service, and
+the recommended way to use GeoClue in the C language.
+
+
+%package -n libgeoclue-devel
+Summary:    C API for GeoClue (development files)
+Group:      TO_BE/FILLED
+Requires:   libgeoclue = %{version}-%{release}
+
+%description -n libgeoclue-devel
+libgeoclue is a convenience wrapper for the GeoClue service, and
+the recommended way to use GeoClue in the C language.
+
+
+%package -n geoclue-gpsd
+Summary:    Position server for GeoClue (GPS)
+Group:      TO_BE/FILLED
+Requires:   %{name} = %{version}-%{release}
+
+%description -n geoclue-gpsd
+GeoClue provides applications access to various geographical information
+sources using a D-Bus API or a C library.
+.
+This package provides a positioning backend for GeoClue. The
+location information comes from a GPS receiver through gpsd
+
+%package -n geoclue-nominatim
+Summary:    Geocode server for GeoClue (OpenStreetMap)
+Group:      TO_BE/FILLED
+Requires:   %{name} = %{version}-%{release}
+
+%description -n geoclue-nominatim
+GeoClue provides applications access to various geographical information
+sources using a D-Bus API or a C library.
+.
+This package provides a tool to search osm data by name and address and to generate synthetic addresses of osm points (reverse geocoding)
+
+
+%prep
+%setup -q -n %{name}-%{version}
+
+
+%build
+export CFLAGS+=" -Wall -g -fPIC"
+export LDFLAGS+=" -Wl,-z,defs -Wl,--rpath=/usr/lib -Wl,--as-needed -Wl,--hash-style=both"
+
+./autogen.sh
+./configure --disable-static --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --enable-system-bus=yes --disable-gypsy --disable-lbs --disable-xps
+
+#make %{?jobs:-j%jobs}
+make
+
+%install
+rm -rf %{buildroot}
+%make_install
+rm -rf %{buildroot}/usr/bin/geoclue-test-gui
+
+
+%post -n libgeoclue -p /sbin/ldconfig
+
+%postun -n libgeoclue -p /sbin/ldconfig
+
+%files
+/usr/libexec/geoclue-master
+/usr/share/dbus-1/services/org.freedesktop.Geoclue.Master.service
+
+%files -n libgeoclue
+/usr/lib/libgeoclue.so.*
+
+%files -n libgeoclue-devel
+/usr/include/*
+/usr/lib/pkgconfig/*
+#/usr/lib/libgeoclue.*a
+/usr/lib/libgeoclue.so
+
+%files -n geoclue-gpsd
+/usr/libexec/geoclue-gpsd
+/usr/share/dbus-1/services/org.freedesktop.Geoclue.Providers.Gpsd.service
+/usr/share/geoclue-providers/geoclue-gpsd.provider
+
+%files -n geoclue-nominatim
+/usr/share/dbus-1/services/org.freedesktop.Geoclue.Providers.Nominatim.service
+/usr/share/geoclue-providers/geoclue-nominatim.provider
+/usr/libexec/geoclue-nominatim
Index: geoclue/geoclue/Makefile.am
===================================================================
--- geoclue.orig/geoclue/Makefile.am	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/geoclue/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -13,10 +13,14 @@
 	gc-iface-master-client-bindings.h	\
 	gc-iface-position-bindings.h	\
 	gc-iface-position-glue.h	\
+	gc-iface-nmea-bindings.h	\
+	gc-iface-nmea-glue.h	\
 	gc-iface-reverse-geocode-bindings.h	\
 	gc-iface-reverse-geocode-glue.h	\
 	gc-iface-velocity-bindings.h	\
-	gc-iface-velocity-glue.h
+	gc-iface-velocity-glue.h \
+	gc-iface-satellite-bindings.h	\
+	gc-iface-satellite-glue.h
 
 BUILT_SOURCES = \
 	$(nodist_libgeoclue_la_SOURCES)	\
@@ -33,17 +37,21 @@
 	geoclue-master.c	\
 	geoclue-master-client.c	\
 	geoclue-position.c	\
+	geoclue-nmea.c	\
 	geoclue-reverse-geocode.c	\
 	geoclue-types.c		\
 	geoclue-velocity.c	\
+	geoclue-satellite.c	\
 	gc-provider.c		\
 	gc-web-service.c	\
 	gc-iface-address.c	\
 	gc-iface-geoclue.c      \
 	gc-iface-geocode.c	\
 	gc-iface-position.c	\
+	gc-iface-nmea.c	\
 	gc-iface-reverse-geocode.c	\
 	gc-iface-velocity.c	\
+	gc-iface-satellite.c	\
 	geoclue-enum-types.c
 
 libgeoclue_la_LIBADD =	\
@@ -53,14 +61,16 @@
 	-I$(top_srcdir)		\
 	-I$(top_builddir)	\
 	$(GEOCLUE_CFLAGS)
-	
+
 geoclue_headers =		\
 	gc-iface-address.h	\
 	gc-iface-geoclue.h	\
 	gc-iface-geocode.h	\
 	gc-iface-position.h	\
+	gc-iface-nmea.h	\
 	gc-iface-reverse-geocode.h	\
 	gc-iface-velocity.h	\
+	gc-iface-satellite.h	\
 	gc-provider.h		\
 	gc-web-service.h	\
 	geoclue-accuracy.h	\
@@ -72,9 +82,12 @@
 	geoclue-master.h	\
 	geoclue-master-client.h	\
 	geoclue-position.h	\
+	geoclue-nmea.h	\
 	geoclue-reverse-geocode.h	\
 	geoclue-types.h		\
 	geoclue-velocity.h	\
+	geoclue-satellite.h	\
+	geoclue-satellite-info.h	\
 	geoclue-enum-types.h
 
 libgeoclue_includedir = $(includedir)/geoclue
@@ -89,8 +102,10 @@
 	stamp-gc-iface-geoclue-glue.h	\
 	stamp-gc-iface-geocode-glue.h	\
 	stamp-gc-iface-position-glue.h	\
+	stamp-gc-iface-nmea-glue.h	\
 	stamp-gc-iface-reverse-geocode-glue.h	\
-	stamp-gc-iface-velocity-glue.h
+	stamp-gc-iface-velocity-glue.h \
+	stamp-gc-iface-satellite-glue.h
 
 DISTCLEANFILES = \
 	$(nodist_libgeoclue_la_SOURCES)	\
@@ -98,45 +113,58 @@
 	geoclue-enum-types.c
 
 geoclue-marshal.h: geoclue-marshal.list $(GLIB_GENMARSHAL)
-	$(AM_V_GEN) $(GLIB_GENMARSHAL) $< --header --prefix=geoclue_marshal > $@
+	$(GLIB_GENMARSHAL) $< --header --prefix=geoclue_marshal > $@
 geoclue-marshal.c: geoclue-marshal.list geoclue-marshal.h $(GLIB_GENMARSHAL)
-	$(AM_V_GEN) $(GLIB_GENMARSHAL) --prefix=geoclue_marshal $(srcdir)/geoclue-marshal.list --header --body > $@
+	echo "#include \"geoclue-marshal.h\"" > $@ \
+	&& $(GLIB_GENMARSHAL) --prefix=geoclue_marshal $(srcdir)/geoclue-marshal.list --body >> $@
 
 %-glue.h: stamp-%-glue.h
 	@true
 
 stamp-gc-iface-address-glue.h: ../interfaces/gc-iface-address.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_address --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_address --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-geoclue-glue.h: ../interfaces/gc-iface-geoclue.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_geoclue --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_geoclue --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-geocode-glue.h: ../interfaces/gc-iface-geocode.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_geocode --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_geocode --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-position-glue.h: ../interfaces/gc-iface-position.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_position --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_position --mode=glib-server $< > xgen-$(@F) \
+	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
+	&& rm -f xgen-$(@F) \
+	&& echo timestamp > $(@F)
+
+stamp-gc-iface-nmea-glue.h: ../interfaces/gc-iface-nmea.xml
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_nmea --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-reverse-geocode-glue.h: ../interfaces/gc-iface-reverse-geocode.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_reverse_geocode --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_reverse_geocode --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-velocity-glue.h: ../interfaces/gc-iface-velocity.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_velocity --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_velocity --mode=glib-server $< > xgen-$(@F) \
+	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
+	&& rm -f xgen-$(@F) \
+	&& echo timestamp > $(@F)
+
+stamp-gc-iface-satellite-glue.h: ../interfaces/gc-iface-satellite.xml
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_satellite --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
@@ -144,7 +172,7 @@
 %-bindings.h: stamp-%-bindings.h
 	@true
 stamp-%-bindings.h: ../interfaces/%.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --mode=glib-client --prefix=geoclue $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --mode=glib-client --prefix=geoclue $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
Index: geoclue/geoclue/gc-iface-nmea.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/gc-iface-nmea.c	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,103 @@
+/*
+ * Geoclue
+ * gc-iface-nmea.c - GInterface for org.freedesktop.Geoclue.Nmea
+ *
+ * Author: Tae-Hwan Kim <the81.kim@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+#include <glib.h>
+
+#include <dbus/dbus-glib.h>
+#include <geoclue/gc-iface-nmea.h>
+#include <geoclue/geoclue-marshal.h>
+
+enum {
+	NMEA_CHANGED,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = {0};
+
+static gboolean
+gc_iface_nmea_get_nmea (GcIfaceNmea *nmea,
+			int         *timestamp,
+			char       **nmea_data,
+			GError     **error);
+
+#include "gc-iface-nmea-glue.h"
+
+static void
+gc_iface_nmea_base_init (gpointer klass)
+{
+	static gboolean initialized = FALSE;
+
+	if (initialized) {
+		return;
+	}
+	initialized = TRUE;
+
+	signals[NMEA_CHANGED] = g_signal_new ("nmea-changed",
+					      G_OBJECT_CLASS_TYPE (klass),
+					      G_SIGNAL_RUN_LAST, 0,
+					      NULL, NULL,
+					      geoclue_marshal_VOID__INT_STRING,
+					      G_TYPE_NONE, 2,
+					      G_TYPE_INT,
+					      G_TYPE_STRING);
+
+	dbus_g_object_type_install_info (gc_iface_nmea_get_type (),
+					 &dbus_glib_gc_iface_nmea_object_info);
+}
+
+GType
+gc_iface_nmea_get_type (void)
+{
+	static GType type = 0;
+
+	if (!type) {
+		const GTypeInfo info = {
+			sizeof (GcIfaceNmeaClass),
+			gc_iface_nmea_base_init,
+			NULL,
+		};
+
+		type = g_type_register_static (G_TYPE_INTERFACE,
+					       "GcIfaceNmea", &info, 0);
+	}
+
+	return type;
+}
+
+static gboolean
+gc_iface_nmea_get_nmea (GcIfaceNmea *gc,
+			int         *timestamp,
+			char       **nmea_data,
+			GError     **error)
+{
+	return GC_IFACE_NMEA_GET_CLASS (gc)->get_nmea (gc, timestamp, nmea_data, error);
+}
+
+void
+gc_iface_nmea_emit_nmea_changed (GcIfaceNmea *gc,
+				 int          timestamp,
+				 char        *nmea_data)
+{
+	g_signal_emit (gc, signals[NMEA_CHANGED], 0, timestamp, nmea_data);
+}
Index: geoclue/geoclue/gc-iface-nmea.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/gc-iface-nmea.h	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,65 @@
+/*
+ * Geoclue
+ * gc-iface-nmea.h - GInterface for org.freedesktop.Geoclue.Nmea
+ *
+ * Author: Tae-Hwan Kim <the81.kim@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _GC_IFACE_NMEA_H
+#define _GC_IFACE_NMEA_H
+
+#include <geoclue/geoclue-types.h>
+
+G_BEGIN_DECLS
+
+#define GC_TYPE_IFACE_NMEA (gc_iface_nmea_get_type ())
+#define GC_IFACE_NMEA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GC_TYPE_IFACE_NMEA, GcIfaceNmea))
+#define GC_IFACE_NMEA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GC_TYPE_IFACE_NMEA, GcIfaceNmeaClass))
+#define GC_IS_IFACE_NMEA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GC_TYPE_IFACE_NMEA))
+#define GC_IS_IFACE_NMEA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GC_TYPE_IFACE_NMEA))
+#define GC_IFACE_NMEA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GC_TYPE_IFACE_NMEA, GcIfaceNmeaClass))
+
+typedef struct _GcIfaceNmea GcIfaceNmea; /* Dummy typedef */
+
+typedef struct _GcIfaceNmeaClass {
+        GTypeInterface base_iface;
+
+	/* signals */
+	void (* nmea_changed) (GcIfaceNmea *gc,
+			       int          timestamp,
+			       char        *nmea_data);
+
+	/* vtable */
+	gboolean (* get_nmea) (GcIfaceNmea *gc,
+			       int         *timestamp,
+			       char       **nmea_data,
+			       GError     **error);
+} GcIfaceNmeaClass;
+
+GType gc_iface_nmea_get_type (void);
+
+void gc_iface_nmea_emit_nmea_changed (GcIfaceNmea *gc,
+				      int timestamp,
+				      char *nmea_data);
+
+G_END_DECLS
+
+#endif
Index: geoclue/geoclue/gc-iface-satellite.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/gc-iface-satellite.c	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,123 @@
+/*
+ * Geoclue
+ * gc-iface-satellite.c - GInterface for org.freedesktop.Geoclue.Satellite
+ *
+ * Author: Sagnho Park <sangho.g.park@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <glib.h>
+
+#include <dbus/dbus-glib.h>
+#include <geoclue/gc-iface-satellite.h>
+#include <geoclue/geoclue-marshal.h>
+
+enum {
+	SATELLITE_CHANGED,
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = {0};
+
+static gboolean
+gc_iface_satellite_get_satellite (GcIfaceSatellite *satellite,
+				  int              *timestamp,
+				  int              *satellite_used,
+				  int              *satellite_visible,
+				  GArray          **used_prn,
+				  GPtrArray       **sat_info,
+				  GError          **error);
+
+#include "gc-iface-satellite-glue.h"
+
+static void
+gc_iface_satellite_base_init (gpointer klass)
+{
+	static gboolean initialized = FALSE;
+
+	if (initialized) {
+		return;
+	}
+	initialized = TRUE;
+
+	signals[SATELLITE_CHANGED] = g_signal_new ("satellite-changed",
+						   G_OBJECT_CLASS_TYPE (klass),
+						   G_SIGNAL_RUN_LAST, 0,
+						   NULL, NULL,
+						   geoclue_marshal_VOID__INT_INT_INT_POINTER_POINTER,
+						   G_TYPE_NONE, 5,
+						   G_TYPE_INT,
+						   G_TYPE_INT,
+						   G_TYPE_INT,
+						   DBUS_TYPE_G_INT_ARRAY,
+						   GEOCLUE_SATELLITE_INFO_ARRAY);
+	dbus_g_object_type_install_info (gc_iface_satellite_get_type (),
+					 &dbus_glib_gc_iface_satellite_object_info);
+}
+
+GType
+gc_iface_satellite_get_type (void)
+{
+	static GType type = 0;
+
+	if (!type) {
+		const GTypeInfo info = {
+			sizeof (GcIfaceSatelliteClass),
+			gc_iface_satellite_base_init,
+			NULL,
+		};
+
+		type = g_type_register_static (G_TYPE_INTERFACE,
+					       "GcIfaceSatellite", &info, 0);
+	}
+
+	return type;
+}
+
+static gboolean
+gc_iface_satellite_get_satellite (GcIfaceSatellite *gc,
+				  int              *timestamp,
+				  int              *satellite_used,
+				  int              *satellite_visible,
+				  GArray          **used_prn,
+				  GPtrArray       **sat_info,
+				  GError          **error)
+{
+	return GC_IFACE_SATELLITE_GET_CLASS (gc)->get_satellite (gc,
+								 timestamp,
+								 satellite_used,
+								 satellite_visible,
+								 used_prn,
+								 sat_info,
+								 error);
+}
+
+void
+gc_iface_satellite_emit_satellite_changed (GcIfaceSatellite *gc,
+					   int               timestamp,
+					   int               satellite_used,
+					   int               satellite_visible,
+					   GArray           *used_prn,
+					   GPtrArray        *sat_info)
+{
+	g_signal_emit (gc, signals[SATELLITE_CHANGED], 0,
+		       timestamp, satellite_used, satellite_visible,
+		       used_prn, sat_info);
+}
Index: geoclue/geoclue/gc-iface-satellite.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/gc-iface-satellite.h	2011-12-29 16:40:38.926428900 +0900
@@ -0,0 +1,76 @@
+/*
+ * Geoclue
+ * gc-iface-satellite.c - GInterface for org.freedesktop.Geoclue.Satellite
+ *
+ * Author: Sagnho Park <sangho.g.park@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _GC_IFACE_SATELLITE_H
+#define _GC_IFACE_SATELLITE_H
+
+#include <geoclue/geoclue-types.h>
+#include <geoclue/geoclue-satellite-info.h>
+
+G_BEGIN_DECLS
+
+#define GC_TYPE_IFACE_SATELLITE (gc_iface_satellite_get_type ())
+#define GC_IFACE_SATELLITE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GC_TYPE_IFACE_SATELLITE, GcIfaceSatellite))
+#define GC_IFACE_SATELLITE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GC_TYPE_IFACE_SATELLITE, GcIfaceSatelliteClass))
+#define GC_IS_IFACE_SATELLITE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GC_TYPE_IFACE_SATELLITE))
+#define GC_IS_IFACE_SATELLITE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GC_TYPE_IFACE_SATELLITE))
+#define GC_IFACE_SATELLITE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GC_TYPE_IFACE_SATELLITE, GcIfaceSatelliteClass))
+
+typedef struct _GcIfaceSatellite GcIfaceSatellite; /* Dummy typedef */
+typedef struct _GcIfaceSatelliteClass GcIfaceSatelliteClass;
+
+struct _GcIfaceSatelliteClass {
+        GTypeInterface base_iface;
+
+	/* signals */
+	void (* satellite_changed) (GcIfaceSatellite *gc,
+				    int               timestamp,
+				    int               satellite_used,
+				    int               satellite_visible,
+				    GArray           *used_prn,
+				    GPtrArray        *sat_info);
+
+	/* vtable */
+	gboolean (* get_satellite) (GcIfaceSatellite *gc,
+				    int              *timestamp,
+				    int              *satellite_used,
+				    int              *satellite_visible,
+				    GArray          **used_prn,
+				    GPtrArray       **sat_info,
+				    GError          **error);
+};
+
+GType gc_iface_satellite_get_type (void);
+
+void gc_iface_satellite_emit_satellite_changed (GcIfaceSatellite *gc,
+						int               timestamp,
+						int               satellite_used,
+						int               satellite_visible,
+						GArray           *used_prn,
+						GPtrArray        *sat_info);
+
+G_END_DECLS
+
+#endif
Index: geoclue/geoclue/gc-provider.c
===================================================================
--- geoclue.orig/geoclue/gc-provider.c	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/geoclue/gc-provider.c	2011-12-29 16:40:38.922428900 +0900
@@ -26,15 +26,15 @@
 /**
  * SECTION:gc-provider
  * @short_description: Abstract class to derive Geoclue providers from.
- * 
- * #GcProvider is an abstract class that all Geoclue providers should 
+ *
+ * #GcProvider is an abstract class that all Geoclue providers should
  * derive from. It takes care of setting up the provider D-Bus service,
- * and also implements #GcIfaceGeoclue interface (derived classes still 
+ * and also implements #GcIfaceGeoclue interface (derived classes still
  * need to implement the functionality).
- * 
- * Derived classes should define the #GcIfaceGeoclue methods in their 
+ *
+ * Derived classes should define the #GcIfaceGeoclue methods in their
  * class_init() and call gc_provider_set_details() in init()
- * 
+ *
  */
 #include <config.h>
 
@@ -52,7 +52,7 @@
 typedef struct {
 	char *name;
 	char *description;
-	
+
 	GHashTable *connections;
 } GcProviderPrivate;
 
@@ -79,9 +79,9 @@
 dispose (GObject *object)
 {
 	GcProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	g_hash_table_destroy (priv->connections);
-	
+
 	((GObjectClass *) gc_provider_parent_class)->dispose (object);
 }
 
@@ -92,9 +92,9 @@
 
 	o_class->finalize = finalize;
 	o_class->dispose = dispose;
-	
+
 	klass->shutdown = NULL;
-	
+
 	g_type_class_add_private (klass, sizeof (GcProviderPrivate));
 }
 
@@ -103,14 +103,14 @@
 {
 	GError *error = NULL;
 	GcProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	provider->connection = dbus_g_bus_get (GEOCLUE_DBUS_BUS, &error);
 	if (provider->connection == NULL) {
 		g_warning ("%s was unable to create a connection to D-Bus: %s",
 			   G_OBJECT_TYPE_NAME (provider), error->message);
 		g_error_free (error);
 	}
-	
+
 	priv->connections = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
 }
 
@@ -122,7 +122,7 @@
 }
 
 
-static gboolean 
+static gboolean
 get_provider_info (GcIfaceGeoclue *geoclue,
 		   gchar          **name,
 		   gchar          **description,
@@ -130,14 +130,14 @@
 {
 	GcProvider *provider = GC_PROVIDER (geoclue);
 	GcProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	if (name) {
 		*name = g_strdup (priv->name);
 	}
 	if (description) {
 		*description = g_strdup (priv->description);
 	}
-	
+
 	return TRUE;
 }
 
@@ -169,33 +169,59 @@
 	klass = GC_PROVIDER_GET_CLASS (geoclue);
 	if (klass->set_options) {
 		return klass->set_options (geoclue, options, error);
-	} 
+	}
 
         /* It is not an error to not have a SetOptions implementation */
         return TRUE;
 }
 
-static gboolean 
+static gboolean
 gc_provider_remove_client (GcProvider *provider, const char *client)
 {
 	int *pcount;
 	GcProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	pcount = g_hash_table_lookup (priv->connections, client);
 	if (!pcount) {
+		g_debug("Client[%s] is already removed", client);
 		return FALSE;
 	}
-	
 	(*pcount)--;
+	g_debug("Client[%s] has reference count[%d]", client, *pcount);
 	if (*pcount == 0) {
+		g_debug("Reference count is zero, Now remove client[%s] in hash table", client);
 		g_hash_table_remove (priv->connections, client);
 	}
 	if (g_hash_table_size (priv->connections) == 0) {
+		g_debug("Hash table size is zero, Now we shutdown provider[%s]", priv->name);
 		gc_provider_shutdown (provider);
 	}
 	return TRUE;
 }
 
+static gboolean
+gc_provider_remove_client_by_force(GcProvider *provider, const char *client)
+{
+	int *pcount;
+	GcProviderPrivate *priv = GET_PRIVATE (provider);
+
+	pcount = g_hash_table_lookup (priv->connections, client);
+	if(!pcount){
+		g_debug("Client(%s) is already removed", client);
+		return FALSE;
+	}
+
+	(*pcount)--;
+	g_debug("Client(%s) has reference count[%d]. Anway, we will remove it by force!", client, *pcount);
+	g_hash_table_remove (priv->connections, client);
+	if (g_hash_table_size (priv->connections) == 0) {
+		g_debug("Hash table size is zero, Now we shutdown provider[%s]", priv->name);
+		gc_provider_shutdown (provider);
+	}
+	return TRUE;
+}
+
+
 static void
 add_reference (GcIfaceGeoclue *geoclue,
                DBusGMethodInvocation *context)
@@ -203,7 +229,7 @@
 	GcProviderPrivate *priv = GET_PRIVATE (geoclue);
 	char *sender;
 	int *pcount;
-	
+
 	/* Update the hash of open connections */
 	sender = dbus_g_method_get_sender (context);
 	pcount = g_hash_table_lookup (priv->connections, sender);
@@ -212,24 +238,24 @@
 		g_hash_table_insert (priv->connections, sender, pcount);
 	}
 	(*pcount)++;
-	
+
 	dbus_g_method_return (context);
 }
 
-static void 
+static void
 remove_reference (GcIfaceGeoclue *geoclue,
                   DBusGMethodInvocation *context)
 {
 	GcProvider *provider = GC_PROVIDER (geoclue);
 	char *sender;
-	
+
 	sender = dbus_g_method_get_sender (context);
 	if (!gc_provider_remove_client (provider, sender)) {
 		g_warning ("Unreffed by client that has not been referenced");
 	}
 
 	g_free (sender);
-	
+
 	dbus_g_method_return (context);
 }
 
@@ -240,8 +266,9 @@
 		    const char  *new_owner,
 		    GcProvider  *provider)
 {
+	g_debug("name_owner_changed, name:%s, prev_owner:%s, new_owner:%s", name, prev_owner, new_owner);
 	if (strcmp (new_owner, "") == 0 && strcmp (name, prev_owner) == 0) {
-		if (gc_provider_remove_client (provider, prev_owner)) {
+		if (gc_provider_remove_client_by_force (provider, prev_owner)) {
 			g_warning ("Impolite client %s disconnected without unreferencing\n", prev_owner);
 		}
 	}
@@ -267,8 +294,8 @@
  * @description: The description of the provider
  *
  * Requests ownership of the @service name, and if that succeeds registers
- * @provider at @path. @name should be the name of the provider (e.g. 
- * "Hostip"), @description should be a short description of the provider 
+ * @provider at @path. @name should be the name of the provider (e.g.
+ * "Hostip"), @description should be a short description of the provider
  * (e.g. "Web service based Position & Address provider (http://hostip.info)").
  */
 void
@@ -295,23 +322,23 @@
 
 	if (!org_freedesktop_DBus_request_name (driver, service, 0,
 						&request_ret, &error)) {
-		g_warning ("%s was unable to register service %s: %s", 
-			   G_OBJECT_TYPE_NAME (provider), service, 
+		g_warning ("%s was unable to register service %s: %s",
+			   G_OBJECT_TYPE_NAME (provider), service,
 			   error->message);
 		g_error_free (error);
 		return;
 	}
-	
+
 	dbus_g_proxy_add_signal (driver, "NameOwnerChanged",
-				 G_TYPE_STRING, G_TYPE_STRING, 
+				 G_TYPE_STRING, G_TYPE_STRING,
 				 G_TYPE_STRING, G_TYPE_INVALID);
 	dbus_g_proxy_connect_signal (driver, "NameOwnerChanged",
 				     G_CALLBACK (name_owner_changed),
 				     provider, NULL);
-	
-	dbus_g_connection_register_g_object (provider->connection, 
+
+	dbus_g_connection_register_g_object (provider->connection,
 					     path, G_OBJECT (provider));
-	
+
 	priv->name = g_strdup (name);
 	priv->description = g_strdup (description);
 }
Index: geoclue/geoclue/gc-web-service.c
===================================================================
--- geoclue.orig/geoclue/gc-web-service.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/gc-web-service.c	2011-12-29 16:40:38.926428900 +0900
@@ -3,7 +3,7 @@
  * gc-web-service.c - A web service helper object for geoclue providers
  *
  * Author: Jussi Kukkonen <jku@o-hand.com>
- * 
+ *
  * Copyright 2007 Jussi Kukkonen (from old geoclue_web_service.c)
  * Copyright 2007, 2008 by Garmin Ltd. or its subsidiaries
  *
@@ -28,50 +28,50 @@
  * SECTION:gc-web-service
  * @short_description: Web service helper object for Geoclue providers.
  *
- * #GcWebService is a web service abstraction for Geoclue provider 
- * implementations. It handles basic http stuff and xml parsing 
- * (although the raw data is available through 
+ * #GcWebService is a web service abstraction for Geoclue provider
+ * implementations. It handles basic http stuff and xml parsing
+ * (although the raw data is available through
  * gc_web_service_get_response() as well).
- * 
- * At the moment xml parsing functions only exist for double and 
+ *
+ * At the moment xml parsing functions only exist for double and
  * char-array data types. Adding new functions is trivial, though.
  * <informalexample>
  * <programlisting>
  * . . .
- * 
+ *
  * #GcWebService *web_service;
  * web_service = g_object_new (GC_TYPE_WEB_SERVICE, NULL);
  * gc_web_service_set_base_url (web_service, "http://example.org");
- * 
- * / * Add namespaces if needed * / 
+ *
+ * / * Add namespaces if needed * /
  * gc_web_service_add_namespace (web_service,
  *                               "ns_name", "http://example.org/ns");
- * 
+ *
  * . . .
- * 
+ *
  * / * Fetch document "http://api.example.org?key1=val1&key2=val2" * /
- * if (!gc_web_service_query (web_service, 
+ * if (!gc_web_service_query (web_service,
  *                            "key1", "val1"
  *                            "key2", val2"
  *                            (char *)0)) {
  * 	/ * error * /
  * 	return;
  * }
- * 
+ *
  * / * Use XPath expressions to parse the xml in fetched document * /
  * gchar *str;
  * if (gc_web_service_get_string (web_service,
  *                                &str, "//path/to/element")) {
  * 	g_debug("got string: %s", str);
  * }
- * 
+ *
  * gdouble number;
  * if (gc_web_service_get_double (web_service,
  *                                &number, "//path/to/another/element")) {
  * 	g_debug("got double: %f", number);
  * }
- * 
- * . . . 
+ *
+ * . . .
  *
  * g_object_unref (G_OBJECT (web_service));
  * </programlisting>
@@ -101,8 +101,8 @@
 {
 	GcWebService *self = (GcWebService *)user_data;
 	XmlNamespace *ns = (XmlNamespace *)data;
-	
-	xmlXPathRegisterNs (self->xpath_ctx, 
+
+	xmlXPathRegisterNs (self->xpath_ctx,
 	                    (xmlChar*)ns->name, (xmlChar*)ns->uri);
 }
 
@@ -111,7 +111,7 @@
 gc_web_service_free_ns (gpointer data, gpointer user_data)
 {
 	XmlNamespace *ns = (XmlNamespace *)data;
-	
+
 	g_free (ns->name);
 	g_free (ns->uri);
 	g_free (ns);
@@ -132,7 +132,7 @@
 	g_free (self->response);
 	self->response = NULL;
 	self->response_length = 0;
-	
+
 	if (self->xpath_ctx) {
 		if (self->xpath_ctx->doc) {
 			xmlFreeDoc (self->xpath_ctx->doc);
@@ -142,19 +142,19 @@
 	}
 }
 
-/* Parse data (self->response), build xpath context and register 
+/* Parse data (self->response), build xpath context and register
  * namespaces. Nothing will be done if xpath context exists already. */
 static gboolean
 gc_web_service_build_xpath_context (GcWebService *self)
 {
 	xmlDocPtr doc;
 	xmlChar *tmp;
-	
+
 	/* don't rebuild if there's no need */
 	if (self->xpath_ctx) {
 		return TRUE;
 	}
-	
+
 	/* make sure response is NULL-terminated */
 	tmp = xmlStrndup(self->response, self->response_length);
 	doc = xmlParseDoc (tmp);
@@ -164,7 +164,7 @@
 		return FALSE;
 	}
 	xmlFree (tmp);
-	
+
 	self->xpath_ctx = xmlXPathNewContext(doc);
 	if (!self->xpath_ctx) {
 		/* TODO: error handling */
@@ -182,39 +182,39 @@
 	gint len;
 	xmlChar buf[1024];
 	xmlBuffer *output;
-	
+
 	g_assert (url);
-	
+
 	gc_web_service_reset (self);
-	
+
 	xmlNanoHTTPInit();
 	ctxt = xmlNanoHTTPMethod (url, "GET", NULL, NULL, NULL, 0);
 	if (!ctxt) {
-		g_set_error (error, GEOCLUE_ERROR,
-		             GEOCLUE_ERROR_NOT_AVAILABLE,
-		             "xmlNanoHTTPMethod did not get a response from %s\n", url);
+		*error = g_error_new (GEOCLUE_ERROR,
+		                      GEOCLUE_ERROR_NOT_AVAILABLE,
+		                      g_strdup_printf ("xmlNanoHTTPMethod did not get a response from %s\n", url));
 		return FALSE;
 	}
-	
+
 	output = xmlBufferCreate ();
 	while ((len = xmlNanoHTTPRead (ctxt, buf, sizeof(buf))) > 0) {
 		if (xmlBufferAdd (output, buf, len) != 0) {
 			xmlNanoHTTPClose(ctxt);
 			xmlBufferFree (output);
-			
-			g_set_error_literal (error, GEOCLUE_ERROR,
-			                     GEOCLUE_ERROR_FAILED,
-			                     "libxml error (xmlBufferAdd failed)");
-			
+
+			*error = g_error_new (GEOCLUE_ERROR,
+			                      GEOCLUE_ERROR_FAILED,
+			                      g_strdup_printf ("libxml error (xmlBufferAdd failed)"));
+
 			return FALSE;
 		}
 	}
 	xmlNanoHTTPClose(ctxt);
-	
+
 	self->response_length = xmlBufferLength (output);
 	self->response = g_memdup (xmlBufferContent (output), self->response_length);
 	xmlBufferFree (output);
-	
+
 	return TRUE;
 }
 
@@ -222,17 +222,17 @@
 gc_web_service_get_xpath_object (GcWebService *self, gchar* xpath)
 {
 	xmlXPathObject *obj = NULL;
-	
+
 	g_return_val_if_fail (xpath, FALSE);
-	
+
 	/* parse the doc if not parsed yet and register namespaces */
 	if (!gc_web_service_build_xpath_context (self)) {
 		return FALSE;
 	}
 	g_assert (self->xpath_ctx);
-	
+
 	obj = xmlXPathEvalExpression ((xmlChar*)xpath, self->xpath_ctx);
-	if (obj && 
+	if (obj &&
 	    (!obj->nodesetval || xmlXPathNodeSetIsEmpty (obj->nodesetval))) {
 		xmlXPathFreeObject (obj);
 		obj = NULL;
@@ -255,14 +255,14 @@
 gc_web_service_finalize (GObject *obj)
 {
 	GcWebService *self = (GcWebService *) obj;
-	
+
 	gc_web_service_reset (self);
-	
+
 	g_free (self->base_url);
-	
+
 	g_list_foreach (self->namespaces, (GFunc)gc_web_service_free_ns, NULL);
 	g_list_free (self->namespaces);
-	
+
 	((GObjectClass *) gc_web_service_parent_class)->finalize (obj);
 }
 
@@ -277,29 +277,29 @@
  * gc_web_service_set_base_url:
  * @self: The #GcWebService object
  * @url: base url
- * 
- * Sets base url for the web service. Must be called before calls to 
+ *
+ * Sets base url for the web service. Must be called before calls to
  * gc_web_service_get_* -methods.
  */
 void
 gc_web_service_set_base_url (GcWebService *self, gchar *url)
 {
 	g_assert (url);
-	
+
 	gc_web_service_reset (self);
-	
+
 	g_free (self->base_url);
 	self->base_url = g_strdup (url);
 }
- 
+
 /**
  * gc_web_service_add_namespace:
  * @self: The #GcWebService object
  * @namespace: Namespace name
- * @uri: Namespace uri 
- * 
- * Adds an xml namespace that will be used in all following calls to 
- * gc_web_service_get_*-functions. 
+ * @uri: Namespace uri
+ *
+ * Adds an xml namespace that will be used in all following calls to
+ * gc_web_service_get_*-functions.
  *
  * Return value: %TRUE on success.
  */
@@ -307,9 +307,9 @@
 gc_web_service_add_namespace (GcWebService *self, gchar *namespace, gchar *uri)
 {
 	XmlNamespace *ns;
-	
+
 	g_return_val_if_fail (self->base_url, FALSE);
-	
+
 	ns = g_new0 (XmlNamespace,1);
 	ns->name = g_strdup (namespace);
 	ns->uri = g_strdup (uri);
@@ -321,10 +321,10 @@
  * gc_web_service_query:
  * @self: A #GcWebService object
  * @Varargs: NULL-terminated list of key-value gchar* pairs
- * 
- * Fetches data from the web. The url is constructed using the 
- * optional arguments as GET parameters (see example in the 
- * Description-section). Data should be read using 
+ *
+ * Fetches data from the web. The url is constructed using the
+ * optional arguments as GET parameters (see example in the
+ * Description-section). Data should be read using
  * gc_web_service_get_* -functions.
  *
  * Return value: %TRUE on success.
@@ -335,19 +335,19 @@
 	va_list list;
 	gchar *key, *value, *esc_value, *tmp, *url;
 	gboolean first_pair = TRUE;
-	
+
 	g_return_val_if_fail (self->base_url, FALSE);
-	
+
 	url = g_strdup (self->base_url);
-	
+
 	/* read the arguments one key-value pair at a time,
 	   add the pairs to url as "?key1=value1&key2=value2&..." */
 	va_start (list, error);
 	key = va_arg (list, char*);
 	while (key) {
 		value = va_arg (list, char*);
-		esc_value = (gchar *)xmlURIEscapeStr ((xmlChar *)value, (xmlChar *)":");
-		
+		esc_value = (gchar *)xmlURIEscapeStr ((xmlChar *)value, NULL);
+
 		if (first_pair) {
 			tmp = g_strdup_printf ("%s?%s=%s",  url, key, esc_value);
 			first_pair = FALSE;
@@ -360,13 +360,13 @@
 		key = va_arg (list, char*);
 	}
 	va_end (list);
-	
+
 	if (!gc_web_service_fetch (self, url, error)) {
 		g_free (url);
 		return FALSE;
 	}
 	g_free (url);
-	
+
 	return TRUE;
 }
 
@@ -374,10 +374,10 @@
  * gc_web_service_get_double:
  * @self: A #GcWebService object
  * @value: Pointer to returned value
- * @xpath: XPath expression to find the value  
- * 
- * Extracts a @value from the data that was fetched in the last call 
- * to gc_web_service_query() using XPath expression @xpath. Returned 
+ * @xpath: XPath expression to find the value
+ *
+ * Extracts a @value from the data that was fetched in the last call
+ * to gc_web_service_query() using XPath expression @xpath. Returned
  * value is the first match.
  *
  * Return value: %TRUE if a value was found.
@@ -386,7 +386,7 @@
 gc_web_service_get_double (GcWebService *self, gdouble *value, gchar *xpath)
 {
 	xmlXPathObject *obj;
-	
+
 	obj = gc_web_service_get_xpath_object (self, xpath);
 	if (!obj) {
 		return FALSE;
@@ -400,10 +400,10 @@
  * gc_web_service_get_string:
  * @self: The #GcWebService object
  * @value: pointer to newly allocated string
- * @xpath: XPath expression used to find the value  
- * 
- * Extracts a @value from the data that was fetched in the last call 
- * to gc_web_service_query() using XPath expression @xpath (returned 
+ * @xpath: XPath expression used to find the value
+ *
+ * Extracts a @value from the data that was fetched in the last call
+ * to gc_web_service_query() using XPath expression @xpath (returned
  * value is the first match).
  *
  * Return value: %TRUE if a value was found.
@@ -412,7 +412,7 @@
 gc_web_service_get_string (GcWebService *self, gchar **value, gchar* xpath)
 {
 	xmlXPathObject *obj;
-	
+
 	obj = gc_web_service_get_xpath_object (self, xpath);
 	if (!obj) {
 		return FALSE;
@@ -427,8 +427,8 @@
  * @self: The #GcWebService object
  * @response: returned guchar array
  * @response_length: length of the returned array
- * 
- * Returns the raw data fetched with the last call to 
+ *
+ * Returns the raw data fetched with the last call to
  * gc_web_service_query(). Data may be unterminated.
  *
  * Return value: %TRUE on success.
Index: geoclue/geoclue/geoclue-marshal.list
===================================================================
--- geoclue.orig/geoclue/geoclue-marshal.list	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/geoclue-marshal.list	2011-12-29 16:40:38.926428900 +0900
@@ -5,3 +5,5 @@
 VOID:INT,POINTER,BOXED
 VOID:INT,BOXED,BOXED
 VOID:STRING,STRING,STRING,STRING
+VOID:INT,STRING
+VOID:INT,INT,INT,POINTER,POINTER
Index: geoclue/geoclue/geoclue-master-client.c
===================================================================
--- geoclue.orig/geoclue/geoclue-master-client.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/geoclue-master-client.c	2011-12-29 16:40:38.922428900 +0900
@@ -26,13 +26,13 @@
  * SECTION:geoclue-master-client
  * @short_description: Geoclue MasterClient API
  *
- * #GeoclueMasterClient is part of the Geoclue public C client API. It uses  
+ * #GeoclueMasterClient is part of the Geoclue public C client API. It uses
  * D-Bus to communicate with the actual Master service.
- * 
- * #GeoclueMasterClient is used to control the client specific behaviour 
+ *
+ * #GeoclueMasterClient is used to control the client specific behaviour
  * of Geoclue Master. Chapter "Master provider: simple example in C" contains a
  * more complete example, but here are the main parts:
- * 
+ *
  * <informalexample>
  * <programlisting>
  * GeoclueMaster *master;
@@ -40,10 +40,10 @@
  * GeoclueAddress *address;
  *
  * ...
- * 
+ *
  * master = geoclue_master_get_default ();
  * client = geoclue_master_create_client (master, NULL, NULL);
- * 
+ *
  * if (!geoclue_master_client_set_requirements (client,
  *                                              GEOCLUE_ACCURACY_LEVEL_NONE,
  *                                              0, FALSE,
@@ -51,13 +51,13 @@
  *                                              &error)) {
  * 	/ * handle error * /
  * }
- * 
+ *
  * address = geoclue_master_client_create_address (client, error);
  * if (!address) {
  * 	/ * handle error * /
  * }
- * 
- * / * Now we can use address just like we'd use a normal address provider, 
+ *
+ * / * Now we can use address just like we'd use a normal address provider,
  *     but GeoclueMasterClient makes sure that underneath the provider
  *     that best matches our requirements is used * /
  * </programlisting>
@@ -152,9 +152,9 @@
 static void
 address_provider_changed (DBusGProxy          *proxy,
                           char                *name,
-                          char                *description, 
-                          char                *service, 
-                          char                *path, 
+                          char                *description,
+                          char                *service,
+                          char                *path,
                           GeoclueMasterClient *client)
 {
 	g_signal_emit (client, signals[ADDRESS_PROVIDER_CHANGED], 0,
@@ -164,12 +164,12 @@
 static void
 position_provider_changed (DBusGProxy          *proxy,
                            char                *name,
-                           char                *description, 
-                           char                *service, 
-                           char                *path, 
+                           char                *description,
+                           char                *service,
+                           char                *path,
                            GeoclueMasterClient *client)
 {
-	g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0, 
+	g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0,
 	               name, description, service, path);
 }
 
@@ -228,7 +228,7 @@
 	dbus_g_proxy_connect_signal (priv->proxy, "AddressProviderChanged",
 	                             G_CALLBACK (address_provider_changed),
 	                             object, NULL);
-	
+
 	dbus_g_proxy_add_signal (priv->proxy, "PositionProviderChanged",
 	                         G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING,
 	                         G_TYPE_INVALID);
@@ -251,7 +251,7 @@
 
 	g_type_class_add_private (klass, sizeof (GeoclueMasterClientPrivate));
 
-	g_object_class_install_property 
+	g_object_class_install_property
 		(o_class, PROP_PATH,
 		 g_param_spec_string ("object-path",
 				      "Object path",
@@ -262,7 +262,7 @@
 				      G_PARAM_STATIC_NICK |
 				      G_PARAM_STATIC_BLURB |
 				      G_PARAM_STATIC_NAME));
-	
+
 	/**
 	* GeoclueMasterClient::address-provider-changed:
 	* @client: the #GeoclueMasterClient object emitting the signal
@@ -270,20 +270,20 @@
 	* @description: a short description of the new provider or %NULL if there is no provider
 	* @service: D-Bus service name of the new provider or %NULL if there is no provider
 	* @path: D-Bus object path name of the new provider or %NULL if there is no provider
-	* 
+	*
 	* The address-provider-changed signal is emitted each time the used address provider
 	* changes.
 	**/
-	signals[ADDRESS_PROVIDER_CHANGED] = 
+	signals[ADDRESS_PROVIDER_CHANGED] =
 		g_signal_new ("address-provider-changed",
 		              G_TYPE_FROM_CLASS (klass),
 		              G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE,
-		              G_STRUCT_OFFSET (GeoclueMasterClientClass, address_provider_changed), 
+		              G_STRUCT_OFFSET (GeoclueMasterClientClass, address_provider_changed),
 		              NULL, NULL,
 		              geoclue_marshal_VOID__STRING_STRING_STRING_STRING,
 		              G_TYPE_NONE, 4,
 		              G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-	
+
 	/**
 	* GeoclueMasterClient::position-provider-changed:
 	* @client: the #GeoclueMasterClient object emitting the signal
@@ -291,15 +291,15 @@
 	* @description: a short description of the new provider or %NULL if there is no provider
 	* @service: D-Bus service name of the new provider or %NULL if there is no provider
 	* @path: D-Bus object path name of the new provider or %NULL if there is no provider
-	* 
+	*
 	* The position-provider-changed signal is emitted each time the used position provider
 	* changes.
 	**/
-	signals[POSITION_PROVIDER_CHANGED] = 
+	signals[POSITION_PROVIDER_CHANGED] =
 		g_signal_new ("position-provider-changed",
 		              G_TYPE_FROM_CLASS (klass),
 		              G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE,
-		              G_STRUCT_OFFSET (GeoclueMasterClientClass, position_provider_changed), 
+		              G_STRUCT_OFFSET (GeoclueMasterClientClass, position_provider_changed),
 		              NULL, NULL,
 		              geoclue_marshal_VOID__STRING_STRING_STRING_STRING,
 		              G_TYPE_NONE, 4,
@@ -333,7 +333,7 @@
  * geoclue_master_client_set_requirements:
  * @client: A #GeoclueMasterClient
  * @min_accuracy: The required minimum accuracy as a #GeoclueAccuracyLevel.
- * @min_time: The minimum time between update signals in seconds
+ * @min_time: The minimum time between update signals (currently not implemented)
  * @require_updates: Whether the updates (signals) are required. Only applies to interfaces with signals
  * @allowed_resources: The resources that are allowed to be used as a #GeoclueResourceFlags
  * @error: A pointer to returned #GError or %NULL.
@@ -353,7 +353,7 @@
 	GeoclueMasterClientPrivate *priv;
 
 	priv = GET_PRIVATE (client);
-	if (!org_freedesktop_Geoclue_MasterClient_set_requirements 
+	if (!org_freedesktop_Geoclue_MasterClient_set_requirements
 	    (priv->proxy, min_accuracy, min_time, require_updates, allowed_resources, error)) {
 		return FALSE;
 	}
@@ -362,7 +362,7 @@
 }
 
 static void
-set_requirements_callback (DBusGProxy                   *proxy, 
+set_requirements_callback (DBusGProxy                   *proxy,
 			   GError                       *error,
 			   GeoclueMasterClientAsyncData *data)
 {
@@ -377,7 +377,7 @@
  * @client: A #GeoclueMasterClient object
  * @error: Error as #Gerror (may be %NULL)
  * @userdata: User data pointer set in geoclue_master_client_set_requirements_async()
- * 
+ *
  * Callback function for geoclue_master_client_set_requirements_async().
  */
 
@@ -389,11 +389,11 @@
  * @require_updates: Whether the updates (signals) are required. Only applies to interfaces with signals
  * @allowed_resources: The resources that are allowed to be used as a #GeoclueResourceFlags
  * @callback: #GeoclueSetRequirementsCallback function to call when requirements have been set
- * @userdata: User data pointer 
- * 
+ * @userdata: User data pointer
+ *
  * Asynchronous version of geoclue_master_client_set_requirements().
  */
-void 
+void
 geoclue_master_client_set_requirements_async (GeoclueMasterClient           *client,
 					      GeoclueAccuracyLevel           min_accuracy,
 					      int                            min_time,
@@ -404,12 +404,12 @@
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (client);
 	GeoclueMasterClientAsyncData *data;
-	
+
 	data = g_new (GeoclueMasterClientAsyncData, 1);
 	data->client = client;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_MasterClient_set_requirements_async
 			(priv->proxy,
 			 min_accuracy,
@@ -425,38 +425,38 @@
  * @client: A #GeoclueMasterClient
  * @error: A pointer to returned #GError or %NULL.
  *
- * Starts the GeoclueMasterClient address provider and returns 
+ * Starts the GeoclueMasterClient address provider and returns
  * a #GeoclueAddress that uses the same D-Bus object as the #GeoclueMasterClient.
  *
  * Return value: New #GeoclueAddress or %NULL on error
  */
 GeoclueAddress *
-geoclue_master_client_create_address (GeoclueMasterClient *client, 
+geoclue_master_client_create_address (GeoclueMasterClient *client,
                                       GError **error)
 {
 	GeoclueMasterClientPrivate *priv;
-	
+
 	priv = GET_PRIVATE (client);
-	
+
 	if (!org_freedesktop_Geoclue_MasterClient_address_start (priv->proxy, error)) {
 		return NULL;
 	}
-	
+
 	return geoclue_address_new (GEOCLUE_MASTER_DBUS_SERVICE, priv->object_path);
 }
 
 static void
-address_start_async_callback (DBusGProxy                   *proxy, 
+address_start_async_callback (DBusGProxy                   *proxy,
 			      GError                       *error,
 			      GeoclueMasterClientAsyncData *data)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (data->client);
 	GeoclueAddress *address = NULL;
-	
+
 	if (!error) {
 		address = geoclue_address_new (GEOCLUE_MASTER_DBUS_SERVICE, priv->object_path);
 	}
-	
+
 	(*(CreateAddressCallback)data->callback) (data->client,
 	                                          address,
 	                                          error,
@@ -470,7 +470,7 @@
  * @address: returned #GeoclueAddress
  * @error: Error as #Gerror (may be %NULL)
  * @userdata: User data pointer set in geoclue_master_client_create_address_async()
- * 
+ *
  * Callback function for geoclue_master_client_create_address_async().
  */
 
@@ -479,23 +479,23 @@
  * @client: A #GeoclueMasterClient object
  * @callback: A #CreateAddressCallback function that should be called when return values are available
  * @userdata: pointer for user specified data
- * 
+ *
  * Function returns (essentially) immediately and calls @callback when it has started the address provider
  * and a #GeoclueAddress is available.
  */
-void 
+void
 geoclue_master_client_create_address_async (GeoclueMasterClient  *client,
 					    CreateAddressCallback callback,
 					    gpointer              userdata)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (client);
 	GeoclueMasterClientAsyncData *data;
-	
+
 	data = g_new (GeoclueMasterClientAsyncData, 1);
 	data->client = client;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_MasterClient_address_start_async
 			(priv->proxy,
 			 (org_freedesktop_Geoclue_MasterClient_address_start_reply)address_start_async_callback,
@@ -508,7 +508,7 @@
  * @client: A #GeoclueMasterClient
  * @error: A pointer to returned #GError or %NULL.
  *
- * Starts the GeoclueMasterClient position provider and returns 
+ * Starts the GeoclueMasterClient position provider and returns
  * a #GeocluePosition that uses the same D-Bus object as the #GeoclueMasterClient.
  *
  * Return value: New #GeocluePosition or %NULL on error
@@ -518,9 +518,9 @@
                                        GError **error)
 {
 	GeoclueMasterClientPrivate *priv;
-	
+
 	priv = GET_PRIVATE (client);
-	
+
 	if (!org_freedesktop_Geoclue_MasterClient_position_start (priv->proxy, error)) {
 		return NULL;
 	}
@@ -529,17 +529,17 @@
 
 
 static void
-position_start_async_callback (DBusGProxy                   *proxy, 
+position_start_async_callback (DBusGProxy                   *proxy,
 			       GError                       *error,
 			       GeoclueMasterClientAsyncData *data)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (data->client);
 	GeocluePosition *position = NULL;
-	
+
 	if (!error) {
 		position = geoclue_position_new (GEOCLUE_MASTER_DBUS_SERVICE, priv->object_path);
 	}
-	
+
 	(*(CreatePositionCallback)data->callback) (data->client,
 	                                          position,
 	                                          error,
@@ -553,7 +553,7 @@
  * @position: returned #GeocluePosition
  * @error: Error as #Gerror (may be %NULL)
  * @userdata: User data pointer set in geoclue_master_client_create_position_async()
- * 
+ *
  * Callback function for geoclue_master_client_create_position_async().
  */
 
@@ -562,23 +562,23 @@
  * @client: A #GeoclueMasterClient object
  * @callback: A #CreatePositionCallback function that should be called when return values are available
  * @userdata: pointer for user specified data
- * 
+ *
  * Function returns (essentially) immediately and calls @callback when it has started the position provider
  * and a #GeocluePosition is available.
  */
-void 
+void
 geoclue_master_client_create_position_async (GeoclueMasterClient    *client,
 					     CreatePositionCallback  callback,
 					     gpointer                userdata)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (client);
 	GeoclueMasterClientAsyncData *data;
-	
+
 	data = g_new (GeoclueMasterClientAsyncData, 1);
 	data->client = client;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_MasterClient_position_start_async
 			(priv->proxy,
 			 (org_freedesktop_Geoclue_MasterClient_position_start_reply)position_start_async_callback,
@@ -594,9 +594,9 @@
  * @service: Pointer to returned D-Bus service name or %NULL
  * @path: Pointer to returned D-Bus object path or %NULL
  * @error: Pointer to returned #GError or %NULL
- * 
+ *
  * Gets name and other information for the currently used address provider.
- * 
+ *
  * Return value: %TRUE on success
  */
 gboolean geoclue_master_client_get_address_provider (GeoclueMasterClient  *client,
@@ -607,26 +607,26 @@
                                                      GError              **error)
 {
 	GeoclueMasterClientPrivate *priv;
-	
+
 	priv = GET_PRIVATE (client);
-	if (!org_freedesktop_Geoclue_MasterClient_get_address_provider 
+	if (!org_freedesktop_Geoclue_MasterClient_get_address_provider
 	    (priv->proxy, name, description, service, path, error)) {
 		return FALSE;
 	}
-	
+
 	return TRUE;
 }
 
 static void
-get_provider_callback (DBusGProxy *proxy, 
-                       char * name, 
-                       char * description, 
-                       char * service, 
-                       char * path, 
-                       GError *error, 
+get_provider_callback (DBusGProxy *proxy,
+                       char * name,
+                       char * description,
+                       char * service,
+                       char * path,
+                       GError *error,
                        GeoclueMasterClientAsyncData *data)
 {
-	
+
 	(*(GeoclueGetProviderCallback)data->callback) (data->client,
 	                                               name,
 	                                               description,
@@ -642,22 +642,22 @@
  * @client: A #GeoclueMasterClient
  * @callback: A #GeoclueGetProviderCallback function that will be called when return values are available
  * @userdata: pointer for user specified data
- * 
+ *
  * Gets name and other information for the currently used address provider asynchronously.
  */
-void 
+void
 geoclue_master_client_get_address_provider_async (GeoclueMasterClient  *client,
                                                   GeoclueGetProviderCallback  callback,
                                                   gpointer userdata)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (client);
 	GeoclueMasterClientAsyncData *data;
-	
+
 	data = g_new (GeoclueMasterClientAsyncData, 1);
 	data->client = client;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_MasterClient_get_address_provider_async
 			(priv->proxy,
 			 (org_freedesktop_Geoclue_MasterClient_get_address_provider_reply)get_provider_callback,
@@ -673,9 +673,9 @@
  * @service: Pointer to returned D-Bus service name or %NULL
  * @path: Pointer to returned D-Bus object path or %NULL
  * @error: Pointer to returned #GError or %NULL
- * 
+ *
  * Gets name and other information for the currently used position provider.
- * 
+ *
  * Return value: %TRUE on success
  */
 gboolean geoclue_master_client_get_position_provider (GeoclueMasterClient  *client,
@@ -686,13 +686,13 @@
                                                       GError              **error)
 {
 	GeoclueMasterClientPrivate *priv;
-	
+
 	priv = GET_PRIVATE (client);
-	if (!org_freedesktop_Geoclue_MasterClient_get_position_provider 
+	if (!org_freedesktop_Geoclue_MasterClient_get_position_provider
 	    (priv->proxy, name, description, service, path, error)) {
 		return FALSE;
 	}
-	
+
 	return TRUE;
 }
 
@@ -701,22 +701,22 @@
  * @client: A #GeoclueMasterClient
  * @callback: A #GeoclueGetProviderCallback function that will be called when return values are available
  * @userdata: pointer for user specified data
- * 
+ *
  * Gets name and other information for the currently used position provider asynchronously.
  */
-void 
+void
 geoclue_master_client_get_position_provider_async (GeoclueMasterClient  *client,
                                                    GeoclueGetProviderCallback  callback,
                                                    gpointer userdata)
 {
 	GeoclueMasterClientPrivate *priv = GET_PRIVATE (client);
 	GeoclueMasterClientAsyncData *data;
-	
+
 	data = g_new (GeoclueMasterClientAsyncData, 1);
 	data->client = client;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_MasterClient_get_position_provider_async
 			(priv->proxy,
 			 (org_freedesktop_Geoclue_MasterClient_get_position_provider_reply)get_provider_callback,
Index: geoclue/geoclue/geoclue-nmea.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/geoclue-nmea.c	2011-12-29 16:40:38.926428900 +0900
@@ -0,0 +1,211 @@
+/*
+ * Geoclue
+ * geoclue-nmea.c - Client API for accessing GcIfaceNmea
+ *
+ * Author: Tae-Hwan Kim <the81.kim@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+/**
+ * SECTION:geoclue-nmea
+ * @short_description: Geoclue nmea client API
+ *
+ * #GeoclueNmea contains nmea-related methods and signals.
+ * It is part of the Geoclue public C client API which uses D-Bus
+ * to communicate with the actual provider.
+ *
+ * After a #GeoclueNmea is created with geoclue_nmea_new() or
+ * using geoclye_master_client_create_nmea(), the
+ * geoclue_nmea_get_nmea() and geoclue_nmea_get_nmea_async()
+ * method and the nmea-changed signal can be used to obtain the current nmea.
+ */
+
+#include <geoclue/geoclue-nmea.h>
+#include <geoclue/geoclue-marshal.h>
+
+#include "gc-iface-nmea-bindings.h"
+
+//#include <glib.h>
+#include <string.h>
+
+typedef struct _GeoclueNmeaPrivate {
+	int dummy;
+} GeoclueNmeaPrivate;
+
+enum {
+	NMEA_CHANGED,
+	LAST_SIGNAL
+};
+
+static guint32 signals[LAST_SIGNAL] = {0, };
+
+#define GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEOCLUE_TYPE_NMEA, GeoclueNmeaPrivate))
+
+G_DEFINE_TYPE (GeoclueNmea, geoclue_nmea, GEOCLUE_TYPE_PROVIDER);
+
+static void
+finalize (GObject *object)
+{
+	G_OBJECT_CLASS (geoclue_nmea_parent_class)->finalize (object);
+}
+
+static void
+dispose (GObject *object)
+{
+	G_OBJECT_CLASS (geoclue_nmea_parent_class)->dispose (object);
+}
+
+static void
+nmea_changed (DBusGProxy      *proxy,
+	      int              timestamp,
+	      char             *nmea_data,
+	      GeoclueNmea *nmea)
+{
+	g_signal_emit (nmea, signals[NMEA_CHANGED], 0,
+		       timestamp, nmea_data);
+}
+
+static GObject *
+constructor (GType                  type,
+	     guint                  n_props,
+	     GObjectConstructParam *props)
+{
+	GObject *object;
+	GeoclueProvider *provider;
+
+	object = G_OBJECT_CLASS (geoclue_nmea_parent_class)->constructor (type, n_props, props);
+	provider = GEOCLUE_PROVIDER (object);
+
+	dbus_g_proxy_add_signal (provider->proxy, "NmeaChanged",
+				 G_TYPE_INT,
+				 G_TYPE_STRING,
+				 G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (provider->proxy, "NmeaChanged",
+				     G_CALLBACK (nmea_changed),
+				     object, NULL);
+
+	return object;
+}
+
+static void
+geoclue_nmea_class_init (GeoclueNmeaClass *klass)
+{
+	GObjectClass *o_class = (GObjectClass *) klass;
+
+	o_class->finalize = finalize;
+	o_class->dispose = dispose;
+	o_class->constructor = constructor;
+
+	g_type_class_add_private (klass, sizeof (GeoclueNmeaPrivate));
+
+	signals[NMEA_CHANGED] = g_signal_new ("nmea-changed",
+					      G_TYPE_FROM_CLASS (klass),
+					      G_SIGNAL_RUN_FIRST |
+					      G_SIGNAL_NO_RECURSE,
+					      G_STRUCT_OFFSET (GeoclueNmeaClass, nmea_changed),
+					      NULL, NULL,
+					      geoclue_marshal_VOID__INT_STRING,
+					      G_TYPE_NONE, 2,
+					      G_TYPE_INT,
+					      G_TYPE_STRING);
+}
+
+static void
+geoclue_nmea_init (GeoclueNmea *nmea)
+{
+}
+
+/**
+ * geoclue_nmea_new:
+ * @service: D-Bus service name
+ * @path: D-Bus path name
+ *
+ * Creates a #GeoclueNmea with given D-Bus service name and path.
+ *
+ * Return value: Pointer to a new #GeoclueNmea
+ */
+GeoclueNmea *
+geoclue_nmea_new (const char *service,
+		      const char *path)
+{
+	return g_object_new (GEOCLUE_TYPE_NMEA,
+			     "service", service,
+			     "path", path,
+			     "interface", GEOCLUE_NMEA_INTERFACE_NAME,
+			     NULL);
+}
+
+gboolean
+geoclue_nmea_get_nmea (GeoclueNmea  *nmea,
+		       int          *timestamp,
+		       char        **nmea_data,
+		       GError      **error)
+{
+	GeoclueProvider *provider = GEOCLUE_PROVIDER (nmea);
+
+	if (!org_freedesktop_Geoclue_Nmea_get_nmea (provider->proxy,
+						    timestamp,
+						    nmea_data,
+						    error)) {
+		return FALSE;
+	}
+	return TRUE;
+}
+
+
+typedef struct _GeoclueNmeaAsyncData {
+	GeoclueNmea *nmea;
+	GCallback callback;
+	gpointer userdata;
+} GeoclueNmeaAsyncData;
+
+static void
+get_nmea_async_callback (DBusGProxy           *proxy,
+			 int                   timestamp,
+			 char                 *nmea_data,
+			 GError               *error,
+			 GeoclueNmeaAsyncData *data)
+{
+	(*(GeoclueNmeaCallback)data->callback) (data->nmea,
+						timestamp,
+						nmea_data,
+						error,
+						data->userdata);
+	g_free (data);
+}
+
+void
+geoclue_nmea_get_nmea_async (GeoclueNmea         *nmea,
+			     GeoclueNmeaCallback  callback,
+			     gpointer             userdata)
+{
+	GeoclueProvider *provider = GEOCLUE_PROVIDER (nmea);
+	GeoclueNmeaAsyncData *data;
+
+	data = g_new (GeoclueNmeaAsyncData, 1);
+	data->nmea = nmea;
+	data->callback = G_CALLBACK (callback);
+	data->userdata = userdata;
+
+	org_freedesktop_Geoclue_Nmea_get_nmea_async (
+			provider->proxy,
+			(org_freedesktop_Geoclue_Nmea_get_nmea_reply)get_nmea_async_callback,
+			data);
+}
Index: geoclue/geoclue/geoclue-nmea.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/geoclue-nmea.h	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,78 @@
+/*
+ * Geoclue
+ * geoclue-nmea.h -
+ *
+ * Author: Tae-Hwan Kim <the81.kim@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef _GEOCLUE_NMEA_H
+#define _GEOCLUE_NMEA_H
+
+#include <geoclue/geoclue-provider.h>
+#include <geoclue/geoclue-types.h>
+//#include <geoclue/geoclue-accuracy.h>
+
+G_BEGIN_DECLS
+
+#define GEOCLUE_TYPE_NMEA (geoclue_nmea_get_type ())
+#define GEOCLUE_NMEA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOCLUE_TYPE_NMEA, GeoclueNmea))
+#define GEOCLUE_IS_NMEA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOCLUE_TYPE_NMEA))
+
+#define GEOCLUE_NMEA_INTERFACE_NAME "org.freedesktop.Geoclue.Nmea"
+
+#define GEOCLUE_MAX_NMEA_DATA_SIZE (1500)
+
+typedef struct _GeoclueNmea {
+	GeoclueProvider provider;
+} GeoclueNmea;
+
+typedef struct _GeoclueNmeaClass {
+	GeoclueProviderClass provider_class;
+
+	void (* nmea_changed) (GeoclueNmea *nmea,
+			       int          timestamp,
+			       char         nmea_data[GEOCLUE_MAX_NMEA_DATA_SIZE]);
+} GeoclueNmeaClass;
+
+GType geoclue_nmea_get_type (void);
+
+GeoclueNmea *geoclue_nmea_new (const char *service,
+			       const char *path);
+
+gboolean geoclue_nmea_get_nmea (GeoclueNmea *nmea,
+				int         *timestamp,
+				char       **nmea_data,
+				GError     **error);
+
+typedef void (*GeoclueNmeaCallback) (GeoclueNmea *nmea,
+				     int          timestamp,
+				     char        *nmea_data,
+				     GError      *error,
+				     gpointer     userdata);
+
+void geoclue_nmea_get_nmea_async (GeoclueNmea         *nmea,
+				  GeoclueNmeaCallback  callback,
+				  gpointer             userdata);
+
+G_END_DECLS
+
+#endif
Index: geoclue/geoclue/geoclue-provider.c
===================================================================
--- geoclue.orig/geoclue/geoclue-provider.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/geoclue-provider.c	2011-12-29 16:40:38.922428900 +0900
@@ -40,8 +40,8 @@
  * GeocluePosition *pos;
  * char *name;
  * GError *error;
- * 
- * pos = geoclue_position_new ("org.freedesktop.Geoclue.Providers.Example", 
+ *
+ * pos = geoclue_position_new ("org.freedesktop.Geoclue.Providers.Example",
  *                             "/org/freedesktop/Geoclue/Providers/Example");
  *
  * if (geoclue_provider_get_provider_info (GEOCLUE_PROVIDER (pos),
@@ -50,12 +50,11 @@
  * }
  * </programlisting>
  * </informalexample>
- * 
+ *
  * #GeoclueProvider can be used to obtain  generic
  * information about the provider and to set provider
  * options.
  */
-#include <config.h>
 
 #include <geoclue/geoclue-provider.h>
 #include "gc-iface-geoclue-bindings.h"
@@ -68,7 +67,7 @@
 
 typedef struct _GeoclueProviderPrivate {
 	DBusGProxy *geoclue_proxy;
-	
+
 	char *service;
 	char *path;
 	char *interface;
@@ -105,7 +104,7 @@
 add_reference_callback (DBusGProxy *proxy, GError *error, gpointer userdata)
 {
 	if (error) {
-		g_printerr ("Could not reference provider: %s", error->message);
+		g_printerr ("Could not reference provider: %s\n", error->message);
 		g_error_free (error);
 	}
 }
@@ -114,7 +113,7 @@
 remove_reference_callback (DBusGProxy *proxy, GError *error, gpointer userdata)
 {
 	if (error) {
-		g_printerr ("Could not unreference provider: %s", error->message);
+		g_printerr ("Could not unreference provider: %s\n", error->message);
 		g_error_free (error);
 	}
 }
@@ -123,11 +122,11 @@
 finalize (GObject *object)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	g_free (priv->service);
 	g_free (priv->path);
 	g_free (priv->interface);
-	
+
 	G_OBJECT_CLASS (geoclue_provider_parent_class)->finalize (object);
 }
 
@@ -136,7 +135,7 @@
 {
 	GeoclueProvider *provider = GEOCLUE_PROVIDER (object);
 	GeoclueProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	org_freedesktop_Geoclue_remove_reference_async (priv->geoclue_proxy,
 	                                                remove_reference_callback,
 	                                                NULL);
@@ -144,12 +143,12 @@
 		g_object_unref (priv->geoclue_proxy);
 		priv->geoclue_proxy = NULL;
 	}
-	
+
 	if (provider->proxy) {
 		g_object_unref (provider->proxy);
 		provider->proxy = NULL;
 	}
-	
+
 	G_OBJECT_CLASS (geoclue_provider_parent_class)->dispose (object);
 }
 
@@ -163,31 +162,34 @@
 	GeoclueProviderPrivate *priv;
 	DBusGConnection *connection;
 	GError *error = NULL;
-	
+
 	object = G_OBJECT_CLASS (geoclue_provider_parent_class)->constructor
 		(type, n_props, props);
 	provider = GEOCLUE_PROVIDER (object);
 	priv = GET_PRIVATE (provider);
-	
-	connection = dbus_g_bus_get (GEOCLUE_DBUS_BUS, &error);
+
+	// There is a crash due to DBUS_BUS_SESSION
+    //connection = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
+    connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+
 	if (connection == NULL) {
 		g_printerr ("Failed to open connection to bus: %s\n",
 		            error->message);
 		g_error_free (error);
 		provider->proxy = NULL;
 		priv->geoclue_proxy = NULL;
-		
+
 		return object;
 	}
-	
+
 	/* proxy for the requested interface */
-	provider->proxy = dbus_g_proxy_new_for_name (connection, 
-	                                           priv->service, priv->path, 
+	provider->proxy = dbus_g_proxy_new_for_name (connection,
+	                                           priv->service, priv->path,
 	                                           priv->interface);
-	
+
 	/* proxy for org.freedesktop.Geoclue */
-	priv->geoclue_proxy = dbus_g_proxy_new_for_name (connection, 
-	                                                 priv->service, priv->path, 
+	priv->geoclue_proxy = dbus_g_proxy_new_for_name (connection,
+	                                                 priv->service, priv->path,
 	                                                 GEOCLUE_INTERFACE_NAME);
 	org_freedesktop_Geoclue_add_reference_async (priv->geoclue_proxy,
 	                                             add_reference_callback,
@@ -197,10 +199,10 @@
 	dbus_g_proxy_connect_signal (priv->geoclue_proxy, "StatusChanged",
 	                             G_CALLBACK (status_changed),
 	                             object, NULL);
-	
+
 	return object;
 }
-	
+
 static void
 set_property (GObject      *object,
               guint         prop_id,
@@ -208,20 +210,20 @@
               GParamSpec   *pspec)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	switch (prop_id) {
 	case PROP_SERVICE:
 		priv->service = g_value_dup_string (value);
 		break;
-	
+
 	case PROP_PATH:
 		priv->path = g_value_dup_string (value);
 		break;
-	
+
 	case PROP_INTERFACE:
 		priv->interface = g_value_dup_string (value);
 		break;
-	
+
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -244,15 +246,15 @@
 geoclue_provider_class_init (GeoclueProviderClass *klass)
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
-	
+
 	o_class->finalize = finalize;
 	o_class->dispose = dispose;
 	o_class->constructor = constructor;
 	o_class->set_property = set_property;
 	o_class->get_property = get_property;
-	
+
 	g_type_class_add_private (klass, sizeof (GeoclueProviderPrivate));
-	
+
 	g_object_class_install_property
 		(o_class, PROP_SERVICE,
 		 g_param_spec_string ("service", "Service",
@@ -280,7 +282,7 @@
 				      G_PARAM_STATIC_NICK |
 				      G_PARAM_STATIC_BLURB |
 				      G_PARAM_STATIC_NAME));
-	
+
 	/**
  	* GeoclueProvider::status-changed:
 	* @provider: the provider object emitting the signal
@@ -293,7 +295,7 @@
 						G_TYPE_FROM_CLASS (klass),
 						G_SIGNAL_RUN_FIRST |
 						G_SIGNAL_NO_RECURSE,
-						G_STRUCT_OFFSET (GeoclueProviderClass, status_changed), 
+						G_STRUCT_OFFSET (GeoclueProviderClass, status_changed),
 						NULL, NULL,
 						g_cclosure_marshal_VOID__INT,
 						G_TYPE_NONE, 1, G_TYPE_INT);
@@ -304,7 +306,7 @@
 geoclue_provider_init (GeoclueProvider *provider)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	provider->proxy = NULL;
 	priv->geoclue_proxy = NULL;
 }
@@ -314,9 +316,9 @@
  * @provider: A #GeoclueProvider object
  * @status: Pointer for returned status as #GeoclueStatus
  * @error:  Pointer for returned #GError or %NULL
- * 
+ *
  * Obtains the current status of the provider.
- * 
+ *
  * Return value: %TRUE on success
  */
 gboolean
@@ -326,12 +328,12 @@
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
 	int i;
-	
+
 	if (status == NULL) {
 		return TRUE;
 	}
-	
-	if (!org_freedesktop_Geoclue_get_status (priv->geoclue_proxy, 
+
+	if (!org_freedesktop_Geoclue_get_status (priv->geoclue_proxy,
 	                                         &i, error)) {
 		return FALSE;
 	}
@@ -340,9 +342,9 @@
 }
 
 static void
-get_status_async_callback (DBusGProxy               *proxy, 
-                           GeoclueStatus             status, 
-                           GError                   *error, 
+get_status_async_callback (DBusGProxy               *proxy,
+                           GeoclueStatus             status,
+                           GError                   *error,
                            GeoclueProviderAsyncData *data)
 {
 	(*(GeoclueProviderStatusCallback)data->callback) (data->provider,
@@ -350,7 +352,7 @@
 	                                                  error,
 	                                                  data->userdata);
 	g_free (data);
-	
+
 }
 
 /**
@@ -359,7 +361,7 @@
  * @status: A #GeoclueStatus
  * @error: Error as #GError or %NULL
  * @userdata: User data pointer set in geoclue_provider_get_status_async()
- * 
+ *
  * Callback function for geoclue_provider_get_status_async().
  */
 
@@ -368,24 +370,24 @@
  * @provider: A #GeoclueProvider object
  * @callback: A #GeoclueProviderStatusCallback function that will be called when return values are available
  * @userdata: pointer for user specified data
- * 
- * Asynchronous version of geoclue_provider_get_status(). Function returns 
- * (essentially) immediately and calls @callback when status is available or 
+ *
+ * Asynchronous version of geoclue_provider_get_status(). Function returns
+ * (essentially) immediately and calls @callback when status is available or
  * when there is an error.
  */
-void 
+void
 geoclue_provider_get_status_async (GeoclueProvider               *provider,
                                    GeoclueProviderStatusCallback  callback,
                                    gpointer                       userdata)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
 	GeoclueProviderAsyncData *data;
-	
+
 	data = g_new (GeoclueProviderAsyncData, 1);
 	data->provider = provider;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_get_status_async
 			(priv->geoclue_proxy,
 			 (org_freedesktop_Geoclue_get_status_reply)get_status_async_callback,
@@ -409,18 +411,18 @@
                               GError          **error)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	if (options == NULL) {
 		return TRUE;
 	}
-	
-	return org_freedesktop_Geoclue_set_options (priv->geoclue_proxy, 
+
+	return org_freedesktop_Geoclue_set_options (priv->geoclue_proxy,
 	                                            options, error);
 }
 
 static void
-set_options_async_callback (DBusGProxy               *proxy, 
-                            GError                   *error, 
+set_options_async_callback (DBusGProxy               *proxy,
+                            GError                   *error,
                             GeoclueProviderAsyncData *data)
 {
 	(*(GeoclueProviderOptionsCallback)data->callback) (data->provider,
@@ -434,7 +436,7 @@
  * @provider: A #GeoclueProvider object
  * @error: Error as #GError or %NULL
  * @userdata: User data pointer set in geoclue_provider_set_options_async()
- * 
+ *
  * Callback function for geoclue_provider_set_options_async().
  */
 
@@ -444,12 +446,12 @@
  * @options: A #GHashTable of options
  * @callback: A #GeoclueProviderOptionsCallback function that will be called when options are set
  * @userdata: pointer for user specified data
- * 
- * Asynchronous version of geoclue_provider_set_options(). Function returns 
- * (essentially) immediately and calls @callback when options have been set or 
+ *
+ * Asynchronous version of geoclue_provider_set_options(). Function returns
+ * (essentially) immediately and calls @callback when options have been set or
  * when there is an error.
  */
-void 
+void
 geoclue_provider_set_options_async (GeoclueProvider                *provider,
                                     GHashTable                     *options,
                                     GeoclueProviderOptionsCallback  callback,
@@ -457,12 +459,12 @@
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
 	GeoclueProviderAsyncData *data;
-	
+
 	data = g_new (GeoclueProviderAsyncData, 1);
 	data->provider = provider;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_set_options_async
 			(priv->geoclue_proxy,
 			 options,
@@ -476,9 +478,9 @@
  * @name: Pointer for returned provider name or %NULL
  * @description: Pointer for returned provider description or %NULL
  * @error:  Pointer for returned #GError or %NULL
- * 
+ *
  * Obtains name and a short description of the provider.
- * 
+ *
  * Return value: %TRUE on success
  */
 gboolean
@@ -488,17 +490,17 @@
                                     GError          **error)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return org_freedesktop_Geoclue_get_provider_info (priv->geoclue_proxy,
 	                                                  name, description,
 	                                                  error);
 }
 
 static void
-get_provider_info_async_callback (DBusGProxy               *proxy, 
+get_provider_info_async_callback (DBusGProxy               *proxy,
                                   char                     *name,
                                   char                     *description,
-                                  GError                   *error, 
+                                  GError                   *error,
                                   GeoclueProviderAsyncData *data)
 {
 	(*(GeoclueProviderInfoCallback)data->callback) (data->provider,
@@ -516,7 +518,7 @@
  * @description: one-line description of the provider
  * @error: Error as #GError or %NULL
  * @userdata: User data pointer set in geoclue_provider_get_provider_info_async()
- * 
+ *
  * Callback function for geoclue_provider_get_provider_info_async().
  */
 
@@ -525,24 +527,24 @@
  * @provider: A #GeoclueProvider object
  * @callback: A #GeoclueProviderInfoCallback function that will be called when info is available
  * @userdata: pointer for user specified data
- * 
- * Asynchronous version of geoclue_provider_get_provider_info(). Function returns 
- * (essentially) immediately and calls @callback when info is available or 
+ *
+ * Asynchronous version of geoclue_provider_get_provider_info(). Function returns
+ * (essentially) immediately and calls @callback when info is available or
  * when there is an error.
  */
-void 
+void
 geoclue_provider_get_provider_info_async (GeoclueProvider             *provider,
                                           GeoclueProviderInfoCallback  callback,
                                           gpointer                     userdata)
 {
 	GeoclueProviderPrivate *priv = GET_PRIVATE (provider);
 	GeoclueProviderAsyncData *data;
-	
+
 	data = g_new (GeoclueProviderAsyncData, 1);
 	data->provider = provider;
 	data->callback = G_CALLBACK (callback);
 	data->userdata = userdata;
-	
+
 	org_freedesktop_Geoclue_get_provider_info_async
 			(priv->geoclue_proxy,
 			 (org_freedesktop_Geoclue_get_provider_info_reply)get_provider_info_async_callback,
Index: geoclue/geoclue/geoclue-satellite-info.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/geoclue-satellite-info.h	2011-12-29 16:40:38.926428900 +0900
@@ -0,0 +1,40 @@
+/*
+ * Geoclue
+ * gc-iface-satellite.c - GInterface for org.freedesktop.Geoclue.Satellite
+ *
+ * Author: Sagnho Park <sangho.g.park@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _GEOCLUE_SATELLITE_INFO_H
+#define _GEOCLUE_SATELLITE_INFO_H
+
+#include <geoclue/geoclue-provider.h>
+#include <geoclue/geoclue-types.h>
+
+G_BEGIN_DECLS
+
+#define GEOCLUE_SATELLITE_INFO (dbus_g_type_get_struct ("GValueArray", G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INVALID))
+#define GEOCLUE_SATELLITE_INFO_ARRAY (dbus_g_type_get_collection ("GPtrArray", GEOCLUE_SATELLITE_INFO))
+
+G_END_DECLS
+
+#endif
+
Index: geoclue/geoclue/geoclue-satellite.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/geoclue-satellite.c	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,199 @@
+/*
+ * Geoclue
+ * geoclue-satellite.c - Client API for accessing GcIfaceSatellite
+ *
+ * Author: Sagnho Park <sangho.g.park@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <geoclue/geoclue-satellite.h>
+#include <geoclue/geoclue-marshal.h>
+
+#include "gc-iface-satellite-bindings.h"
+
+typedef struct _GeoclueSatellitePrivate {
+	int dummy;
+} GeoclueSatellitePrivate;
+
+enum {
+	SATELLITE_CHANGED,
+	LAST_SIGNAL
+};
+
+static guint32 signals[LAST_SIGNAL] = {0, };
+
+#define GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEOCLUE_TYPE_SATELLITE, GeoclueSatellitePrivate))
+
+G_DEFINE_TYPE (GeoclueSatellite, geoclue_satellite, GEOCLUE_TYPE_PROVIDER);
+
+static void
+finalize (GObject *object)
+{
+	G_OBJECT_CLASS (geoclue_satellite_parent_class)->finalize (object);
+}
+
+static void
+dispose (GObject *object)
+{
+	G_OBJECT_CLASS (geoclue_satellite_parent_class)->dispose (object);
+}
+
+static void
+satellite_changed (DBusGProxy       *proxy,
+		   int               timestamp,
+		   int               satellite_used,
+		   int               satellite_visible,
+		   GArray           *used_prn,
+		   GPtrArray        *sat_info,
+		   GeoclueSatellite *satellite)
+{
+	g_signal_emit (satellite, signals[SATELLITE_CHANGED], 0, timestamp, satellite_used, satellite_visible,
+		       used_prn,sat_info);
+}
+
+static GObject *
+constructor (GType                  type,
+	     guint                  n_props,
+	     GObjectConstructParam *props)
+{
+	GObject *object;
+	GeoclueProvider *provider;
+
+	object = G_OBJECT_CLASS (geoclue_satellite_parent_class)->constructor (type, n_props, props);
+	provider = GEOCLUE_PROVIDER (object);
+
+	dbus_g_proxy_add_signal (provider->proxy, "SatelliteChanged",
+				 G_TYPE_INT,
+				 G_TYPE_INT,
+				 G_TYPE_INT,
+				 DBUS_TYPE_G_INT_ARRAY,
+				 GEOCLUE_SATELLITE_INFO_ARRAY,
+				 G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (provider->proxy, "SatelliteChanged",
+				     G_CALLBACK (satellite_changed),
+				     object, NULL);
+
+	return object;
+}
+
+static void
+geoclue_satellite_class_init (GeoclueSatelliteClass *klass)
+{
+	GObjectClass *o_class = (GObjectClass *) klass;
+
+	o_class->finalize = finalize;
+	o_class->dispose = dispose;
+	o_class->constructor = constructor;
+
+	g_type_class_add_private (klass, sizeof (GeoclueSatellitePrivate));
+
+	signals[SATELLITE_CHANGED] = g_signal_new ("satellite-changed",
+						   G_TYPE_FROM_CLASS (klass),
+						   G_SIGNAL_RUN_FIRST |
+						   G_SIGNAL_NO_RECURSE,
+						   G_STRUCT_OFFSET (GeoclueSatelliteClass, satellite_changed),
+						   NULL, NULL,
+						   geoclue_marshal_VOID__INT_INT_INT_POINTER_POINTER,
+						   G_TYPE_NONE, 5,
+						   G_TYPE_INT, G_TYPE_INT, G_TYPE_INT,
+						   G_TYPE_POINTER, G_TYPE_POINTER);
+}
+
+static void
+geoclue_satellite_init (GeoclueSatellite *satellite)
+{
+}
+
+GeoclueSatellite *
+geoclue_satellite_new (const char *service,
+		       const char *path)
+{
+	return g_object_new (GEOCLUE_TYPE_SATELLITE,
+			     "service", service,
+			     "path", path,
+			     "interface", GEOCLUE_SATELLITE_INTERFACE_NAME,
+			     NULL);
+}
+
+gboolean
+geoclue_satellite_get_satellite (GeoclueSatellite *satellite,
+				 int              *timestamp,
+				 int              *satellite_used,
+				 int              *satellite_visible,
+				 GArray          **used_prn,
+				 GPtrArray       **sat_info,
+				 GError          **error)
+{
+	GeoclueProvider *provider = GEOCLUE_PROVIDER (satellite);
+	if (!org_freedesktop_Geoclue_Satellite_get_satellite (provider->proxy,
+							      timestamp, satellite_used, satellite_visible,
+							      used_prn, sat_info, error)) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+typedef struct _GeoclueSatelliteAsyncData {
+	GeoclueSatellite *satellite;
+	GCallback         callback;
+	gpointer          userdata;
+} GeoclueSatelliteAsyncData;
+
+static void
+get_satellite_async_callback (DBusGProxy                *proxy,
+			      int                        timestamp,
+			      int                        satellite_used,
+			      int                        satellite_visible,
+			      GArray                    *used_prn,
+			      GPtrArray                 *sat_info,
+			      GError                    *error,
+			      GeoclueSatelliteAsyncData *data)
+{
+	(*(GeoclueSatelliteCallback)data->callback) (data->satellite,
+						     timestamp,
+						     satellite_used,
+						     satellite_visible,
+						     used_prn,
+						     sat_info,
+						     error,
+						     data->userdata);
+
+	g_free (data);
+}
+
+void
+geoclue_satellite_get_satellite_async (GeoclueSatellite        *satellite,
+				       GeoclueSatelliteCallback callback,
+				       gpointer                 userdata)
+{
+	GeoclueProvider *provider = GEOCLUE_PROVIDER (satellite);
+	GeoclueSatelliteAsyncData *data;
+
+	data = g_new (GeoclueSatelliteAsyncData, 1);
+	data->satellite = satellite;
+	data->callback = G_CALLBACK (callback);
+	data->userdata = userdata;
+
+	org_freedesktop_Geoclue_Satellite_get_satellite_async (provider->proxy,
+			(org_freedesktop_Geoclue_Satellite_get_satellite_reply)get_satellite_async_callback,
+			data);
+}
Index: geoclue/geoclue/geoclue-satellite.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/geoclue/geoclue-satellite.h	2011-12-29 16:40:38.922428900 +0900
@@ -0,0 +1,84 @@
+/*
+ * Geoclue
+ * geoclue-satellite.h -
+ *
+ * Author: Sagnho Park <sangho.g.park@samsung.com>, Youngae Kang <youngae.kang@samsung.com>,
+ *         Yunhan Kim <yhan.kim@samsung.com>, Genie Kim <daejins.kim@samsung.com>
+ * Copyright (c) 2000 - 2011 Samsung Electronics Co., Ltd. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _GEOCLUE_SATELLITE_H
+#define _GEOCLUE_SATELLITE_H
+
+#include <geoclue/geoclue-provider.h>
+#include <geoclue/geoclue-types.h>
+#include <geoclue/geoclue-satellite-info.h>
+
+G_BEGIN_DECLS
+
+#define GEOCLUE_TYPE_SATELLITE (geoclue_satellite_get_type ())
+#define GEOCLUE_SATELLITE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOCLUE_TYPE_SATELLITE, GeoclueSatellite))
+#define GEOCLUE_IS_SATELLITE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOCLUE_TYPE_SATELLITE))
+
+#define GEOCLUE_SATELLITE_INTERFACE_NAME "org.freedesktop.Geoclue.Satellite"
+
+typedef struct _GeoclueSatellite {
+	GeoclueProvider provider;
+} GeoclueSatellite;
+
+typedef struct _GeoclueSatelliteClass {
+	GeoclueProviderClass provider_class;
+
+	void (* satellite_changed) (GeoclueSatellite *satellite,
+				    int               timestamp,
+				    int               satellite_used,
+				    int               satellite_visible,
+				    GArray           *used_prn,
+				    GPtrArray        *sat_info);
+} GeoclueSatelliteClass;
+
+GType geoclue_satellite_get_type (void);
+
+GeoclueSatellite *geoclue_satellite_new (const char *service,
+					 const char *path);
+
+gboolean geoclue_satellite_get_satellite (GeoclueSatellite *satellite,
+					  int              *timestamp,
+					  int              *satellite_used,
+					  int              *satellite_visible,
+					  GArray          **used_prn,
+					  GPtrArray       **sat_info,
+					  GError          **error);
+
+typedef void (*GeoclueSatelliteCallback) (GeoclueSatellite *satellite,
+					  int               timestamp,
+					  int               satellite_used,
+					  int               satellite_visible,
+					  GArray           *used_prn,
+					  GPtrArray        *sat_info,
+					  GError           *error,
+					  gpointer          userdata);
+
+void geoclue_satellite_get_satellite_async (GeoclueSatellite        *satellite,
+					    GeoclueSatelliteCallback callback,
+					    gpointer                 userdata);
+
+G_END_DECLS
+
+#endif
Index: geoclue/geoclue/geoclue-types.c
===================================================================
--- geoclue.orig/geoclue/geoclue-types.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/geoclue-types.c	2011-12-29 16:40:38.926428900 +0900
@@ -1,6 +1,6 @@
 /*
  * Geoclue
- * geoclue-types.c - 
+ * geoclue-types.c -
  *
  * Author: Iain Holmes <iain@openedhand.com>
  * Copyright 2007 by Garmin Ltd. or its subsidiaries
@@ -25,16 +25,12 @@
 #include <geoclue/geoclue-marshal.h>
 #include <geoclue/geoclue-types.h>
 #include <geoclue/geoclue-accuracy.h>
+#include <geoclue/geoclue-satellite.h>
 #include <geoclue/geoclue-error.h>
 
-static gboolean initted = FALSE;
-
 void
 geoclue_types_init (void)
 {
-	if (initted != FALSE)
-		return;
-
 	dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_INT_DOUBLE_DOUBLE_DOUBLE,
 					   G_TYPE_NONE,
 					   G_TYPE_INT,
@@ -43,7 +39,8 @@
 					   G_TYPE_DOUBLE,
 					   G_TYPE_DOUBLE,
 					   G_TYPE_INVALID);
-        dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_INT_DOUBLE_DOUBLE_DOUBLE_BOXED,
+
+	dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_INT_DOUBLE_DOUBLE_DOUBLE_BOXED,
                                            G_TYPE_NONE,
                                            G_TYPE_INT,
 					   G_TYPE_INT,
@@ -52,14 +49,14 @@
 					   G_TYPE_DOUBLE,
                                            G_TYPE_BOXED,
 					   G_TYPE_INVALID);
-	
+
 	dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_BOXED_BOXED,
 					   G_TYPE_NONE,
 					   G_TYPE_INT,
 					   G_TYPE_BOXED,
 					   G_TYPE_BOXED,
 					   G_TYPE_INVALID);
-	
+
 	dbus_g_object_register_marshaller (geoclue_marshal_VOID__STRING_STRING_STRING_STRING,
 	                                   G_TYPE_NONE,
 	                                   G_TYPE_STRING,
@@ -68,9 +65,24 @@
 	                                   G_TYPE_STRING,
 	                                   G_TYPE_INVALID);
 
+	dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_STRING,
+	                                   G_TYPE_NONE,
+	                                   G_TYPE_INT,
+	                                   G_TYPE_STRING,
+	                                   G_TYPE_INVALID);
+
+	dbus_g_object_register_marshaller (geoclue_marshal_VOID__INT_INT_INT_POINTER_POINTER,
+					   G_TYPE_NONE,
+					   G_TYPE_INT,
+					   G_TYPE_INT,
+					   G_TYPE_INT,
+					   DBUS_TYPE_G_INT_ARRAY,
+					   GEOCLUE_SATELLITE_INFO_ARRAY,
+					   G_TYPE_INVALID);
+
 	dbus_g_error_domain_register (GEOCLUE_ERROR,
 				      GEOCLUE_ERROR_DBUS_INTERFACE,
 				      GEOCLUE_TYPE_ERROR);
 
-	initted = TRUE;
+
 }
Index: geoclue/geoclue/geoclue-types.h
===================================================================
--- geoclue.orig/geoclue/geoclue-types.h	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/geoclue/geoclue-types.h	2011-12-29 16:40:38.926428900 +0900
@@ -29,13 +29,13 @@
 
 /**
  * SECTION:geoclue-types
- * @short_description: Type definitions and defines useful for Geoclue clients 
+ * @short_description: Type definitions and defines useful for Geoclue clients
  **/
 
 
 /**
  * GeoclueStatus
- * 
+ *
  * defines the provider status
  **/
 typedef enum {
@@ -48,12 +48,8 @@
 /**
  * GeoclueAccuracyLevel:
  *
- * Enum values used to define the approximate accuracy of 
- * Position or Address information. These are ordered in
- * from lowest accuracy possible to highest accuracy possible.
- * geoclue_accuracy_get_details() can be used to get get the
- * current accuracy. It is up to the provider to set the
- * accuracy based on analysis of its queries.
+ * Enum values used to define the approximate accuracy of
+ * Position or Address information.
  **/
 typedef enum {
 	GEOCLUE_ACCURACY_LEVEL_NONE = 0,
@@ -68,15 +64,15 @@
 /**
  * GeocluePositionFields:
  *
- * #GeocluePositionFields is a bitfield that defines the validity of 
+ * #GeocluePositionFields is a bitfield that defines the validity of
  * Position values.
- * 
+ *
  * Example:
  * <informalexample>
  * <programlisting>
  * GeocluePositionFields fields;
  * fields = geoclue_position_get_position (. . .);
- * 
+ *
  * if (fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
  *     fields & GEOCLUE_POSITION_FIELDS_LONGITUDE) {
  * 	g_print("latitude and longitude are valid");
@@ -94,7 +90,7 @@
 /**
  * GeoclueVelocityFields:
  *
- * GeoclueVelocityFields is a bitfield that defines the validity of 
+ * GeoclueVelocityFields is a bitfield that defines the validity of
  * Velocity values.
  **/
 typedef enum {
@@ -106,55 +102,55 @@
 
 /**
  * GEOCLUE_ADDRESS_KEY_COUNTRYCODE:
- * 
- * A key for address hashtables. The hash value should be a ISO 3166 two 
- * letter country code. 
- * 
- * The used hash keys match the elements of XEP-0080 (XMPP protocol 
- * extension for user location), see 
+ *
+ * A key for address hashtables. The hash value should be a ISO 3166 two
+ * letter country code.
+ *
+ * The used hash keys match the elements of XEP-0080 (XMPP protocol
+ * extension for user location), see
  * <ulink url="http://www.xmpp.org/extensions/xep-0080.html">
  * http://www.xmpp.org/extensions/xep-0080.html</ulink>
  */
 #define GEOCLUE_ADDRESS_KEY_COUNTRYCODE "countrycode"
 /**
  * GEOCLUE_ADDRESS_KEY_COUNTRY:
- * 
- * A key for address hashtables. The hash value should be a name of a country. 
+ *
+ * A key for address hashtables. The hash value should be a name of a country.
  */
 #define GEOCLUE_ADDRESS_KEY_COUNTRY "country"
 /**
  * GEOCLUE_ADDRESS_KEY_REGION:
- * 
- * A key for address hashtables. The hash value should be a name of an 
+ *
+ * A key for address hashtables. The hash value should be a name of an
  * administrative region of a nation, e.g. province or
- * US state. 
+ * US state.
  */
-#define GEOCLUE_ADDRESS_KEY_REGION "region" 
+#define GEOCLUE_ADDRESS_KEY_REGION "region"
 /**
  * GEOCLUE_ADDRESS_KEY_LOCALITY:
- * 
- * A key for address hashtables. The hash value should be a name of a town 
- * or city. 
+ *
+ * A key for address hashtables. The hash value should be a name of a town
+ * or city.
  */
 #define GEOCLUE_ADDRESS_KEY_LOCALITY "locality"
 /**
  * GEOCLUE_ADDRESS_KEY_AREA:
- * 
- * A key for address hashtables. The hash value should be a name of an 
- * area, such as neighborhood or campus. 
+ *
+ * A key for address hashtables. The hash value should be a name of an
+ * area, such as neighborhood or campus.
  */
 #define GEOCLUE_ADDRESS_KEY_AREA "area"
 /**
  * GEOCLUE_ADDRESS_KEY_POSTALCODE:
- * 
- * A key for address hashtables. The hash value should be a code used for 
+ *
+ * A key for address hashtables. The hash value should be a code used for
  * postal delivery.
  */
 #define GEOCLUE_ADDRESS_KEY_POSTALCODE "postalcode"
 /**
  * GEOCLUE_ADDRESS_KEY_STREET:
- * 
- * A key for address hashtables. The hash value should be a partial or full street 
+ *
+ * A key for address hashtables. The hash value should be a partial or full street
  * address.
  */
 #define GEOCLUE_ADDRESS_KEY_STREET "street"
@@ -162,15 +158,15 @@
 /**
  * GeoclueResourceFlags:
  *
- * bitfield that represents a set of physical resources. 
- * 
+ * bitfield that represents a set of physical resources.
+ *
  **/
 typedef enum _GeoclueResourceFlags {
 	GEOCLUE_RESOURCE_NONE = 0,
 	GEOCLUE_RESOURCE_NETWORK = 1 << 0,
 	GEOCLUE_RESOURCE_CELL = 1 << 1,
 	GEOCLUE_RESOURCE_GPS = 1 << 2,
-	
+
 	GEOCLUE_RESOURCE_ALL = (1 << 10) - 1
 } GeoclueResourceFlags;
 
@@ -178,8 +174,8 @@
 /**
  * GeoclueNetworkStatus:
  *
- * Enumeration for current network status. 
- * 
+ * Enumeration for current network status.
+ *
  **/
 typedef enum {
 	GEOCLUE_CONNECTIVITY_UNKNOWN,
Index: geoclue/interfaces/Makefile.am
===================================================================
--- geoclue.orig/interfaces/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/interfaces/Makefile.am	2011-12-29 16:40:38.930428900 +0900
@@ -1,15 +1,17 @@
 %.xml: %-full.xml
-	$(AM_V_GEN) $(XSLT) -o $@ $(top_srcdir)/docs/tools/spec-strip-docs.xsl $<
+	$(XSLT) -o $@ $(top_srcdir)/docs/tools/spec-strip-docs.xsl $<
 
 noinst_DATA = \
 	gc-iface-geoclue.xml \
 	gc-iface-position.xml \
+	gc-iface-nmea.xml \
 	gc-iface-address.xml \
 	gc-iface-geocode.xml \
 	gc-iface-master.xml \
 	gc-iface-master-client.xml \
 	gc-iface-reverse-geocode.xml \
-	gc-iface-velocity.xml
+	gc-iface-velocity.xml \
+	gc-iface-satellite.xml
 
 BUILT_SOURCES = $(noinst_DATA)
 CLEANFILES = $(BUILT_SOURCES)
@@ -17,9 +19,11 @@
 EXTRA_DIST = \
 	gc-iface-geoclue-full.xml \
 	gc-iface-position-full.xml \
+	gc-iface-nmea-full.xml \
 	gc-iface-address-full.xml \
 	gc-iface-geocode-full.xml \
 	gc-iface-master-full.xml \
 	gc-iface-master-client-full.xml \
 	gc-iface-reverse-geocode-full.xml \
-	gc-iface-velocity-full.xml
+	gc-iface-velocity-full.xml \
+	gc-iface-satellite-full.xml
Index: geoclue/interfaces/gc-iface-geoclue-full.xml
===================================================================
--- geoclue.orig/interfaces/gc-iface-geoclue-full.xml	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/interfaces/gc-iface-geoclue-full.xml	2011-12-29 16:40:38.930428900 +0900
@@ -1,14 +1,14 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
-	
+
 	<interface name="org.freedesktop.Geoclue">
 		<doc:doc>
-			<doc:para>Geoclue interface contains methods 
+			<doc:para>Geoclue interface contains methods
 			and signals common to all providers (and all providers
 			must implement at least this interface).</doc:para>
 		</doc:doc>
-		
+
 		<method name="GetProviderInfo">
 			<arg type="s" name="Name" direction="out">
 				<doc:doc>
@@ -21,7 +21,7 @@
 				</doc:doc>
 			</arg>
 		</method>
-		
+
 		<method name="GetStatus">
 			<arg type="i" name="status" direction="out" >
 				<doc:doc>
@@ -39,20 +39,20 @@
 		</signal>
 
 		<method name="SetOptions">
-			<arg type="a{sv}" name="options" direction="in" />
+			<arg type="a{ss}" name="options" direction="in" />
 		</method>
-		
+
 		<method name="AddReference">
 			<doc:doc>
-				<doc:description>Increase the reference count on the provider. 
-				Provider may shutdown if reference count reaches zero, so 
+				<doc:description>Increase the reference count on the provider.
+				Provider may shutdown if reference count reaches zero, so
 				using AddReference()/RemoveReference is important for clients needing server
 				persistence -- basically any client that uses SetOptions() or connects to
 				signals.</doc:description>
 			</doc:doc>
 			<annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
 		</method>
-		
+
 		<method name="RemoveReference">
 			<doc:doc>
 				<doc:description>Decrease the reference count on the provider</doc:description>
Index: geoclue/interfaces/gc-iface-nmea-full.xml
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/interfaces/gc-iface-nmea-full.xml	2011-12-29 16:40:38.930428900 +0900
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
+
+	<interface name="org.freedesktop.Geoclue.Nmea">
+		<doc:doc>
+			<doc:para>Nmea interface contains a method
+			and a signal for querying current coordinates.</doc:para>
+		</doc:doc>
+
+		<method name="GetNmea">
+			<arg type="i" name="timestamp" direction="out" />
+			<arg type="s" name="nmea_data" direction="out" />
+		</method>
+
+		<signal name="NmeaChanged">
+			<arg type="i" name="timestamp" />
+			<arg type="s" name="nmea_data" />
+		</signal>
+	</interface>
+</node>
Index: geoclue/interfaces/gc-iface-satellite-full.xml
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/interfaces/gc-iface-satellite-full.xml	2011-12-29 16:40:38.930428900 +0900
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/">
+	<interface name="org.freedesktop.Geoclue.Satellite">
+		<method name="GetSatellite">
+			<arg type="i" name="timestamp" direction="out" />
+			<arg type="i" name="satellite_used" direction="out" />
+			<arg type="i" name="satellite_visible" direction="out" />
+			<arg type="ai" name="used_prn" direction="out" />
+			<arg type="a(iiii)" name="sat_info" direction="out" />
+		</method>
+
+		<signal name="SatelliteChanged">
+			<arg type="i" name="timestamp" />
+			<arg type="i" name="satellite_used" />
+			<arg type="i" name="satellite_visible" />
+			<arg type="ai" name="used_prn" />
+			<arg type="a(iiii)" name="sat_info" />
+		</signal>
+	</interface>
+</node>
Index: geoclue/providers/example/Makefile.am
===================================================================
--- geoclue.orig/providers/example/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/example/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -20,7 +20,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/example/geoclue-example.c
===================================================================
--- geoclue.orig/providers/example/geoclue-example.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/example/geoclue-example.c	2011-12-29 16:40:38.926428900 +0900
@@ -62,10 +62,7 @@
               gpointer value,
               gpointer data)
 {
-	if (G_VALUE_TYPE (value) == G_TYPE_STRING)
-		g_print ("   %s - %s\n", key, g_value_get_string (value));
-	else
-		g_print ("   %s - %d\n", key, g_value_get_int (value));
+        g_print ("   %s - %s\n", key, value);
 }
 
 static gboolean
@@ -82,7 +79,7 @@
 shutdown (GcProvider *provider)
 {
 	GeoclueExample *example = GEOCLUE_EXAMPLE (provider);
-	
+
 	g_main_loop_quit (example->loop);
 }
 
@@ -138,9 +135,9 @@
 
 	accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE,
 					 0.0, 0.0);
-	
-	gc_iface_position_emit_position_changed 
-		(GC_IFACE_POSITION (example), 
+
+	gc_iface_position_emit_position_changed
+		(GC_IFACE_POSITION (example),
 		 GEOCLUE_POSITION_FIELDS_NONE,
 		 time (NULL), 0.0, 0.0, 0.0, accuracy);
 
Index: geoclue/providers/geonames/Makefile.am
===================================================================
--- geoclue.orig/providers/geonames/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/geonames/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -15,7 +15,7 @@
 
 geoclue_geonames_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-geonames.provider
@@ -25,7 +25,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/gpsd/Makefile.am
===================================================================
--- geoclue.orig/providers/gpsd/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gpsd/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -6,9 +6,13 @@
 	$(GEOCLUE_CFLAGS)	\
     $(GPSD_CFLAGS)
 
+geoclue_gpsd_LDFLAGS = \
+	-Wl,--warn-unresolved-symbols
+
 geoclue_gpsd_LDADD =		\
 	$(GEOCLUE_LIBS)		\
 	$(GPSD_LIBS)		\
+	-lm			\
 	$(top_builddir)/geoclue/libgeoclue.la
 
 geoclue_gpsd_SOURCES =		\
@@ -22,7 +26,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/gpsd/geoclue-gpsd.c
===================================================================
--- geoclue.orig/providers/gpsd/geoclue-gpsd.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gpsd/geoclue-gpsd.c	2011-12-29 16:40:38.926428900 +0900
@@ -23,10 +23,10 @@
  */
 
 /* TODO:
- * 
- * 	call to gps_set_callback blocks for a long time if 
+ *
+ * 	call to gps_set_callback blocks for a long time if
  * 	BT device is not present.
- * 
+ *
  **/
 
 #include <config.h>
@@ -55,19 +55,19 @@
 
 typedef struct {
 	GcProvider parent;
-	
+
 	char *host;
 	char *port;
-	
+
 	gps_data *gpsdata;
-	
+
 	gps_fix *last_fix;
-	
+
 	GeoclueStatus last_status;
 	GeocluePositionFields last_pos_fields;
 	GeoclueAccuracy *last_accuracy;
 	GeoclueVelocityFields last_velo_fields;
-	
+
 	GMainLoop *loop;
 
 } GeoclueGpsd;
@@ -105,7 +105,7 @@
             GError        **error)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (gc);
-	
+
 	*status = gpsd->last_status;
 	return TRUE;
 }
@@ -114,7 +114,7 @@
 shutdown (GcProvider *provider)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (provider);
-	
+
 	g_main_loop_quit (gpsd->loop);
 }
 
@@ -123,12 +123,13 @@
 {
 	if (status != self->last_status) {
 		self->last_status = status;
-		
+
 		/* make position and velocity invalid if no fix */
 		if (status != GEOCLUE_STATUS_AVAILABLE) {
 			self->last_pos_fields = GEOCLUE_POSITION_FIELDS_NONE;
 			self->last_velo_fields = GEOCLUE_VELOCITY_FIELDS_NONE;
 		}
+		g_debug("status changed [%d]", status);
 		gc_iface_geoclue_emit_status_changed (GC_IFACE_GEOCLUE (self),
 		                                      status);
 	}
@@ -140,31 +141,28 @@
              GError        **error)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (gc);
-	GValue *port_value, *host_value;
-	const char *port, *host;
+	char *port, *host;
 	gboolean changed = FALSE;
 
-	host_value = g_hash_table_lookup (options,
-					  "org.freedesktop.Geoclue.GPSHost");
-	host = host_value ? g_value_get_string (host_value) : NULL;
-	port_value = g_hash_table_lookup (options,
-					  "org.freedesktop.Geoclue.GPSPort");
-	port = port_value ? g_value_get_string (port_value) : NULL;
+	host = g_hash_table_lookup (options,
+	                                  "org.freedesktop.Geoclue.GPSHost");
+	port = g_hash_table_lookup (options,
+	                                  "org.freedesktop.Geoclue.GPSPort");
 
 	if (port == NULL) {
 		port = DEFAULT_GPSD_PORT;
 	}
-	
+
 	/* new values? */
 	if (g_strcmp0 (host, gpsd->host) != 0 ||
 	    g_strcmp0 (port, gpsd->port) != 0) {
 		changed = TRUE;
 	}
-	
+
 	if (!changed) {
 		return TRUE;
 	}
-	
+
 	/* update private values with new ones, restart gpsd */
 	g_free (gpsd->port);
 	gpsd->port = NULL;
@@ -192,16 +190,16 @@
 finalize (GObject *object)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (object);
-	
+
 	geoclue_gpsd_stop_gpsd (gpsd);
 	g_free (gpsd->last_fix);
 	geoclue_accuracy_free (gpsd->last_accuracy);
-	
+
 	g_free (gpsd->port);
 	if (gpsd->host) {
 		g_free (gpsd->host);
 	}
-	
+
 	((GObjectClass *) geoclue_gpsd_parent_class)->finalize (object);
 }
 
@@ -210,9 +208,9 @@
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
 	GcProviderClass *p_class = (GcProviderClass *) klass;
-	
+
 	o_class->finalize = finalize;
-	
+
 	p_class->get_status = get_status;
 	p_class->set_options = set_options;
 	p_class->shutdown = shutdown;
@@ -229,160 +227,139 @@
 }
 
 static void
-geoclue_gpsd_update_position (GeoclueGpsd *gpsd, NmeaTag nmea_tag)
+geoclue_gpsd_update_position (GeoclueGpsd *gpsd)
 {
+	if(gpsd->last_status != GEOCLUE_STATUS_AVAILABLE)
+		return;
+
 	gps_fix *fix = &gpsd->gpsdata->fix;
 	gps_fix *last_fix = gpsd->last_fix;
-	
-	last_fix->time = fix->time;
-	
-	/* If a flag is not set, bail out.*/
-	if (!((gpsd->gpsdata->set & LATLON_SET) || (gpsd->gpsdata->set & ALTITUDE_SET))) {
-		return;
-	}
-	gpsd->gpsdata->set &= ~(LATLON_SET | ALTITUDE_SET);
-	
+
+
+	if (isnan(fix->time)==0){
+		last_fix->time = fix->time;
+    }
 	if (equal_or_nan (fix->latitude, last_fix->latitude) &&
 	    equal_or_nan (fix->longitude, last_fix->longitude) &&
 	    equal_or_nan (fix->altitude, last_fix->altitude)) {
-		/* position has not changed */
 		return;
 	}
-	
 	/* save values */
-	last_fix->latitude = fix->latitude;
-	last_fix->longitude = fix->longitude;
-	last_fix->altitude = fix->altitude;
-	
-	/* Could use fix.eph for accuracy, but eph is 
-	 * often NaN... what then? 
-	 * Could also use fix mode (2d/3d) to decide vertical accuracy, 
-	 * but gpsd updates that so erratically that I couldn't
-	 * be arsed so far */
+	if (fix->mode >= MODE_2D && isnan(fix->latitude)==0) {
+		last_fix->latitude = fix->latitude;
+	}
+	if (fix->mode >= MODE_2D && isnan(fix->longitude)==0) {
+		last_fix->longitude = fix->longitude;
+	}
+	if (fix->mode == MODE_3D && isnan(fix->altitude)==0){
+		last_fix->altitude = fix->altitude;
+	}
+
+	if (isnan(fix->epx)==0){
+		last_fix->epx = fix->epx;
+	}
+	if (isnan(fix->epy)==0){
+		last_fix->epy = fix->epy;
+	}
+	if (isnan(fix->epv)==0){
+		last_fix->epv = fix->epv;
+	}
 	geoclue_accuracy_set_details (gpsd->last_accuracy,
 	                              GEOCLUE_ACCURACY_LEVEL_DETAILED,
-	                              24, 60);
-	
+	                              sqrt(pow(last_fix->epx, 2)+pow(last_fix->epy, 2)), fix->epv);
 	gpsd->last_pos_fields = GEOCLUE_POSITION_FIELDS_NONE;
-	gpsd->last_pos_fields |= (isnan (fix->latitude)) ? 
+	gpsd->last_pos_fields |= (isnan (fix->latitude)) ?
 	                         0 : GEOCLUE_POSITION_FIELDS_LATITUDE;
-	gpsd->last_pos_fields |= (isnan (fix->longitude)) ? 
+	gpsd->last_pos_fields |= (isnan (fix->longitude)) ?
 	                         0 : GEOCLUE_POSITION_FIELDS_LONGITUDE;
-	gpsd->last_pos_fields |= (isnan (fix->altitude)) ? 
+	gpsd->last_pos_fields |= (isnan (fix->altitude)) ?
 	                         0 : GEOCLUE_POSITION_FIELDS_ALTITUDE;
-	
-	gc_iface_position_emit_position_changed 
+
+	g_debug("Update position: %lf, %lf, %lf, fields:0x%x, Accuracy level: %d, vert:%lf hori:%lf",
+		last_fix->latitude, last_fix->longitude, last_fix->altitude, gpsd->last_pos_fields,
+		GEOCLUE_ACCURACY_LEVEL_DETAILED, sqrt(pow(last_fix->epx, 2)+pow(last_fix->epy, 2)), fix->epv);
+	gc_iface_position_emit_position_changed
 		(GC_IFACE_POSITION (gpsd), gpsd->last_pos_fields,
-		 (int)(last_fix->time+0.5), 
-		 last_fix->latitude, last_fix->longitude, last_fix->altitude, 
+		 (int)(last_fix->time+0.5),
+		 last_fix->latitude, last_fix->longitude, last_fix->altitude,
 		 gpsd->last_accuracy);
-	
+
 }
 
 static void
-geoclue_gpsd_update_velocity (GeoclueGpsd *gpsd, NmeaTag nmea_tag)
+geoclue_gpsd_update_velocity (GeoclueGpsd *gpsd)
 {
+	if(gpsd->last_status != GEOCLUE_STATUS_AVAILABLE)
+		return;
+
 	gps_fix *fix = &gpsd->gpsdata->fix;
 	gps_fix *last_fix = gpsd->last_fix;
-	gboolean changed = FALSE;
-	
-	/* at least with my devices, gpsd updates
-	 *  - climb on GGA, GSA and GSV messages (speed and track are set to NaN).
-	 *  - speed and track on RMC message (climb is set to NaN).
-	 * 
-	 * couldn't think of an smart way to handle this, I don't think there is one
-	 */
-	
-	if (((gpsd->gpsdata->set & TRACK_SET) || (gpsd->gpsdata->set & SPEED_SET)) &&
-	    nmea_tag == NMEA_RMC) {
-		
-		gpsd->gpsdata->set &= ~(TRACK_SET | SPEED_SET);
-		
-		last_fix->time = fix->time;
-		
-		if (!equal_or_nan (fix->track, last_fix->track) ||
-		    !equal_or_nan (fix->speed, last_fix->speed)){
-			
-			/* velocity has changed */
-			changed = TRUE;
-			last_fix->track = fix->track;
-			last_fix->speed = fix->speed;
-		}
-	} else if ((gpsd->gpsdata->set & CLIMB_SET) &&
-	           (nmea_tag == NMEA_GGA || 
-	            nmea_tag == NMEA_GSA || 
-	            nmea_tag == NMEA_GSV)) {
-		
-		gpsd->gpsdata->set &= ~(CLIMB_SET);
-		
+
+	if (isnan(fix->time)==0){
 		last_fix->time = fix->time;
-		
-		if (!equal_or_nan (fix->climb, last_fix->climb)){
-			
-			/* velocity has changed */
-			changed = TRUE;
-			last_fix->climb = fix->climb;
-		}
+    }
+	if (equal_or_nan (fix->track, last_fix->track) &&
+	    equal_or_nan (fix->speed, last_fix->speed) &&
+	    equal_or_nan (fix->climb, last_fix->climb)) {
+		return;
+	}
+	if (fix->mode >= MODE_2D && isnan(fix->track)==0){
+		last_fix->track = fix->track;
 	}
-	
-	if (changed) {
-		gpsd->last_velo_fields = GEOCLUE_VELOCITY_FIELDS_NONE;
-		gpsd->last_velo_fields |= (isnan (last_fix->track)) ?
-			0 : GEOCLUE_VELOCITY_FIELDS_DIRECTION;
-		gpsd->last_velo_fields |= (isnan (last_fix->speed)) ?
-			0 : GEOCLUE_VELOCITY_FIELDS_SPEED;
-		gpsd->last_velo_fields |= (isnan (last_fix->climb)) ?
-			0 : GEOCLUE_VELOCITY_FIELDS_CLIMB;
-		
-		gc_iface_velocity_emit_velocity_changed 
-			(GC_IFACE_VELOCITY (gpsd), gpsd->last_velo_fields,
-			 (int)(last_fix->time+0.5),
-			 last_fix->speed, last_fix->track, last_fix->climb);
+	if (fix->mode >= MODE_2D && isnan(fix->speed)==0){
+		last_fix->speed = fix->speed;
 	}
+	if (fix->mode >= MODE_3D && isnan(fix->climb)==0){
+		last_fix->climb = fix->climb;
+	}
+
+	g_debug("Update velocity: %lf, %lf, %lf", last_fix->track, last_fix->speed, last_fix->climb);
+	gpsd->last_velo_fields = GEOCLUE_VELOCITY_FIELDS_NONE;
+	gpsd->last_velo_fields |= (isnan (last_fix->track)) ?
+		0 : GEOCLUE_VELOCITY_FIELDS_DIRECTION;
+	gpsd->last_velo_fields |= (isnan (last_fix->speed)) ?
+		0 : GEOCLUE_VELOCITY_FIELDS_SPEED;
+	gpsd->last_velo_fields |= (isnan (last_fix->climb)) ?
+		0 : GEOCLUE_VELOCITY_FIELDS_CLIMB;
+
+	gc_iface_velocity_emit_velocity_changed
+		(GC_IFACE_VELOCITY (gpsd), gpsd->last_velo_fields,
+		 (int)(last_fix->time+0.5),
+		 last_fix->speed, last_fix->track, last_fix->climb);
 }
 
 static void
-geoclue_gpsd_update_status (GeoclueGpsd *gpsd, NmeaTag nmea_tag)
+geoclue_gpsd_update_status (GeoclueGpsd *gpsd)
 {
 	GeoclueStatus status;
-	
+
 	/* gpsdata->online is supposedly always up-to-date */
 	if (gpsd->gpsdata->online <= 0) {
 		status = GEOCLUE_STATUS_UNAVAILABLE;
 	} else if (gpsd->gpsdata->set & STATUS_SET) {
 		gpsd->gpsdata->set &= ~(STATUS_SET);
-		
 		if (gpsd->gpsdata->status > 0) {
 			status = GEOCLUE_STATUS_AVAILABLE;
 		} else {
 			status = GEOCLUE_STATUS_ACQUIRING;
 		}
 	} else {
+		status = GEOCLUE_STATUS_AVAILABLE;
 		return;
 	}
-	
+
 	geoclue_gpsd_set_status (gpsd, status);
 }
 
-static void 
-gpsd_raw_hook (struct gps_data_t *gpsdata, char *message, size_t len)
+static void
+gpsd_raw_hook (gps_data *gpsdata, char *message, size_t len)
 {
-	char *tag_str = gpsd->gpsdata->tag;
-	NmeaTag nmea_tag = NMEA_NONE;
-	
-	if (tag_str[0] == 'G' && tag_str[1] == 'S' && tag_str[2] == 'A') {
-		nmea_tag = NMEA_GSA;
-	} else if (tag_str[0] == 'G' && tag_str[1] == 'G' && tag_str[2] == 'A') {
-		nmea_tag = NMEA_GGA;
-	} else if (tag_str[0] == 'G' && tag_str[1] == 'S' && tag_str[2] == 'V') {
-		nmea_tag = NMEA_GSV;
-	} else if (tag_str[0] == 'R' && tag_str[1] == 'M' && tag_str[2] == 'C') {
-		nmea_tag = NMEA_RMC;
-	}
-	
-	geoclue_gpsd_update_status (gpsd, nmea_tag);
-	geoclue_gpsd_update_position (gpsd, nmea_tag);
-	geoclue_gpsd_update_velocity (gpsd, nmea_tag);
+	if(gpsdata == NULL)
+		return;
+
+	geoclue_gpsd_update_status (gpsd);
+	geoclue_gpsd_update_position (gpsd);
+	geoclue_gpsd_update_velocity (gpsd);
 }
 
 static void
@@ -399,7 +376,7 @@
 {
 	self->gpsdata = gps_open (self->host, self->port);
 	if (self->gpsdata) {
-		gps_stream(self->gpsdata, WATCH_ENABLE | WATCH_NMEA | POLL_NONBLOCK, NULL);
+		gps_stream(self->gpsdata, WATCH_ENABLE | WATCH_NEWSTYLE, NULL);
 		gps_set_raw_hook (self->gpsdata, gpsd_raw_hook);
 		return TRUE;
 	} else {
@@ -427,18 +404,19 @@
 {
 	self->gpsdata = NULL;
 	self->last_fix = g_new0 (gps_fix, 1);
-	
+
 	self->last_pos_fields = GEOCLUE_POSITION_FIELDS_NONE;
 	self->last_velo_fields = GEOCLUE_VELOCITY_FIELDS_NONE;
 	self->last_accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0, 0);
-	
+
 	gc_provider_set_details (GC_PROVIDER (self),
 				 "org.freedesktop.Geoclue.Providers.Gpsd",
 				 "/org/freedesktop/Geoclue/Providers/Gpsd",
 				 "Gpsd", "Gpsd provider");
-	
+
 	self->port = g_strdup (DEFAULT_GPSD_PORT);
-	self->host = NULL;
+	self->host = g_strdup ("localhost");
+
 	geoclue_gpsd_set_status (self, GEOCLUE_STATUS_ACQUIRING);
 	if (!geoclue_gpsd_start_gpsd (self)) {
 		geoclue_gpsd_set_status (self, GEOCLUE_STATUS_ERROR);
@@ -456,14 +434,14 @@
               GError               **error)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (gc);
-	
+
 	*timestamp = (int)(gpsd->last_fix->time+0.5);
 	*latitude = gpsd->last_fix->latitude;
 	*longitude = gpsd->last_fix->longitude;
 	*altitude = gpsd->last_fix->altitude;
 	*fields = gpsd->last_pos_fields;
 	*accuracy = geoclue_accuracy_copy (gpsd->last_accuracy);
-	
+
 	return TRUE;
 }
 
@@ -483,13 +461,13 @@
               GError               **error)
 {
 	GeoclueGpsd *gpsd = GEOCLUE_GPSD (gc);
-	
+
 	*timestamp = (int)(gpsd->last_fix->time+0.5);
 	*speed = gpsd->last_fix->speed;
 	*direction = gpsd->last_fix->track;
 	*climb = gpsd->last_fix->climb;
 	*fields = gpsd->last_velo_fields;
-	
+
 	return TRUE;
 }
 
@@ -504,16 +482,16 @@
       char **argv)
 {
 	g_type_init ();
-	
+
 	gpsd = g_object_new (GEOCLUE_TYPE_GPSD, NULL);
-	
+
 	gpsd->loop = g_main_loop_new (NULL, TRUE);
 	g_timeout_add(500, gpsd_poll, (gpointer)gpsd);
 
 	g_main_loop_run (gpsd->loop);
-	
+
 	g_main_loop_unref (gpsd->loop);
 	g_object_unref (gpsd);
-	
+
 	return 0;
 }
Index: geoclue/providers/gsmloc/Makefile.am
===================================================================
--- geoclue.orig/providers/gsmloc/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gsmloc/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -7,9 +7,7 @@
 	ofono-manager-bindings.h \
 	ofono-modem-bindings.h \
 	ofono-network-registration-bindings.h \
-	ofono-network-operator-bindings.h \
-	mm-marshal.c \
-	mm-marshal.h
+	ofono-network-operator-bindings.h
 
 BUILT_SOURCES = \
 	$(nodist_geoclue_gsmloc_SOURCES)
@@ -18,9 +16,7 @@
 	mcc.h \
 	geoclue-gsmloc.c \
 	geoclue-gsmloc-ofono.c \
-	geoclue-gsmloc-ofono.h \
-	geoclue-gsmloc-mm.c \
-	geoclue-gsmloc-mm.h
+	geoclue-gsmloc-ofono.h
 
 
 geoclue_gsmloc_CFLAGS = \
@@ -30,7 +26,7 @@
 
 geoclue_gsmloc_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-gsmloc.provider
@@ -40,7 +36,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	ofono-marshal.list	\
@@ -48,7 +44,6 @@
 	ofono-modem.xml \
 	ofono-network-operator.xml \
 	ofono-network-registration.xml \
-	mm-marshal.list \
 	$(service_in_files)	\
 	$(providers_DATA)
 
@@ -61,7 +56,7 @@
 %-bindings.h: stamp-%-bindings.h
 	@true
 stamp-%-bindings.h: %.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --mode=glib-client $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --mode=glib-client $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
@@ -69,9 +64,5 @@
 ofono-marshal.h: ofono-marshal.list $(GLIB_GENMARSHAL)
 	$(GLIB_GENMARSHAL) $< --header --prefix=ofono_marshal > $@
 ofono-marshal.c: ofono-marshal.list ofono-marshal.h $(GLIB_GENMARSHAL)
-	$(AM_V_GEN) $(GLIB_GENMARSHAL) --prefix=ofono_marshal $(srcdir)/ofono-marshal.list --header --body >> $@
-
-mm-marshal.h: mm-marshal.list $(GLIB_GENMARSHAL)
-	$(AM_V_GEN) $(GLIB_GENMARSHAL) $< --header --prefix=mm_marshal > $@
-mm-marshal.c: mm-marshal.list mm-marshal.h $(GLIB_GENMARSHAL)
-	$(AM_V_GEN) $(GLIB_GENMARSHAL) --prefix=mm_marshal $(srcdir)/mm-marshal.list --header --body >> $@
+	echo "#include \"ofono-marshal.h\"" > $@ \
+	&& $(GLIB_GENMARSHAL) --prefix=ofono_marshal $(srcdir)/ofono-marshal.list --body >> $@
Index: geoclue/providers/gsmloc/geoclue-gsmloc-mm.c
===================================================================
--- geoclue.orig/providers/gsmloc/geoclue-gsmloc-mm.c	2011-12-29 16:41:40.362430014 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,779 +0,0 @@
-/*
- * Geoclue
- * geoclue-gsmloc-mm.c - An Address/Position provider for ModemManager
- *
- * Author: Dan Williams <dcbw@redhat.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- */
-
-#include <config.h>
-
-#include <unistd.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-#include <glib-object.h>
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib-bindings.h>
-
-#include "geoclue-gsmloc-mm.h"
-
-#include "mm-marshal.h"
-
-#define MM_DBUS_SERVICE       "org.freedesktop.ModemManager"
-#define MM_DBUS_PATH          "/org/freedesktop/ModemManager"
-#define MM_DBUS_INTERFACE     "org.freedesktop.ModemManager"
-#define MM_DBUS_LOC_INTERFACE "org.freedesktop.ModemManager.Modem.Location"
-#define DBUS_PROPS_INTERFACE  "org.freedesktop.DBus.Properties"
-#define MM_DBUS_MODEM_INTERFACE "org.freedesktop.ModemManager.Modem"
-
-G_DEFINE_TYPE (GeoclueGsmlocMm, geoclue_gsmloc_mm, G_TYPE_OBJECT)
-
-#define GEOCLUE_GSMLOC_MM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEOCLUE_TYPE_GSMLOC_MM, GeoclueGsmlocMmPrivate))
-
-typedef struct {
-	char *path;
-
-	DBusGProxy *loc_proxy;
-	DBusGProxy *props_proxy;
-	DBusGProxy *modem_proxy;
-
-	gboolean got_enabled;
-	gboolean enabled;
-	gboolean enabling;
-
-	gboolean got_loc_enabled;
-	gboolean loc_enabled;
-	gboolean loc_enabling;
-	gboolean got_initial_loc;
-
-	/* Whether the modem signals its location or whether we
-	 * have to poll for it.
-	 */
-	gboolean signals;
-	guint loc_idle;
-
-	gboolean has_location;
-
-	gpointer owner;
-} Modem;
-
-typedef struct {
-	DBusGConnection *bus;
-	DBusGProxy *dbus_proxy;
-
-	/* Listens for device add/remove events */
-	DBusGProxy *mm_proxy;
-	DBusGProxy *props_proxy;
-
-	/* List of Modem objects */
-	GSList *modems;
-} GeoclueGsmlocMmPrivate;
-
-enum {
-	PROP_0,
-	PROP_AVAILABLE,
-};
-
-enum {
-	NETWORK_DATA_CHANGED,
-	LAST_SIGNAL
-};
-static guint signals[LAST_SIGNAL] = {0};
-
-#define LOC_CAP_GSM_LACCI 0x02
-
-gboolean mm_debug = FALSE;
-
-#define debugmsg(fmt, args...) \
-	{ if (mm_debug) { g_debug (fmt, ##args); } }
-
-
-static gboolean
-is_available (GeoclueGsmlocMm *self)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-	GSList *iter;
-
-	for (iter = priv->modems; iter; iter = g_slist_next (iter)) {
-		Modem *modem = iter->data;
-
-		if (modem->enabled && modem->loc_enabled && modem->has_location)
-			return TRUE;
-	}
-
-	return FALSE;
-}
-
-static Modem *
-find_modem (GeoclueGsmlocMm *self, const char *path)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-	GSList *iter;
-
-	g_return_val_if_fail (path != NULL, NULL);
-
-	for (iter = priv->modems; iter; iter = g_slist_next (iter)) {
-		Modem *modem = iter->data;
-
-		if (strcmp (path, modem->path) == 0)
-			return modem;
-	}
-
-	return NULL;
-}
-
-static void
-recheck_available (GeoclueGsmlocMm *self)
-{
-	g_object_notify (G_OBJECT (self), "available");
-}
-
-static void
-location_update (GeoclueGsmlocMm *self, const char *loc)
-{
-	char **components = NULL;
-	char *dec_lac = NULL, *dec_cid = NULL;
-	unsigned long int num;
-
-	components = g_strsplit (loc, ",", 0);
-	if (!components || g_strv_length (components) < 4) {
-		g_warning ("%s: invalid GSM LAC/CI location: '%s'", __func__, loc);
-		goto out;
-	}
-
-	/* convert lac to decimal */
-	errno = 0;
-	num = strtoul (components[2], NULL, 16);
-	if (errno != 0) {
-		g_warning ("%s: cannot convert LAC '%s' to decimal!",
-		           __func__, components[2]);
-		goto out;
-	}
-	dec_lac = g_strdup_printf ("%u", num);
-
-	/* convert cell id to decimal */
-	errno = 0;
-	num = strtoul (components[3], NULL, 16);
-	if (errno != 0) {
-		g_warning ("%s: cannot convert Cell ID '%s' to decimal!",
-		           __func__, components[3]);
-		goto out;
-	}
-	dec_cid = g_strdup_printf ("%u", num);
-
-	debugmsg ("%s: emitting location: %s/%s/%s/%s",
-	           __func__, components[0], components[1], dec_lac, dec_cid);
-	g_signal_emit (G_OBJECT (self), signals[NETWORK_DATA_CHANGED], 0,
-	               components[0],  /* MCC */
-	               components[1],  /* MNC */
-	               dec_lac,        /* LAC */
-	               dec_cid);       /* CID */
-
-out:
-	if (components)
-		g_strfreev (components);
-	g_free (dec_lac);
-	g_free (dec_cid);
-}
-
-static void
-modem_location_update (Modem *modem, GHashTable *locations)
-{
-	GValue *lacci;
-
-	/* GSMLOC only handles GSM LAC/CI location info */
-	lacci = g_hash_table_lookup (locations, GUINT_TO_POINTER (LOC_CAP_GSM_LACCI));
-	if (!lacci)
-		return;
-	if (!G_VALUE_HOLDS_STRING (lacci)) {
-		g_warning ("%s: GSM LAC/CI location member not a string!", __func__);
-		return;
-	}
-
-	debugmsg ("%s: GSM LAC/CI: %s", __func__, g_value_get_string (lacci));
-	location_update (modem->owner, g_value_get_string (lacci));
-}
-
-#define DBUS_TYPE_LOCATIONS (dbus_g_type_get_map ("GHashTable", G_TYPE_UINT, G_TYPE_VALUE))
-#define DBUS_TYPE_G_MAP_OF_VARIANT (dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE))
-
-static void
-loc_poll_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	GError *error = NULL;
-	GHashTable *locations = NULL;
-
-	if (!dbus_g_proxy_end_call (proxy, call, &error,
-	                            DBUS_TYPE_LOCATIONS, &locations,
-	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed to get location: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-
-	modem_location_update ((Modem *) user_data, locations);
-	g_hash_table_destroy (locations);
-}
-
-static gboolean
-modem_loc_poll (gpointer user_data)
-{
-	Modem *modem = user_data;
-
-	dbus_g_proxy_begin_call (modem->loc_proxy, "GetLocation",
-	                         loc_poll_cb, modem, NULL,
-	                         G_TYPE_INVALID);
-
-	return TRUE;
-}
-
-static void
-modem_loc_enable_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	Modem *modem = user_data;
-	GError *error = NULL;
-
-	modem->loc_enabling = FALSE;
-	if (!dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID)) {
-		g_warning ("%s: failed to enable modem location services: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-}
-
-static void
-modem_try_loc_enable (Modem *modem)
-{
-	/* Don't enable location services if we don't have all the modem's
-	 * status yet or if location services are already enabled.
-	 */
-
-	if (!modem->got_loc_enabled ||
-	    !modem->enabled ||
-	    !modem->has_location ||
-	    !modem->got_loc_enabled ||
-	    modem->loc_enabled ||
-	    modem->loc_enabling)
-		return;
-
-	modem->loc_enabling = TRUE;
-	debugmsg ("%s: (%s) enabling location services...", __func__, modem->path);
-	dbus_g_proxy_begin_call (modem->loc_proxy, "Enable",
-		                 modem_loc_enable_cb, modem, NULL,
-		                 G_TYPE_BOOLEAN, TRUE,  /* enable */
-		                 G_TYPE_BOOLEAN, TRUE,  /* signal location changes */
-		                 G_TYPE_INVALID);
-}
-
-static void
-modem_enable_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	Modem *modem = user_data;
-	GError *error = NULL;
-
-	modem->enabling = FALSE;
-	if (!dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID)) {
-		g_warning ("%s: failed to enable modem: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-
-	/* enable location services */
-	modem_try_loc_enable (modem);
-}
-
-static void
-modem_properties_changed (DBusGProxy *proxy,
-                          const char *interface,
-                          GHashTable *props,
-                          gpointer user_data)
-{
-	Modem *modem = user_data;
-	GValue *value;
-	gboolean old_avail = modem->enabled && modem->loc_enabled && modem->has_location;
-	gboolean new_avail;
-
-	if (strcmp (interface, MM_DBUS_MODEM_INTERFACE) == 0) {
-		value = g_hash_table_lookup (props, "Enabled");
-		if (value && G_VALUE_HOLDS_BOOLEAN (value)) {
-			modem->enabled = g_value_get_boolean (value);
-			modem->got_enabled = TRUE;
-			debugmsg ("%s: (%s) modem %s", __func__, modem->path,
-			           modem->enabled ? "enabled" : "disabled");
-		}
-	} else if (strcmp (interface, MM_DBUS_LOC_INTERFACE) == 0) {
-		value = g_hash_table_lookup (props, "Enabled");
-		if (value && G_VALUE_HOLDS_BOOLEAN (value)) {
-			modem->loc_enabled = g_value_get_boolean (value);
-			modem->got_loc_enabled = TRUE;
-			debugmsg ("%s: (%s) modem location services %s",
-			           __func__, modem->path,
-			           modem->loc_enabled ? "enabled" : "disabled");
-		}
-
-		value = g_hash_table_lookup (props, "SignalsLocation");
-		if (value && G_VALUE_HOLDS_BOOLEAN (value)) {
-			modem->signals = g_value_get_boolean (value);
-			debugmsg ("%s: (%s) modem %s signal location updates",
-			           __func__, modem->path,
-			           modem->signals ? "will" : "does not");
-		}
-
-		value = g_hash_table_lookup (props, "Capabilities");
-		if (value && G_VALUE_HOLDS_UINT (value)) {
-			debugmsg ("%s: (%s) modem location capabilities: 0x%X",
-			           __func__, modem->path,
-			           g_value_get_uint (value));
-
-			if (g_value_get_uint (value) & LOC_CAP_GSM_LACCI)
-				modem->has_location = TRUE;
-		}
-
-		value = g_hash_table_lookup (props, "Location");
-		if (value && G_VALUE_HOLDS_BOXED (value))
-			modem_location_update (modem, (GHashTable *) g_value_get_boxed (value));
-	}
-
-	new_avail = modem->enabled && modem->loc_enabled && modem->has_location;
-
-	/* If the modem doesn't signal its location, start polling for the
-	 * location now.
-	 */
-	if (new_avail && !modem->signals && !modem->loc_idle) {
-		modem->loc_idle = g_timeout_add_seconds (20, modem_loc_poll, modem);
-		/* Kick off a quick location request */
-		modem_loc_poll (modem);
-	}
-
-	/* If the modem is no longer enabled, or it now signals its location
-	 * then we no longer need to poll.
-	 */
-	if ((!new_avail || modem->signals) && modem->loc_idle)
-		g_source_remove (modem->loc_idle);
-
-	/* Tell the manager to recheck availability of location info */
-	if (old_avail != new_avail)
-		recheck_available (modem->owner);
-
-	/* If we've successfully retrieved modem properties and the modem
-	 * isn't enabled, do that now.
-	 */
-	if (modem->got_enabled && !modem->enabled && !modem->enabling) {
-		debugmsg ("%s: (%s) enabling...", __func__, modem->path);
-		modem->enabling = TRUE;
-		dbus_g_proxy_begin_call (modem->modem_proxy, "Enable",
-			                 modem_enable_cb, modem, NULL,
-			                 G_TYPE_BOOLEAN, TRUE, G_TYPE_INVALID);
-	}
-
-	/* If the modem was already enabled but location services weren't,
-	 * enable them now.
-	 */
-	modem_try_loc_enable (modem);
-
-	/* After location is enabled, try to get the location ASAP */
-	if (modem->has_location && modem->loc_enabled && !modem->got_initial_loc) {
-		modem->got_initial_loc = TRUE;
-		modem_loc_poll (modem);
-	}
-}
-
-static void
-modem_props_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	GError *error = NULL;
-	GHashTable *props = NULL;
-	Modem *modem = user_data;
-
-	if (!dbus_g_proxy_end_call (proxy, call, &error,
-	                            DBUS_TYPE_G_MAP_OF_VARIANT, &props,
-	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed to get modem interface properties: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-
-	modem_properties_changed (modem->loc_proxy, MM_DBUS_MODEM_INTERFACE, props, modem);
-	g_hash_table_destroy (props);
-}
-
-static void
-loc_props_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	GError *error = NULL;
-	GHashTable *props = NULL;
-	Modem *modem = user_data;
-
-	if (!dbus_g_proxy_end_call (proxy, call, &error,
-	                            DBUS_TYPE_G_MAP_OF_VARIANT, &props,
-	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed to get location interface properties: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-
-	modem_properties_changed (modem->loc_proxy, MM_DBUS_LOC_INTERFACE, props, modem);
-	g_hash_table_destroy (props);
-
-	/* Now that we know the device supports location services, get basic
-	 * modem properties and start grabbing location info.
-	 */
-	dbus_g_proxy_begin_call (modem->props_proxy, "GetAll",
-	                         modem_props_cb, modem, NULL,
-	                         G_TYPE_STRING, MM_DBUS_MODEM_INTERFACE, G_TYPE_INVALID);
-}
-
-static Modem *
-modem_new (DBusGConnection *bus, const char *path, gpointer owner)
-{
-	Modem *modem;
-
-	modem = g_slice_new0 (Modem);
-	modem->owner = owner;
-	modem->path = g_strdup (path);
-
-	modem->loc_proxy = dbus_g_proxy_new_for_name (bus,
-	                                              MM_DBUS_SERVICE,
-	                                              path,
-	                                              MM_DBUS_LOC_INTERFACE);
-
-	modem->modem_proxy = dbus_g_proxy_new_for_name (bus,
-	                                                MM_DBUS_SERVICE,
-	                                                path,
-	                                                MM_DBUS_MODEM_INTERFACE);
-
-	/* Listen for property changes */
-	modem->props_proxy = dbus_g_proxy_new_for_name (bus,
-	                                                MM_DBUS_SERVICE,
-	                                                path,
-	                                                "org.freedesktop.DBus.Properties");
-	dbus_g_object_register_marshaller (mm_marshal_VOID__STRING_BOXED,
-	                                   G_TYPE_NONE,
-	                                   G_TYPE_STRING, DBUS_TYPE_G_MAP_OF_VARIANT,
-	                                   G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (modem->props_proxy, "MmPropertiesChanged",
-	                         G_TYPE_STRING, DBUS_TYPE_G_MAP_OF_VARIANT,
-	                         G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (modem->props_proxy, "MmPropertiesChanged",
-	                             G_CALLBACK (modem_properties_changed),
-	                             modem,
-	                             NULL);
-
-	debugmsg ("%s: (%s) modem created", __func__, path);
-
-	/* Check if the Location interface is actually supported before doing
-	 * anything with the modem, because if it's not, we don't care about
-	 * the modem at all.
-	 */
-	dbus_g_proxy_begin_call (modem->props_proxy, "GetAll",
-	                         loc_props_cb, modem, NULL,
-	                         G_TYPE_STRING, MM_DBUS_LOC_INTERFACE, G_TYPE_INVALID);
-
-	return modem;
-}
-
-static void
-modem_free (Modem *modem)
-{
-
-	debugmsg ("%s: (%s) modem removed", __func__, modem->path);
-
-	g_free (modem->path);
-	g_object_unref (modem->loc_proxy);
-	g_object_unref (modem->modem_proxy);
-	g_object_unref (modem->props_proxy);
-
-	if (modem->loc_idle)
-		g_source_remove (modem->loc_idle);
-
-	memset (modem, 0, sizeof (Modem));
-	g_slice_free (Modem, modem);
-}
-
-static void
-modem_added (DBusGProxy *proxy, const char *path, gpointer user_data)
-{
-	GeoclueGsmlocMm *self = GEOCLUE_GSMLOC_MM (user_data);
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-	Modem *modem;
-
-	if (!find_modem (self, path)) {
-		modem = modem_new (priv->bus, path, self);
-		priv->modems = g_slist_prepend (priv->modems, modem);
-	}
-}
-
-static void
-enumerate_modems_cb (DBusGProxy *proxy, DBusGProxyCall *call, gpointer user_data)
-{
-	GPtrArray *modems;
-	GError *error = NULL;
-	int i;
-
-	if (!dbus_g_proxy_end_call (proxy, call, &error,
-	                            dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &modems,
-	                            G_TYPE_INVALID)) {
-		g_warning ("%s: failed to enumerate modems: (%d) %s",
-		           __func__,
-		           error ? error->code : -1,
-		           error && error->message ? error->message : "(unknown)");
-		g_clear_error (&error);
-		return;
-	}
-
-	for (i = 0; i < modems->len; i++) {
-		char *path = g_ptr_array_index (modems, i);
-
-		modem_added (NULL, path, GEOCLUE_GSMLOC_MM (user_data));
-		g_free (path);
-	}
-	g_ptr_array_free (modems, TRUE);
-}
-
-static void
-enumerate_modems (GeoclueGsmlocMm *self)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-
-	dbus_g_proxy_begin_call (priv->mm_proxy, "EnumerateDevices",
-	                         enumerate_modems_cb, self, NULL,
-	                         G_TYPE_INVALID);
-}
-
-static void
-modem_removed (DBusGProxy *proxy, const char *path, gpointer user_data)
-{
-	GeoclueGsmlocMm *self = GEOCLUE_GSMLOC_MM (user_data);
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-	Modem *modem;
-
-	modem = find_modem (self, path);
-	if (modem) {
-		gboolean old_available = is_available (self);
-
-		priv->modems = g_slist_remove (priv->modems, modem);
-		modem_free (modem);
-		if (is_available (self) != old_available)
-			g_object_notify (G_OBJECT (self), "available");
-	}
-}
-
-static void
-kill_modems (GeoclueGsmlocMm *self)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-	gboolean old_available = is_available (self);
-	GSList *iter;
-
-	/* Kill all modems */
-	for (iter = priv->modems; iter; iter = g_slist_next (iter))
-		modem_free ((Modem *) iter->data);
-	g_slist_free (priv->modems);
-	priv->modems = NULL;
-
-	/* No more modems; clearly location is no longer available */
-	if (old_available)
-		g_object_notify (G_OBJECT (self), "available");
-}
-
-static void
-name_owner_changed (DBusGProxy *proxy,
-                    const char *name,
-                    const char *old_owner,
-                    const char *new_owner,
-                    gpointer user_data)
-{
-	gboolean old_owner_good;
-	gboolean new_owner_good;
-
-	if (strcmp (MM_DBUS_SERVICE, name) != 0)
-		return;
-
-	old_owner_good = (old_owner && strlen (old_owner));
-	new_owner_good = (new_owner && strlen (new_owner));
-
-	if (!old_owner_good && new_owner_good) {
-		debugmsg ("ModemManager appeared");
-		enumerate_modems (GEOCLUE_GSMLOC_MM (user_data));
-	} else if (old_owner_good && !new_owner_good) {
-		debugmsg ("ModemManager disappeared");
-		kill_modems (GEOCLUE_GSMLOC_MM (user_data));
-	}
-}
-
-GeoclueGsmlocMm *
-geoclue_gsmloc_mm_new (void)
-{
-	return (GeoclueGsmlocMm *) g_object_new (GEOCLUE_TYPE_GSMLOC_MM, NULL);
-}
-
-static gboolean
-mm_alive (DBusGProxy *proxy)
-{
-	char *owner = NULL;
-	gboolean owned = FALSE;
-	GError *error = NULL;
-
-	if (dbus_g_proxy_call_with_timeout (proxy,
-	                                    "GetNameOwner", 2000, &error,
-	                                    G_TYPE_STRING, MM_DBUS_SERVICE,
-	                                    G_TYPE_INVALID,
-	                                    G_TYPE_STRING, &owner,
-	                                    G_TYPE_INVALID)) {
-		owned = !!owner;
-		g_free (owner);
-	}
-	return owned;
-}
-
-static void
-geoclue_gsmloc_mm_init (GeoclueGsmlocMm *self)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (self);
-
-	if (getenv ("GEOCLUE_GSMLOC_MM_DEBUG"))
-		mm_debug = TRUE;
-
-	priv->bus = dbus_g_bus_get (DBUS_BUS_SYSTEM, NULL);
-	if (!priv->bus) {
-		g_warning ("Failed to acquire a connection to the D-Bus system bus.");
-		return;
-	}
-
-	priv->dbus_proxy = dbus_g_proxy_new_for_name (priv->bus,
-	                                              DBUS_SERVICE_DBUS,
-	                                              DBUS_PATH_DBUS,
-	                                              DBUS_INTERFACE_DBUS);
-	/* Handle ModemManager restarts */
-	dbus_g_proxy_add_signal (priv->dbus_proxy, "NameOwnerChanged",
-				 G_TYPE_STRING, G_TYPE_STRING,
-				 G_TYPE_STRING, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (priv->dbus_proxy, "NameOwnerChanged",
-				     G_CALLBACK (name_owner_changed),
-				     self, NULL);
-
-	priv->mm_proxy = dbus_g_proxy_new_for_name (priv->bus,
-	                                            MM_DBUS_SERVICE,
-	                                            MM_DBUS_PATH,
-	                                            MM_DBUS_INTERFACE);
-	g_assert (priv->mm_proxy);
-
-	dbus_g_proxy_add_signal (priv->mm_proxy, "DeviceAdded",
-	                         DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (priv->mm_proxy, "DeviceAdded",
-	                             G_CALLBACK (modem_added), self, NULL);
-	dbus_g_proxy_add_signal (priv->mm_proxy, "DeviceRemoved",
-	                         DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (priv->mm_proxy, "DeviceRemoved",
-	                             G_CALLBACK (modem_removed), self, NULL);
-
-	if (mm_alive (priv->dbus_proxy)) {
-		debugmsg ("ModemManager is alive");
-		enumerate_modems (self);
-	}
-}
-
-static void
-dispose (GObject *object)
-{
-	GeoclueGsmlocMmPrivate *priv = GEOCLUE_GSMLOC_MM_GET_PRIVATE (object);
-
-	kill_modems (GEOCLUE_GSMLOC_MM (object));
-
-	/* Stop listening to ModemManager */
-	if (priv->mm_proxy) {
-		g_object_unref (priv->mm_proxy);
-		priv->mm_proxy = NULL;
-	}
-
-	if (priv->props_proxy) {
-		g_object_unref (priv->props_proxy);
-		priv->props_proxy = NULL;
-	}
-
-	if (priv->dbus_proxy) {
-		g_object_unref (priv->dbus_proxy);
-		priv->dbus_proxy = NULL;
-	}
-
-	G_OBJECT_CLASS (geoclue_gsmloc_mm_parent_class)->dispose (object);
-}
-
-static void
-get_property (GObject *object, guint prop_id,
-              GValue *value, GParamSpec *pspec)
-{
-	switch (prop_id) {
-	case PROP_AVAILABLE:
-		g_value_set_boolean (value, is_available (GEOCLUE_GSMLOC_MM (object)));
-		break;
-	default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-		break;
-	}
-}
-
-static void
-geoclue_gsmloc_mm_class_init (GeoclueGsmlocMmClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-	g_type_class_add_private (klass, sizeof (GeoclueGsmlocMmPrivate));
-
-	/* virtual methods */
-	object_class->get_property = get_property;
-	object_class->dispose = dispose;
-
-	/* properties */
-	g_object_class_install_property
-		(object_class, PROP_AVAILABLE,
-		 g_param_spec_boolean ("available",
-		                       "Available",
-		                       "Whether any mobile broadband device is "
-		                       "providing location information at this "
-		                       "time.",
-		                       FALSE,
-		                       G_PARAM_READABLE));
-
-	/* signals */
-	signals[NETWORK_DATA_CHANGED] =
-		g_signal_new ("network-data-changed",
-		              G_OBJECT_CLASS_TYPE (klass),
-		              G_SIGNAL_RUN_LAST, 0,
-		              NULL, NULL,
-		              mm_marshal_VOID__STRING_STRING_STRING_STRING,
-		              G_TYPE_NONE, 4,
-		              G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-}
-
Index: geoclue/providers/gsmloc/geoclue-gsmloc-mm.h
===================================================================
--- geoclue.orig/providers/gsmloc/geoclue-gsmloc-mm.h	2011-12-29 16:41:40.362430014 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-/*
- * Geoclue
- * geoclue-gsmloc-mm.h - An Address/Position provider for ModemManager
- *
- * Author: Dan Williams <dcbw@redhat.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- */
-
-#ifndef _GEOCLUE_GSMLOC_MM
-#define _GEOCLUE_GSMLOC_MM
-
-#include <glib-object.h>
-
-G_BEGIN_DECLS
-
-#define GEOCLUE_TYPE_GSMLOC_MM (geoclue_gsmloc_mm_get_type ())
-
-#define GEOCLUE_GSMLOC_MM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOCLUE_TYPE_GSMLOC_MM, GeoclueGsmlocMm))
-#define GEOCLUE_GSMLOC_MM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOCLUE_TYPE_GSMLOC_MM, GeoclueGsmlocMmClass))
-#define GEOCLUE_IS_GSMLOC_MM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOCLUE_TYPE_GSMLOC_MM))
-#define GEOCLUE_IS_GSMLOC_MM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOCLUE_TYPE_GSMLOC_MM))
-
-typedef struct _GeoclueGsmlocMm {
-	GObject parent;
-} GeoclueGsmlocMm;
-
-typedef struct _GeoclueGsmlocMmClass {
-	GObjectClass parent_class;
-
-	void (*network_data_changed) (GeoclueGsmlocMm *mm,
-	                              char *mcc, char *mnc,
-	                              char *lac, char *cid);
-} GeoclueGsmlocMmClass;
-
-GType geoclue_gsmloc_mm_get_type (void);
-
-GeoclueGsmlocMm *geoclue_gsmloc_mm_new (void);
-
-G_END_DECLS
-
-#endif  /* _GEOCLUE_GSMLOC_MM */
-
Index: geoclue/providers/gsmloc/geoclue-gsmloc.c
===================================================================
--- geoclue.orig/providers/gsmloc/geoclue-gsmloc.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gsmloc/geoclue-gsmloc.c	2011-12-29 16:40:38.926428900 +0900
@@ -1,11 +1,10 @@
 /*
  * Geoclue
  * geoclue-gsmloc.c - A GSM cell based Position provider
- * 
+ *
  * Author: Jussi Kukkonen <jku@linux.intel.com>
  * Copyright 2008 by Garmin Ltd. or its subsidiaries
  *           2010 Intel Corporation
- *           2010 Red Hat, Inc.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -24,18 +23,18 @@
  *
  */
 
- /** 
-  * Gsmloc provider is a position and address provider that uses GSM cell 
+ /**
+  * Gsmloc provider is a position and address provider that uses GSM cell
   * location and the webservice http://www.opencellid.org/ (a similar service
   * used to live at gsmloc.org, hence the name). The web service does not
-  * provide any address data: that is done with a 
+  * provide any address data: that is done with a
   * "mobile country code -> ISO country code" lookup table: as a result address
   * will only ever have country code and country fields.
-  * 
-  * Gsmloc requires the oFono or ModemManager telephony stacks to work -- more
-  * IMSI data sources could be added fairly easily.
+  *
+  * Gsmloc requires the telephony stack oFono to work -- more IMSI data
+  * sources could be added fairly easily.
   **/
-  
+
 #include <config.h>
 
 #include <time.h>
@@ -55,9 +54,6 @@
 /* ofono implementation */
 #include "geoclue-gsmloc-ofono.h"
 
-/* ModemManager implementation */
-#include "geoclue-gsmloc-mm.h"
-
 /* country code list */
 #include "mcc.h"
 
@@ -80,7 +76,6 @@
 	GcWebService *web_service;
 
 	GeoclueGsmlocOfono *ofono;
-	GeoclueGsmlocMm *mm;
 
 	/* current data */
 	char *mcc;
@@ -119,17 +114,15 @@
 {
 	GeoclueGsmloc *gsmloc = GEOCLUE_GSMLOC (iface);
 	gboolean ofono_available;
-	gboolean mm_available;
 
 	g_object_get (gsmloc->ofono, "available", &ofono_available, NULL);
-	g_object_get (gsmloc->mm, "available", &mm_available, NULL);
 
-	if (!ofono_available && !mm_available) {
+	if (!ofono_available) {
 		*status = GEOCLUE_STATUS_ERROR;
 	} else if (!gsmloc->mcc || !gsmloc->mnc ||
 	           !gsmloc->lac || !gsmloc->cid) {
 		*status = GEOCLUE_STATUS_UNAVAILABLE;
-	} else { 
+	} else {
 		*status = GEOCLUE_STATUS_AVAILABLE;
 	}
 	return TRUE;
@@ -159,11 +152,11 @@
 		                          "cellid", gsmloc->cid,
 		                          (char *)0)) {
 
-			if (gc_web_service_get_double (gsmloc->web_service, 
+			if (gc_web_service_get_double (gsmloc->web_service,
 			                               &lat, OPENCELLID_LAT)) {
 				fields |= GEOCLUE_POSITION_FIELDS_LATITUDE;
 			}
-			if (gc_web_service_get_double (gsmloc->web_service, 
+			if (gc_web_service_get_double (gsmloc->web_service,
 			                               &lon, OPENCELLID_LON)) {
 				fields |= GEOCLUE_POSITION_FIELDS_LONGITUDE;
 			}
@@ -171,10 +164,10 @@
 			if (fields != GEOCLUE_POSITION_FIELDS_NONE) {
 				char *retval_cid;
 				/* if cellid is not present, location is for the local area code.
-				 * the accuracy might be an overstatement -- I have no idea how 
+				 * the accuracy might be an overstatement -- I have no idea how
 				 * big LACs typically are */
 				level = GEOCLUE_ACCURACY_LEVEL_LOCALITY;
-				if (gc_web_service_get_string (gsmloc->web_service, 
+				if (gc_web_service_get_string (gsmloc->web_service,
 				                               &retval_cid, OPENCELLID_CID)) {
 					if (retval_cid && strlen (retval_cid) != 0) {
 						level = GEOCLUE_ACCURACY_LEVEL_POSTALCODE;
@@ -250,13 +243,13 @@
 		                                       time (NULL),
 		                                       gsmloc->address,
 		                                       acc);
-		
+
 	}
 	geoclue_accuracy_free (acc);
 }
 static void
 geoclue_gsmloc_set_cell (GeoclueGsmloc *gsmloc,
-                         const char *mcc, const char *mnc, 
+                         const char *mcc, const char *mnc,
                          const char *lac, const char *cid)
 {
 	g_free (gsmloc->mcc);
@@ -275,7 +268,7 @@
 
 static void
 network_data_changed_cb (gpointer connection_manager,
-                         const char *mcc, const char *mnc, 
+                         const char *mcc, const char *mnc,
                          const char *lac, const char *cid,
                          GeoclueGsmloc *gsmloc)
 {
@@ -291,7 +284,7 @@
 
 /* Position interface implementation */
 
-static gboolean 
+static gboolean
 geoclue_gsmloc_get_position (GcIfacePosition        *iface,
                              GeocluePositionFields  *fields,
                              int                    *timestamp,
@@ -371,14 +364,6 @@
 		gsmloc->ofono = NULL;
 	}
 
-	if (gsmloc->mm) {
-		g_signal_handlers_disconnect_by_func (gsmloc->mm,
-		                                      network_data_changed_cb,
-		                                      gsmloc);
-		g_object_unref (gsmloc->mm);
-		gsmloc->mm = NULL;
-	}
-
 	if (gsmloc->address) {
 		g_hash_table_destroy (gsmloc->address);
 		gsmloc->address = NULL;
@@ -407,7 +392,7 @@
 {
 	gsmloc->address = geoclue_address_details_new ();
 
-	gc_provider_set_details (GC_PROVIDER (gsmloc), 
+	gc_provider_set_details (GC_PROVIDER (gsmloc),
 	                         GEOCLUE_DBUS_SERVICE_GSMLOC,
 	                         GEOCLUE_DBUS_PATH_GSMLOC,
 	                         "Gsmloc", "GSM cell based position provider");
@@ -423,11 +408,6 @@
 	gsmloc->ofono = geoclue_gsmloc_ofono_new ();
 	g_signal_connect (gsmloc->ofono, "network-data-changed",
 	                  G_CALLBACK (network_data_changed_cb), gsmloc);
-
-	/* init mm */
-	gsmloc->mm = geoclue_gsmloc_mm_new ();
-	g_signal_connect (gsmloc->mm, "network-data-changed",
-	                  G_CALLBACK (network_data_changed_cb), gsmloc);
 }
 
 static void
@@ -442,7 +422,7 @@
 	iface->get_address = geoclue_gsmloc_get_address;
 }
 
-int 
+int
 main()
 {
 	g_type_init();
Index: geoclue/providers/gsmloc/mm-marshal.list
===================================================================
--- geoclue.orig/providers/gsmloc/mm-marshal.list	2011-12-29 16:41:40.362430014 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,2 +0,0 @@
-VOID:STRING,STRING,STRING,STRING
-VOID:STRING,BOXED
Index: geoclue/providers/gypsy/Makefile.am
===================================================================
--- geoclue.orig/providers/gypsy/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gypsy/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -22,7 +22,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/gypsy/geoclue-gypsy.c
===================================================================
--- geoclue.orig/providers/gypsy/geoclue-gypsy.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/gypsy/geoclue-gypsy.c	2011-12-29 16:40:38.926428900 +0900
@@ -38,7 +38,6 @@
 	GcProvider parent;
 
         char *device_name;
-        guint baud_rate;
 
 	GypsyControl *control;
 	GypsyDevice *device;
@@ -123,14 +122,14 @@
 gypsy_position_to_geoclue (GypsyPositionFields fields)
 {
 	GeocluePositionFields gc_fields = GEOCLUE_POSITION_FIELDS_NONE;
-	
+
 	gc_fields |= (fields & GYPSY_POSITION_FIELDS_LATITUDE) ? GEOCLUE_POSITION_FIELDS_LATITUDE : 0;
 	gc_fields |= (fields & GYPSY_POSITION_FIELDS_LONGITUDE) ? GEOCLUE_POSITION_FIELDS_LONGITUDE : 0;
 	gc_fields |= (fields & GYPSY_POSITION_FIELDS_ALTITUDE) ? GEOCLUE_POSITION_FIELDS_ALTITUDE : 0;
-	
+
 	return gc_fields;
 }
-	      
+
 static GeoclueVelocityFields
 gypsy_course_to_geoclue (GypsyCourseFields fields)
 {
@@ -188,9 +187,9 @@
 
                 g_print ("Emitting signal\n");
 		fields = gypsy_position_to_geoclue (gypsy->position_fields);
-		gc_iface_position_emit_position_changed 
+		gc_iface_position_emit_position_changed
 			(GC_IFACE_POSITION (gypsy), fields,
-			 timestamp, gypsy->latitude, gypsy->longitude, 
+			 timestamp, gypsy->latitude, gypsy->longitude,
 			 gypsy->altitude, gypsy->accuracy);
 	}
 }
@@ -238,12 +237,12 @@
 		GeoclueVelocityFields fields;
 
 		fields = gypsy_course_to_geoclue (gypsy->course_fields);
-		gc_iface_velocity_emit_velocity_changed 
+		gc_iface_velocity_emit_velocity_changed
 			(GC_IFACE_VELOCITY (gypsy), fields,
 			 timestamp, gypsy->speed, gypsy->direction, gypsy->climb);
 	}
 }
-		
+
 static void
 accuracy_changed (GypsyAccuracy      *accuracy,
 		  GypsyAccuracyFields fields,
@@ -257,7 +256,7 @@
 	double horiz, vert;
 
 	geoclue_accuracy_get_details (gypsy->accuracy, &level, &horiz, &vert);
-	if (fields & (GYPSY_ACCURACY_FIELDS_HORIZONTAL | 
+	if (fields & (GYPSY_ACCURACY_FIELDS_HORIZONTAL |
 		      GYPSY_ACCURACY_FIELDS_VERTICAL)){
 		if (level != GEOCLUE_ACCURACY_LEVEL_DETAILED ||
 		    horiz != hdop || vert != vdop) {
@@ -281,11 +280,11 @@
 
 	if (changed) {
 		GeocluePositionFields fields;
-		
+
 		fields = gypsy_position_to_geoclue (gypsy->position_fields);
-		gc_iface_position_emit_position_changed 
+		gc_iface_position_emit_position_changed
 			(GC_IFACE_POSITION (gypsy), fields,
-			 gypsy->timestamp, gypsy->latitude, gypsy->longitude, 
+			 gypsy->timestamp, gypsy->latitude, gypsy->longitude,
 			 gypsy->altitude, gypsy->accuracy);
 	}
 }
@@ -295,7 +294,7 @@
 		    gboolean      connected,
 		    GeoclueGypsy *gypsy)
 {
-	if (connected == FALSE && 
+	if (connected == FALSE &&
 	    gypsy->status != GEOCLUE_STATUS_UNAVAILABLE) {
 		gypsy->status = GEOCLUE_STATUS_UNAVAILABLE;
 		gc_iface_geoclue_emit_status_changed (GC_IFACE_GEOCLUE (gypsy),
@@ -379,26 +378,14 @@
              GError        **error)
 {
         GeoclueGypsy *gypsy = GEOCLUE_GYPSY (gc);
-        GValue *device_value, *baud_rate_value;
         const char *device_name;
         char *path;
-        int baud_rate;
 
-	device_value = g_hash_table_lookup (options,
-					    "org.freedesktop.Geoclue.GPSDevice");
-	device_name = device_value ? g_value_get_string (device_value) : NULL;
-	baud_rate_value = g_hash_table_lookup (options,
-					   "org.freedesktop.Geoclue.GPSBaudRate");
-	baud_rate = baud_rate_value ? g_value_get_int (baud_rate_value) : 0;
+        device_name = g_hash_table_lookup (options,
+                                           "org.freedesktop.Geoclue.GPSDevice");
 
-        if (g_strcmp0 (gypsy->device_name, device_name) == 0 &&
-            gypsy->baud_rate == baud_rate)
-		return TRUE;
-
-	/* Disconnect from the old device, if any */
-	if (gypsy->device != NULL) {
-		g_object_unref (gypsy->device);
-		gypsy->device = NULL;
+        if (g_strcmp0 (gypsy->device_name, device_name) == 0) {
+        	return TRUE;
 	}
 
 	g_free (gypsy->device_name);
@@ -409,8 +396,7 @@
 	}
 
         gypsy->device_name = g_strdup (device_name);
-        gypsy->baud_rate = baud_rate;
-        g_print ("Gypsy provider using '%s' at %d bps\n", gypsy->device_name, gypsy->baud_rate);
+        g_print ("Gypsy provider using '%s'\n", gypsy->device_name);
 	path = gypsy_control_create (gypsy->control, gypsy->device_name,
 				     error);
 	if (*error != NULL) {
@@ -427,7 +413,7 @@
 			  G_CALLBACK (connection_changed), gypsy);
 	g_signal_connect (gypsy->device, "fix-status-changed",
 			  G_CALLBACK (fix_status_changed), gypsy);
-	
+
 	gypsy->position = gypsy_position_new (path);
 	g_signal_connect (gypsy->position, "position-changed",
 			  G_CALLBACK (position_changed), gypsy);
@@ -437,26 +423,8 @@
 	gypsy->acc = gypsy_accuracy_new (path);
 	g_signal_connect (gypsy->acc, "accuracy-changed",
 			  G_CALLBACK (accuracy_changed), gypsy);
-	
+
 	g_debug ("starting device");
-	if (gypsy->baud_rate != 0) {
-		GHashTable *goptions;
-		GValue speed_val = { 0, };
-		GError *err = NULL;
-
-		g_value_init (&speed_val, G_TYPE_UINT);
-		g_value_set_uint (&speed_val, gypsy->baud_rate);
-		goptions = g_hash_table_new (g_str_hash,
-					     g_str_equal);
-		g_hash_table_insert (goptions, "BaudRate", &speed_val);
-		if (!gypsy_device_set_start_options (gypsy->device,
-						    goptions,
-						    &err)) {
-			g_warning ("Error: %s", err->message);
-			g_error_free (err);
-		}
-		g_hash_table_destroy (goptions);
-	}
 	gypsy_device_start (gypsy->device, error);
 	if (*error != NULL) {
 		g_print ("Error - %s?\n", (*error)->message);
@@ -466,7 +434,7 @@
 	}
 	get_initial_status (gypsy);
 	g_free (path);
-	
+
 	return TRUE;
 }
 
@@ -474,7 +442,7 @@
 shutdown (GcProvider *provider)
 {
 	GeoclueGypsy *gypsy = GEOCLUE_GYPSY (provider);
-	
+
 	g_main_loop_quit (gypsy->loop);
 }
 
@@ -556,7 +524,7 @@
 	GeoclueGypsy *gypsy = GEOCLUE_GYPSY (gc);
 	GeoclueAccuracyLevel level;
 	double horizontal, vertical;
-	
+
 	*timestamp = gypsy->timestamp;
 
 	*fields = GEOCLUE_POSITION_FIELDS_NONE;
@@ -576,7 +544,7 @@
 	geoclue_accuracy_get_details (gypsy->accuracy, &level,
 				      &horizontal, &vertical);
 	*accuracy = geoclue_accuracy_new (level, horizontal, vertical);
-		
+
 	return TRUE;
 }
 
Index: geoclue/providers/hostip/Makefile.am
===================================================================
--- geoclue.orig/providers/hostip/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/hostip/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -15,7 +15,7 @@
 
 geoclue_hostip_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-hostip.provider
@@ -25,7 +25,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/localnet/Makefile.am
===================================================================
--- geoclue.orig/providers/localnet/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/localnet/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -10,17 +10,15 @@
 	$(nodist_geoclue_localnet_SOURCES)
 
 geoclue_localnet_SOURCES = 	\
-	geoclue-localnet.c     
+	geoclue-localnet.c
 
 geoclue_localnet_CFLAGS = \
 	-I$(top_srcdir)     \
 	-I$(top_builddir)   \
-	-I$(top_srcdir)/src \
 	$(GEOCLUE_CFLAGS)
 
 geoclue_localnet_LDADD = \
 	$(GEOCLUE_LIBS)    \
-	$(top_builddir)/src/libconnectivity.la \
 	$(top_builddir)/geoclue/libgeoclue.la
 
 
@@ -32,7 +30,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 CLEANFILES = \
 	stamp-geoclue-localnet-glue.h
@@ -50,7 +48,7 @@
 	@true
 
 stamp-geoclue-localnet-glue.h: geoclue-localnet.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=geoclue_localnet --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=geoclue_localnet --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
Index: geoclue/providers/localnet/geoclue-localnet.c
===================================================================
--- geoclue.orig/providers/localnet/geoclue-localnet.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/localnet/geoclue-localnet.c	2011-12-29 16:40:38.926428900 +0900
@@ -1,27 +1,27 @@
 /**
- * 
+ *
  * Expects to find a keyfile in user config dir
- * (~/.config/geoclue-localnet-gateways). 
- * 
+ * (~/.config/geoclue-localnet-gateways).
+ *
  * The keyfile should contain entries like this:
- * 
+ *
  * [00:1D:7E:55:8D:80]
  * country=Finland
  * street=Solnantie 24
  * locality=Helsinki
  *
- * Only address interface is supported so far. 
- * 
- * Any application that can obtain a reliable address can submit it 
+ * Only address interface is supported so far.
+ *
+ * Any application that can obtain a reliable address can submit it
  * to localnet provider through the D-Bus API -- it will then be provided
  * whenever connected to the same router:
  *    org.freedesktop.Geoclue.Localnet.SetAddress
  *    org.freedesktop.Geoclue.Localnet.SetAddressFields
  *
- * SetAddress allows setting the current address as a GeoclueAddress, 
- * while SetAddressFields is a convenience version with separate 
+ * SetAddress allows setting the current address as a GeoclueAddress,
+ * while SetAddressFields is a convenience version with separate
  * address fields. Shell example using SetAddressFields:
- * 
+ *
   dbus-send --print-reply --type=method_call \
             --dest=org.freedesktop.Geoclue.Providers.Localnet \
             /org/freedesktop/Geoclue/Providers/Localnet \
@@ -33,9 +33,9 @@
             string: \
             string: \
             string:"Solnantie 24"
-  
- * This would make the provider save the specified address with current 
- * router mac address. It will provide the address to clients whenever 
+
+ * This would make the provider save the specified address with current
+ * router mac address. It will provide the address to clients whenever
  * the computer is connected to the same router again.
  *
  * This library is free software; you can redistribute it and/or
@@ -53,7 +53,7 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *
- */ 
+ */
 
 #include <config.h>
 
@@ -69,8 +69,6 @@
 #include <geoclue/geoclue-error.h>
 #include <geoclue/gc-iface-address.h>
 
-#include "connectivity.h"
-
 #define KEYFILE_NAME "geoclue-localnet-gateways"
 
 typedef struct {
@@ -82,9 +80,8 @@
 
 typedef struct {
 	GcProvider parent;
-	
+
 	GMainLoop *loop;
-	GeoclueConnectivity *conn;
 
 	char *keyfile_name;
 	GSList *gateways;
@@ -121,7 +118,7 @@
 shutdown (GcProvider *provider)
 {
 	GeoclueLocalnet *localnet;
-	
+
 	localnet = GEOCLUE_LOCALNET (provider);
 	g_main_loop_quit (localnet->loop);
 }
@@ -130,17 +127,17 @@
 free_gateway_list (GSList *gateways)
 {
 	GSList *l;
-	
+
 	l = gateways;
 	while (l) {
 		Gateway *gw;
-		
+
 		gw = l->data;
 		g_free (gw->mac);
 		g_hash_table_destroy (gw->address);
 		geoclue_accuracy_free (gw->accuracy);
 		g_free (gw);
-		
+
 		l = l->next;
 	}
 	g_slist_free (gateways);
@@ -150,16 +147,12 @@
 finalize (GObject *object)
 {
 	GeoclueLocalnet *localnet;
-	
+
 	localnet = GEOCLUE_LOCALNET (object);
 
-	if (localnet->conn != NULL) {
-		g_object_unref (localnet->conn);
-		localnet->conn = NULL;
-	}
 	g_free (localnet->keyfile_name);
 	free_gateway_list (localnet->gateways);
-	
+
 	G_OBJECT_CLASS (geoclue_localnet_parent_class)->finalize (object);
 }
 
@@ -168,25 +161,113 @@
 {
 	GcProviderClass *p_class = (GcProviderClass *) klass;
 	GObjectClass *o_class = (GObjectClass *) klass;
-	
+
 	o_class->finalize = finalize;
-	
+
 	p_class->get_status = get_status;
 	p_class->shutdown = shutdown;
-	
+
 	dbus_g_object_type_install_info (geoclue_localnet_get_type (),
 	                                 &dbus_glib_geoclue_localnet_object_info);
 
 }
 
+/* Parse /proc/net/route to get default gateway address and then parse
+ * /proc/net/arp to find matching mac address.
+ *
+ * There are some problems with this. First, it's IPv4 only.
+ * Second, there must be a way to do this with ioctl, but that seemed really
+ * complicated... even /usr/sbin/arp parses /proc/net/arp
+ *
+ * returns:
+ *   1 : on success
+ *   0 : no success, no errors
+ *  <0 : error
+ */
+int
+get_mac_address (char **mac)
+{
+	char *content;
+	char **lines, **entry;
+	GError *error = NULL;
+	char *route_gateway = NULL;
+
+	g_assert (*mac == NULL);
+
+	if (!g_file_get_contents ("/proc/net/route", &content, NULL, &error)) {
+		g_warning ("Failed to read /proc/net/route: %s", error->message);
+		g_error_free (error);
+		return -1;
+	}
+
+	lines = g_strsplit (content, "\n", 0);
+	g_free (content);
+	entry = lines + 1;
+
+	while (*entry && strlen (*entry) > 0) {
+		char dest[9];
+		char gateway[9];
+		if (sscanf (*entry,
+			        "%*s %8[0-9A-Fa-f] %8[0-9A-Fa-f] %*s",
+			        dest, gateway) != 2) {
+			g_warning ("Failed to parse /proc/net/route entry '%s'", *entry);
+		} else if (strcmp (dest, "00000000") == 0) {
+			route_gateway = g_strdup (gateway);
+			break;
+		}
+		entry++;
+	}
+	g_strfreev (lines);
+
+	if (!route_gateway) {
+		g_warning ("Failed to find default route in /proc/net/route");
+		return -1;
+	}
+
+	if (!g_file_get_contents ("/proc/net/arp", &content, NULL, &error)) {
+		g_warning ("Failed to read /proc/net/arp: %s", error->message);
+		g_error_free (error);
+		return -1;
+	}
+
+	lines = g_strsplit (content, "\n", 0);
+	g_free (content);
+	entry = lines+1;
+	while (*entry && strlen (*entry) > 0) {
+		char hwa[100];
+		char *arp_gateway;
+		int ip[4];
+
+		if (sscanf(*entry,
+		           "%d.%d.%d.%d 0x%*x 0x%*x %100s %*s %*s\n",
+		           &ip[0], &ip[1], &ip[2], &ip[3], hwa) != 5) {
+			g_warning ("Failed to parse /proc/net/arp entry '%s'", *entry);
+		} else {
+			arp_gateway = g_strdup_printf ("%02X%02X%02X%02X", ip[3], ip[2], ip[1], ip[0]);
+			if (strcmp (arp_gateway, route_gateway) == 0) {
+				g_free (arp_gateway);
+				*mac = g_strdup (hwa);
+				break;
+			}
+			g_free (arp_gateway);
+
+		}
+		entry++;
+	}
+	g_free (route_gateway);
+	g_strfreev (lines);
+
+	return *mac ? 1 : 0;
+}
+
 static void
-geoclue_localnet_load_gateways_from_keyfile (GeoclueLocalnet  *localnet, 
+geoclue_localnet_load_gateways_from_keyfile (GeoclueLocalnet  *localnet,
                                              GKeyFile         *keyfile)
 {
 	char **groups;
 	char **g;
 	GError *error = NULL;
-	
+
 	groups = g_key_file_get_groups (keyfile, NULL);
 	g = groups;
 	while (*g) {
@@ -194,36 +275,36 @@
 		char **keys;
 		char **k;
 		Gateway *gateway = g_new0 (Gateway, 1);
-		
+
 		gateway->mac = g_ascii_strdown (*g, -1);
 		gateway->address = geoclue_address_details_new ();
-		
+
 		/* read all keys in the group as address fields */
 		keys = g_key_file_get_keys (keyfile, *g,
 		                            NULL, &error);
 		if (error) {
-			g_warning ("Could not load keys for group [%s] from %s: %s", 
+			g_warning ("Could not load keys for group [%s] from %s: %s",
 			           *g, localnet->keyfile_name, error->message);
 			g_error_free (error);
 			error = NULL;
 		}
-		
+
 		k = keys;
 		while (*k) {
 			char *value;
-			
+
 			value = g_key_file_get_string (keyfile, *g, *k, NULL);
-			g_hash_table_insert (gateway->address, 
+			g_hash_table_insert (gateway->address,
 			                     *k, value);
 			k++;
 		}
 		g_free (keys);
-		
+
 		level = geoclue_address_details_get_accuracy_level (gateway->address);
 		gateway->accuracy = geoclue_accuracy_new (level, 0, 0);
-		
+
 		localnet->gateways = g_slist_prepend (localnet->gateways, gateway);
-		
+
 		g++;
 	}
 	g_strfreev (groups);
@@ -233,19 +314,19 @@
 geoclue_localnet_find_gateway (GeoclueLocalnet *localnet, char *mac)
 {
 	GSList *l;
-	
+
 	l = localnet->gateways;
 	/* eww, should be using a hashtable or something here */
 	while (l) {
 		Gateway *gw = l->data;
-		
-		if (g_ascii_strcasecmp (gw->mac, mac) == 0) {
+
+		if (strcmp (gw->mac, mac) == 0) {
 			return gw;
 		}
-		
+
 		l = l->next;
 	}
-	
+
 	return NULL;
 }
 
@@ -255,31 +336,31 @@
 	const char *dir;
 	GKeyFile *keyfile;
 	GError *error = NULL;
-	
+
 	gc_provider_set_details (GC_PROVIDER (localnet),
 	                         "org.freedesktop.Geoclue.Providers.Localnet",
 	                         "/org/freedesktop/Geoclue/Providers/Localnet",
 	                         "Localnet", "provides Address based on current gateway mac address and a local address file (which can be updated through D-Bus)");
-	
-	
+
+
 	localnet->gateways = NULL;
-	
+
 	/* load known addresses from keyfile */
 	dir = g_get_user_config_dir ();
 	g_mkdir_with_parents (dir, 0755);
 	localnet->keyfile_name = g_build_filename (dir, KEYFILE_NAME, NULL);
-	
+
 	keyfile = g_key_file_new ();
-	if (!g_key_file_load_from_file (keyfile, localnet->keyfile_name, 
+	if (!g_key_file_load_from_file (keyfile, localnet->keyfile_name,
 	                                G_KEY_FILE_NONE, &error)) {
-		g_warning ("Could not load keyfile %s: %s", 
+		g_warning ("Could not load keyfile %s: %s",
 		           localnet->keyfile_name, error->message);
 		g_error_free (error);
 	}
 	geoclue_localnet_load_gateways_from_keyfile (localnet, keyfile);
 	g_key_file_free (keyfile);
 
-	localnet->conn = geoclue_connectivity_new ();
+
 }
 
 typedef struct {
@@ -288,7 +369,7 @@
 } localnet_keyfile_group;
 
 static void
-add_address_detail_to_keyfile (char *key, char *value, 
+add_address_detail_to_keyfile (char *key, char *value,
                                localnet_keyfile_group *group)
 {
 	g_key_file_set_string (group->keyfile, group->group_name,
@@ -300,18 +381,20 @@
                               GHashTable *details,
                               GError **error)
 {
-	char *str, *mac;
+	char *str, *mac = NULL;
 	GKeyFile *keyfile;
 	GError *int_err = NULL;
 	localnet_keyfile_group *keyfile_group;
 	Gateway *gw;
-	
+
 	if (!details) {
 		/* TODO set error */
 		return FALSE;
 	}
 
-	mac = geoclue_connectivity_get_router_mac (localnet->conn);
+	if (get_mac_address (&mac) < 0)
+		return FALSE;
+
 	if (!mac) {
 		g_warning ("Couldn't get current gateway mac address");
 		/* TODO set error */
@@ -319,23 +402,23 @@
 	}
 	/* reload keyfile just in case it's changed */
 	keyfile = g_key_file_new ();
-	if (!g_key_file_load_from_file (keyfile, localnet->keyfile_name, 
+	if (!g_key_file_load_from_file (keyfile, localnet->keyfile_name,
 	                                G_KEY_FILE_NONE, &int_err)) {
-		g_warning ("Could not load keyfile %s: %s", 
+		g_warning ("Could not load keyfile %s: %s",
 		         localnet->keyfile_name, int_err->message);
 		g_error_free (int_err);
 		int_err = NULL;
 	}
-	
+
 	/* remove old group (if exists) and add new to GKeyFile */
 	g_key_file_remove_group (keyfile, mac, NULL);
-	
+
 	keyfile_group = g_new0 (localnet_keyfile_group, 1);
 	keyfile_group->keyfile = keyfile;
 	keyfile_group->group_name = mac;
 	g_hash_table_foreach (details, (GHFunc) add_address_detail_to_keyfile, keyfile_group);
 	g_free (keyfile_group);
-	
+
 	/* save keyfile*/
 	str = g_key_file_to_data (keyfile, NULL, &int_err);
 	if (int_err) {
@@ -346,7 +429,7 @@
 		/* TODO set error */
 		return FALSE;
 	}
-	
+
 	g_file_set_contents (localnet->keyfile_name, str, -1, &int_err);
 	g_free (str);
 	if (int_err) {
@@ -357,16 +440,16 @@
 		/* TODO set error */
 		return FALSE;
 	}
-	
+
 	/* re-parse keyfile */
 	free_gateway_list (localnet->gateways);
 	localnet->gateways = NULL;
 	geoclue_localnet_load_gateways_from_keyfile (localnet, keyfile);
 	g_key_file_free (keyfile);
-	
+
 	gw = geoclue_localnet_find_gateway (localnet, mac);
 	g_free (mac);
-	
+
 	if (gw) {
 		gc_iface_address_emit_address_changed (GC_IFACE_ADDRESS (localnet),
 		                                       time (NULL), gw->address, gw->accuracy);
@@ -389,11 +472,11 @@
 {
 	GHashTable *address;
 	gboolean ret;
-	
+
 	address = geoclue_address_details_new ();
 	if (country_code && (strlen (country_code) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRYCODE), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRYCODE),
 		                     g_strdup (country_code));
 		if (!country) {
 			geoclue_address_details_set_country_from_code (address);
@@ -401,35 +484,35 @@
 	}
 	if (country && (strlen (country) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRY), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRY),
 		                     g_strdup (country));
 	}
 	if (region && (strlen (region) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_REGION), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_REGION),
 		                     g_strdup (region));
 	}
 	if (locality && (strlen (locality) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_LOCALITY), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_LOCALITY),
 		                     g_strdup (locality));
 	}
 	if (area && (strlen (area) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_AREA), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_AREA),
 		                     g_strdup (area));
 	}
 	if (postalcode && (strlen (postalcode) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_POSTALCODE), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_POSTALCODE),
 		                     g_strdup (postalcode));
 	}
 	if (street && (strlen (street) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_STREET), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_STREET),
 		                     g_strdup (street));
 	}
-	
+
 	ret = geoclue_localnet_set_address (localnet,
 	                                    address,
 	                                    error);
@@ -445,27 +528,35 @@
              GError          **error)
 {
 	GeoclueLocalnet *localnet;
-	char *mac;
+	int i, ret_val;
+	char *mac = NULL;
 	Gateway *gw;
-	
+
 	localnet = GEOCLUE_LOCALNET (gc);
 
-	/* we may be trying to read /proc/net/arp right after network connection. 
+	/* we may be trying to read /proc/net/arp right after network connection.
 	 * It's sometimes not up yet, try a couple of times */
-	mac = geoclue_connectivity_get_router_mac (localnet->conn);
+	for (i = 0; i < 5; i++) {
+		ret_val = get_mac_address (&mac);
+		if (ret_val < 0)
+			return FALSE;
+		else if (ret_val == 1)
+			break;
+		usleep (200);
+	}
 
 	if (!mac) {
 		g_warning ("Couldn't get current gateway mac address");
 		if (error) {
-			g_set_error (error, GEOCLUE_ERROR, 
+			g_set_error (error, GEOCLUE_ERROR,
 			             GEOCLUE_ERROR_NOT_AVAILABLE, "Could not get current gateway mac address");
 		}
 		return FALSE;
 	}
-	
+
 	gw = geoclue_localnet_find_gateway (localnet, mac);
 	g_free (mac);
-	
+
 	if (timestamp) {
 		*timestamp = time(NULL);
 	}
@@ -497,16 +588,16 @@
       char **argv)
 {
 	GeoclueLocalnet *localnet;
-	
+
 	g_type_init ();
-	
+
 	localnet = g_object_new (GEOCLUE_TYPE_LOCALNET, NULL);
 	localnet->loop = g_main_loop_new (NULL, TRUE);
-	
+
 	g_main_loop_run (localnet->loop);
-	
+
 	g_main_loop_unref (localnet->loop);
 	g_object_unref (localnet);
-	
+
 	return 0;
 }
Index: geoclue/providers/manual/Makefile.am
===================================================================
--- geoclue.orig/providers/manual/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/manual/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -10,7 +10,7 @@
 	$(nodist_geoclue_manual_SOURCES)
 
 geoclue_manual_SOURCES = 	\
-	geoclue-manual.c     
+	geoclue-manual.c
 
 geoclue_manual_CFLAGS = \
 	-I$(top_srcdir)     \
@@ -30,7 +30,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 CLEANFILES = \
 	stamp-geoclue-manual-glue.h
@@ -48,7 +48,7 @@
 	@true
 
 stamp-geoclue-manual-glue.h: geoclue-manual.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=geoclue_manual --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=geoclue_manual --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F) \
 	&& echo timestamp > $(@F)
Index: geoclue/providers/manual/geoclue-manual.c
===================================================================
--- geoclue.orig/providers/manual/geoclue-manual.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/manual/geoclue-manual.c	2011-12-29 16:40:38.926428900 +0900
@@ -23,17 +23,17 @@
  */
 
 /** Geoclue manual provider
- *  
- * This is an address provider which gets its address data from user 
- * input. No UI is included, any application may query the address from 
+ *
+ * This is an address provider which gets its address data from user
+ * input. No UI is included, any application may query the address from
  * the user and submit it to manual provider through the D-Bus API:
  *    org.freedesktop.Geoclue.Manual.SetAddress
  *    org.freedesktop.Geoclue.Manual.SetAddressFields
- * 
- * SetAddress allows setting the current address as a GeoclueAddress, 
- * while SetAddressFields is a convenience version with separate 
+ *
+ * SetAddress allows setting the current address as a GeoclueAddress,
+ * while SetAddressFields is a convenience version with separate
  * address fields. Shell example using SetAddressFields:
- * 
+ *
  * dbus-send --print-reply --type=method_call \
  *           --dest=org.freedesktop.Geoclue.Providers.Manual \
  *           /org/freedesktop/Geoclue/Providers/Manual \
@@ -46,10 +46,10 @@
  *           string: \
  *           string: \
  *           string:"Solnantie 24"
- * 
- * This would make the provider emit a AddressChanged signal with 
- * accuracy level GEOCLUE_ACCURACY_STREET. Unless new SetAddress* calls 
- * are made, provider will emit another signal in two hours (7200 sec), 
+ *
+ * This would make the provider emit a AddressChanged signal with
+ * accuracy level GEOCLUE_ACCURACY_STREET. Unless new SetAddress* calls
+ * are made, provider will emit another signal in two hours (7200 sec),
  * with empty address and GEOCLUE_ACCURACY_NONE.
  **/
 
@@ -63,11 +63,11 @@
 
 typedef struct {
 	GcProvider parent;
-	
+
 	GMainLoop *loop;
-	
+
 	guint event_id;
-	
+
 	int timestamp;
 	GHashTable *address;
 	GeoclueAccuracy *accuracy;
@@ -130,15 +130,7 @@
 	    GeoclueStatus  *status,
 	    GError        **error)
 {
-	GeoclueAccuracyLevel level;
-  
-	geoclue_accuracy_get_details (GEOCLUE_MANUAL (gc)->accuracy,
-	                              &level, NULL, NULL);
-	if (level == GEOCLUE_ACCURACY_LEVEL_NONE) {
-		*status = GEOCLUE_STATUS_UNAVAILABLE;
-	} else {
-		*status = GEOCLUE_STATUS_AVAILABLE;
-	}
+	*status = GEOCLUE_STATUS_AVAILABLE;
 	return TRUE;
 }
 
@@ -146,19 +138,19 @@
 shutdown (GcProvider *provider)
 {
 	GeoclueManual *manual;
-	
+
 	manual = GEOCLUE_MANUAL (provider);
 	g_main_loop_quit (manual->loop);
 }
 
-gboolean 
+gboolean
 validity_ended (GeoclueManual *manual)
 {
 	manual->event_id = 0;
 	g_hash_table_remove_all (manual->address);
 	geoclue_accuracy_set_details (manual->accuracy,
 	                              GEOCLUE_ACCURACY_LEVEL_NONE, 0, 0);
-	
+
 	gc_iface_address_emit_address_changed (GC_IFACE_ADDRESS (manual),
 	                                       manual->timestamp,
 	                                       manual->address,
@@ -175,24 +167,24 @@
 	if (manual->event_id > 0) {
 		g_source_remove (manual->event_id);
 	}
-	
+
 	manual->timestamp = time (NULL);
-	
+
 	g_hash_table_destroy (manual->address);
 	manual->address = address;
-	
+
 	geoclue_accuracy_set_details (manual->accuracy,
 	                              get_accuracy_for_address (address),
 	                              0, 0);
-	
+
 	gc_iface_address_emit_address_changed (GC_IFACE_ADDRESS (manual),
 	                                       manual->timestamp,
 	                                       manual->address,
 	                                       manual->accuracy);
-	
+
 	if (valid_for > 0) {
-		manual->event_id = g_timeout_add (valid_for * 1000, 
-		                                  (GSourceFunc)validity_ended, 
+		manual->event_id = g_timeout_add (valid_for * 1000,
+		                                  (GSourceFunc)validity_ended,
 		                                  manual);
 	}
 }
@@ -222,44 +214,44 @@
                                    GError **error)
 {
 	GHashTable *address;
-	
+
 	address = geoclue_address_details_new ();
 	if (country_code && (strlen (country_code) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRYCODE), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRYCODE),
 		                     g_strdup (country_code));
 	}
 	if (country && (strlen (country) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRY), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_COUNTRY),
 		                     g_strdup (country));
 	}
 	if (region && (strlen (region) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_REGION), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_REGION),
 		                     g_strdup (region));
 	}
 	if (locality && (strlen (locality) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_LOCALITY), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_LOCALITY),
 		                     g_strdup (locality));
 	}
 	if (area && (strlen (area) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_AREA), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_AREA),
 		                     g_strdup (area));
 	}
 	if (postalcode && (strlen (postalcode) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_POSTALCODE), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_POSTALCODE),
 		                     g_strdup (postalcode));
 	}
 	if (street && (strlen (street) > 0)) {
 		g_hash_table_insert (address,
-		                     g_strdup (GEOCLUE_ADDRESS_KEY_STREET), 
+		                     g_strdup (GEOCLUE_ADDRESS_KEY_STREET),
 		                     g_strdup (street));
 	}
-	
+
 	geoclue_manual_set_address_common (manual,
 	                                   valid_for,
 	                                   address);
@@ -271,12 +263,12 @@
 finalize (GObject *object)
 {
 	GeoclueManual *manual;
-	
+
 	manual = GEOCLUE_MANUAL (object);
-	
+
 	g_hash_table_destroy (manual->address);
 	geoclue_accuracy_free (manual->accuracy);
-	
+
 	((GObjectClass *) geoclue_manual_parent_class)->finalize (object);
 }
 
@@ -285,12 +277,12 @@
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
 	GcProviderClass *p_class = (GcProviderClass *) klass;
-	
+
 	o_class->finalize = finalize;
-	
+
 	p_class->get_status = get_status;
 	p_class->shutdown = shutdown;
-	
+
 	dbus_g_object_type_install_info (geoclue_manual_get_type (),
 	                                 &dbus_glib_geoclue_manual_object_info);
 }
@@ -302,9 +294,9 @@
 	                         "org.freedesktop.Geoclue.Providers.Manual",
 	                         "/org/freedesktop/Geoclue/Providers/Manual",
 	                         "Manual", "Manual provider");
-	
+
 	manual->address = geoclue_address_details_new ();
-	manual->accuracy = 
+	manual->accuracy =
 		geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0, 0);
 }
 
@@ -316,15 +308,7 @@
              GError          **error)
 {
 	GeoclueManual *manual = GEOCLUE_MANUAL (gc);
-	GeoclueAccuracyLevel level;
-  
-	geoclue_accuracy_get_details (manual->accuracy, &level, NULL, NULL);
-	if (level == GEOCLUE_ACCURACY_LEVEL_NONE) {
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
-		             "No manual address set");
-		return FALSE;
-	}
+
 
 	if (timestamp) {
 		*timestamp = manual->timestamp;
@@ -335,7 +319,7 @@
 	if (accuracy) {
 		*accuracy = geoclue_accuracy_copy (manual->accuracy);
 	}
-	
+
 	return TRUE;
 }
 
@@ -350,16 +334,16 @@
       char **argv)
 {
 	GeoclueManual *manual;
-	
+
 	g_type_init ();
-	
+
 	manual = g_object_new (GEOCLUE_TYPE_MANUAL, NULL);
 	manual->loop = g_main_loop_new (NULL, TRUE);
-	
+
 	g_main_loop_run (manual->loop);
-	
+
 	g_main_loop_unref (manual->loop);
 	g_object_unref (manual);
-	
+
 	return 0;
 }
Index: geoclue/providers/nominatim/Makefile.am
===================================================================
--- geoclue.orig/providers/nominatim/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/nominatim/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -15,7 +15,7 @@
 
 geoclue_nominatim_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-nominatim.provider
@@ -25,7 +25,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/plazes/Makefile.am
===================================================================
--- geoclue.orig/providers/plazes/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/plazes/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -7,13 +7,11 @@
 geoclue_plazes_CFLAGS = \
 	-I$(top_srcdir) \
 	-I$(top_builddir) \
-	-I$(top_srcdir)/src \
 	$(GEOCLUE_CFLAGS)
 
 geoclue_plazes_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/src/libconnectivity.la \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-plazes.provider
@@ -23,7 +21,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/plazes/geoclue-plazes.c
===================================================================
--- geoclue.orig/providers/plazes/geoclue-plazes.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/plazes/geoclue-plazes.c	2011-12-29 16:40:38.926428900 +0900
@@ -1,7 +1,7 @@
 /*
  * Geoclue
  * geoclue-plazes.c - A plazes.com-based Address/Position provider
- * 
+ *
  * Author: Jussi Kukkonen <jku@o-hand.com>
  * Copyright 2008 by Garmin Ltd. or its subsidiaries
  *
@@ -38,8 +38,6 @@
 #include <geoclue/gc-iface-position.h>
 #include <geoclue/gc-iface-address.h>
 
-#include "connectivity.h"
-
 #define GEOCLUE_DBUS_SERVICE_PLAZES "org.freedesktop.Geoclue.Providers.Plazes"
 #define GEOCLUE_DBUS_PATH_PLAZES "/org/freedesktop/Geoclue/Providers/Plazes"
 #define PLAZES_URL "http://plazes.com/suggestions.xml"
@@ -53,7 +51,6 @@
 typedef struct _GeocluePlazes {
 	GcProvider parent;
 	GMainLoop *loop;
-	GeoclueConnectivity *conn;
 	GcWebService *web_service;
 	GeoclueStatus last_status;
 } GeocluePlazes;
@@ -102,19 +99,98 @@
     }
 }
 
-static char *
-mac_strdown (char *mac)
+/* Parse /proc/net/route to get default gateway address and then parse
+ * /proc/net/arp to find matching mac address.
+ *
+ * There are some problems with this. First, it's IPv4 only.
+ * Second, there must be a way to do this with ioctl, but that seemed really
+ * complicated... even /usr/sbin/arp parses /proc/net/arp
+ *
+ * returns:
+ *   1 : on success
+ *   0 : no success, no errors
+ *  <0 : error
+ */
+int
+get_mac_address (char **mac)
 {
-	guint i;
-	for (i = 0; mac[i] != '\0' ; i++) {
-		if (g_ascii_isalpha (mac[i]))
-			mac[i] = g_ascii_tolower (mac[i]);
+	char *content;
+	char **lines, **entry;
+	GError *error = NULL;
+	char *route_gateway = NULL;
+
+	g_assert (*mac == NULL);
+
+	if (!g_file_get_contents ("/proc/net/route", &content, NULL, &error)) {
+		g_warning ("Failed to read /proc/net/route: %s", error->message);
+		g_error_free (error);
+		return -1;
+	}
+
+	lines = g_strsplit (content, "\n", 0);
+	g_free (content);
+	entry = lines + 1;
+
+	while (*entry && strlen (*entry) > 0) {
+		char dest[9];
+		char gateway[9];
+		if (sscanf (*entry,
+			        "%*s %8[0-9A-Fa-f] %8[0-9A-Fa-f] %*s",
+			        dest, gateway) != 2) {
+			g_warning ("Failed to parse /proc/net/route entry '%s'", *entry);
+		} else if (strcmp (dest, "00000000") == 0) {
+			route_gateway = g_strdup (gateway);
+			break;
+		}
+		entry++;
 	}
-	return mac;
+	g_strfreev (lines);
+
+	if (!route_gateway) {
+		g_warning ("Failed to find default route in /proc/net/route");
+		return -1;
+	}
+
+	if (!g_file_get_contents ("/proc/net/arp", &content, NULL, &error)) {
+		g_warning ("Failed to read /proc/net/arp: %s", error->message);
+		g_error_free (error);
+		return -1;
+	}
+
+	lines = g_strsplit (content, "\n", 0);
+	g_free (content);
+	entry = lines+1;
+	while (*entry && strlen (*entry) > 0) {
+		char hwa[100];
+		char *arp_gateway;
+		int ip[4];
+
+		if (sscanf(*entry,
+		           "%d.%d.%d.%d 0x%*x 0x%*x %100s %*s %*s\n",
+		           &ip[0], &ip[1], &ip[2], &ip[3], hwa) != 5) {
+			g_warning ("Failed to parse /proc/net/arp entry '%s'", *entry);
+		} else {
+			arp_gateway = g_strdup_printf ("%02X%02X%02X%02X", ip[3], ip[2], ip[1], ip[0]);
+			if (strcmp (arp_gateway, route_gateway) == 0) {
+				g_free (arp_gateway);
+				*mac = g_strdup (hwa);
+				break;
+			}
+			g_free (arp_gateway);
+
+		}
+		entry++;
+	}
+	g_free (route_gateway);
+	g_strfreev (lines);
+
+	return *mac ? 1 : 0;
 }
+
+
 /* Position interface implementation */
 
-static gboolean 
+static gboolean
 geoclue_plazes_get_position (GcIfacePosition        *iface,
                              GeocluePositionFields  *fields,
                              int                    *timestamp,
@@ -125,34 +201,41 @@
                              GError                **error)
 {
 	GeocluePlazes *plazes;
-	char *mac, *mac_lc;
-	
+	int i, ret_val;
+	char *mac = NULL;
+
 	plazes = (GEOCLUE_PLAZES (iface));
-	
+
 	*fields = GEOCLUE_POSITION_FIELDS_NONE;
 	if (timestamp) {
 		*timestamp = time (NULL);
 	}
 
-	mac = geoclue_connectivity_get_router_mac (plazes->conn);
+	/* we may be trying to read /proc/net/arp right after network connection.
+	 * It's sometimes not up yet, try a couple of times */
+	for (i = 0; i < 5; i++) {
+		ret_val = get_mac_address (&mac);
+		if (ret_val < 0)
+			return FALSE;
+		else if (ret_val == 1)
+			break;
+		usleep (200);
+	}
+
 	if (mac == NULL) {
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
+		g_set_error (error, GEOCLUE_ERROR,
+		             GEOCLUE_ERROR_NOT_AVAILABLE,
 		             "Router mac address query failed");
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ERROR);
 		return FALSE;
 	}
 
-	mac = mac_strdown (mac);
-
-	geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ACQUIRING);
+    geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ACQUIRING);
 
-	mac_lc = g_ascii_strdown (mac, -1);
-	g_free (mac);
 	if (!gc_web_service_query (plazes->web_service, error,
 	                           PLAZES_KEY_MAC, mac,
 	                           (char *)0)) {
-		g_free (mac_lc);
+		g_free (mac);
         // did not get a reply; we can try again later
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_AVAILABLE);
 		g_set_error (error, GEOCLUE_ERROR,
@@ -161,36 +244,34 @@
 		return FALSE;
 	}
 
-	g_free (mac);
-
-	if (latitude && gc_web_service_get_double (plazes->web_service, 
+	if (latitude && gc_web_service_get_double (plazes->web_service,
 	                                           latitude, PLAZES_LAT_XPATH)) {
 		*fields |= GEOCLUE_POSITION_FIELDS_LATITUDE;
 	}
-	if (longitude && gc_web_service_get_double (plazes->web_service, 
+	if (longitude && gc_web_service_get_double (plazes->web_service,
 	                                            longitude, PLAZES_LON_XPATH)) {
 		*fields |= GEOCLUE_POSITION_FIELDS_LONGITUDE;
 	}
-	
+
 	if (accuracy) {
-        /* Educated guess. Plazes are typically hand pointed on 
-         * a map, or geocoded from address, so should be fairly 
+        /* Educated guess. Plazes are typically hand pointed on
+         * a map, or geocoded from address, so should be fairly
          * accurate */
         *accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_STREET, 0, 0);
 	}
-	
+
     if (!(*fields & GEOCLUE_POSITION_FIELDS_LATITUDE &&
          *fields & GEOCLUE_POSITION_FIELDS_LONGITUDE)) {
 
         // we got a reply, but could not exploit it. It would probably be the
         // same next time.
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ERROR);
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
+		g_set_error (error, GEOCLUE_ERROR,
+		             GEOCLUE_ERROR_NOT_AVAILABLE,
 		             "Could not understand reply from server");
 		return FALSE;
     }
-	
+
 	geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_AVAILABLE);
 
 	return TRUE;
@@ -198,55 +279,62 @@
 
 /* Address interface implementation */
 
-static gboolean 
+static gboolean
 geoclue_plazes_get_address (GcIfaceAddress   *iface,
                             int              *timestamp,
                             GHashTable      **address,
                             GeoclueAccuracy **accuracy,
                             GError          **error)
 {
-	
+
 	GeocluePlazes *plazes = GEOCLUE_PLAZES (iface);
-	char *mac, *mac_lc;
+	int i, ret_val;
+	char *mac = NULL;
 
 	GeoclueAccuracyLevel level = GEOCLUE_ACCURACY_LEVEL_NONE;
-	
+
 	if (timestamp) {
 		*timestamp = time (NULL);
 	}
 
-	mac = geoclue_connectivity_get_router_mac (plazes->conn);
+	/* we may be trying to read /proc/net/arp right after network connection.
+	 * It's sometimes not up yet, try a couple of times */
+	for (i = 0; i < 5; i++) {
+		ret_val = get_mac_address (&mac);
+		if (ret_val < 0)
+			return FALSE;
+		else if (ret_val == 1)
+			break;
+		usleep (200);
+	}
 
 	if (mac == NULL) {
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
+		g_set_error (error, GEOCLUE_ERROR,
+		             GEOCLUE_ERROR_NOT_AVAILABLE,
 		             "Router mac address query failed");
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ERROR);
 		return FALSE;
 	}
-	
+
     geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ACQUIRING);
 
-	mac_lc = g_ascii_strdown (mac, -1);
-	g_free (mac);
 	if (!gc_web_service_query (plazes->web_service, error,
-	                           PLAZES_KEY_MAC, mac_lc, 
+	                           PLAZES_KEY_MAC, mac,
 	                           (char *)0)) {
-		g_free (mac_lc);
+		g_free (mac);
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_AVAILABLE);
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
+		g_set_error (error, GEOCLUE_ERROR,
+		             GEOCLUE_ERROR_NOT_AVAILABLE,
 		             "Did not get reply from server");
 		return FALSE;
 	}
-	g_free (mac_lc);
 
 	if (address) {
 		char *str;
-		
+
 		*address = geoclue_address_details_new ();
-		
-		if (gc_web_service_get_string (plazes->web_service, 
+
+		if (gc_web_service_get_string (plazes->web_service,
 		                               &str, "//plaze/country")) {
 			geoclue_address_details_insert (*address,
 			                                GEOCLUE_ADDRESS_KEY_COUNTRY,
@@ -254,7 +342,7 @@
 			g_free (str);
 			level = GEOCLUE_ACCURACY_LEVEL_COUNTRY;
 		}
-		if (gc_web_service_get_string (plazes->web_service, 
+		if (gc_web_service_get_string (plazes->web_service,
 		                               &str, "//plaze/country_code")) {
 			geoclue_address_details_insert (*address,
 			                                GEOCLUE_ADDRESS_KEY_COUNTRYCODE,
@@ -262,7 +350,7 @@
 			g_free (str);
 			level = GEOCLUE_ACCURACY_LEVEL_COUNTRY;
 		}
-		if (gc_web_service_get_string (plazes->web_service, 
+		if (gc_web_service_get_string (plazes->web_service,
 		                               &str, "//plaze/city")) {
 			geoclue_address_details_insert (*address,
 			                                GEOCLUE_ADDRESS_KEY_LOCALITY,
@@ -270,7 +358,7 @@
 			g_free (str);
 			level = GEOCLUE_ACCURACY_LEVEL_LOCALITY;
 		}
-		if (gc_web_service_get_string (plazes->web_service, 
+		if (gc_web_service_get_string (plazes->web_service,
 		                               &str, "//plaze/zip_code")) {
 			geoclue_address_details_insert (*address,
 			                                GEOCLUE_ADDRESS_KEY_POSTALCODE,
@@ -278,7 +366,7 @@
 			g_free (str);
 			level = GEOCLUE_ACCURACY_LEVEL_POSTALCODE;
 		}
-		if (gc_web_service_get_string (plazes->web_service, 
+		if (gc_web_service_get_string (plazes->web_service,
 		                               &str, "//plaze/address")) {
 			geoclue_address_details_insert (*address,
 			                                GEOCLUE_ADDRESS_KEY_STREET,
@@ -292,8 +380,8 @@
         // we got a reply, but could not exploit it. It would probably be the
         // same next time.
 		geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_ERROR);
-		g_set_error (error, GEOCLUE_ERROR, 
-		             GEOCLUE_ERROR_NOT_AVAILABLE, 
+		g_set_error (error, GEOCLUE_ERROR,
+		             GEOCLUE_ERROR_NOT_AVAILABLE,
 		             "Could not understand reply from server");
 		return FALSE;
     }
@@ -301,7 +389,7 @@
 	if (accuracy) {
 		*accuracy = geoclue_accuracy_new (level, 0, 0);
 	}
-	
+
 	return TRUE;
 }
 
@@ -310,12 +398,8 @@
 {
 	GeocluePlazes *plazes = GEOCLUE_PLAZES (obj);
 
-	if (plazes->conn != NULL) {
-		g_object_unref (plazes->conn);
-		plazes->conn = NULL;
-	}
 	g_object_unref (plazes->web_service);
-	
+
 	((GObjectClass *) geoclue_plazes_parent_class)->finalize (obj);
 }
 
@@ -327,22 +411,21 @@
 {
 	GcProviderClass *p_class = (GcProviderClass *)klass;
 	GObjectClass *o_class = (GObjectClass *)klass;
-	
+
 	p_class->shutdown = shutdown;
 	p_class->get_status = geoclue_plazes_get_status;
-	
+
 	o_class->finalize = geoclue_plazes_finalize;
 }
 
 static void
 geoclue_plazes_init (GeocluePlazes *plazes)
 {
-	gc_provider_set_details (GC_PROVIDER (plazes), 
+	gc_provider_set_details (GC_PROVIDER (plazes),
 	                         GEOCLUE_DBUS_SERVICE_PLAZES,
 	                         GEOCLUE_DBUS_PATH_PLAZES,
 	                         "Plazes", "Plazes.com based provider, uses gateway mac address to locate");
 
-	plazes->conn = geoclue_connectivity_new ();
 	plazes->web_service = g_object_new (GC_TYPE_WEB_SERVICE, NULL);
 	gc_web_service_set_base_url (plazes->web_service, PLAZES_URL);
     geoclue_plazes_set_status (plazes, GEOCLUE_STATUS_AVAILABLE);
@@ -360,18 +443,18 @@
 	iface->get_address = geoclue_plazes_get_address;
 }
 
-int 
+int
 main()
 {
 	g_type_init();
-	
+
 	GeocluePlazes *o = g_object_new (GEOCLUE_TYPE_PLAZES, NULL);
 	o->loop = g_main_loop_new (NULL, TRUE);
-	
+
 	g_main_loop_run (o->loop);
-	
+
 	g_main_loop_unref (o->loop);
 	g_object_unref (o);
-	
+
 	return 0;
 }
Index: geoclue/providers/skyhook/Makefile.am
===================================================================
--- geoclue.orig/providers/skyhook/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/skyhook/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -7,14 +7,12 @@
 geoclue_skyhook_CFLAGS = \
 	-I$(top_srcdir) \
 	-I$(top_builddir) \
-	-I$(top_srcdir)/src \
 	$(GEOCLUE_CFLAGS) \
 	$(SKYHOOK_CFLAGS)
 
 geoclue_skyhook_LDADD = \
 	$(GEOCLUE_LIBS) \
 	$(SKYHOOK_LIBS) \
-	$(top_builddir)/src/libconnectivity.la \
 	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
@@ -25,7 +23,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/providers/skyhook/geoclue-skyhook.c
===================================================================
--- geoclue.orig/providers/skyhook/geoclue-skyhook.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/skyhook/geoclue-skyhook.c	2011-12-29 16:40:38.926428900 +0900
@@ -1,7 +1,7 @@
 /*
  * Geoclue
  * geoclue-skyhook.c - A skyhook.com-based Address/Position provider
- * 
+ *
  * Author: Bastien Nocera <hadess@hadess.net>
  * Copyright 2009 Bastien Nocera
  */
@@ -22,8 +22,6 @@
 #include <geoclue/geoclue-error.h>
 #include <geoclue/gc-iface-position.h>
 
-#include "connectivity.h"
-
 #define GEOCLUE_DBUS_SERVICE_SKYHOOK "org.freedesktop.Geoclue.Providers.Skyhook"
 #define GEOCLUE_DBUS_PATH_SKYHOOK "/org/freedesktop/Geoclue/Providers/Skyhook"
 #define SKYHOOK_URL "https://api.skyhookwireless.com/wps2/location"
@@ -34,15 +32,12 @@
 #define GEOCLUE_TYPE_SKYHOOK (geoclue_skyhook_get_type ())
 #define GEOCLUE_SKYHOOK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOCLUE_TYPE_SKYHOOK, GeoclueSkyhook))
 
-#define QUERY_START "<?xml version=\'1.0\'?><LocationRQ xmlns=\'http://skyhookwireless.com/wps/2005\' version=\'2.6\' street-address-lookup=\'full\'><authentication version=\'2.0\'><simple><username>beta</username><realm>js.loki.com</realm></simple></authentication>"
-#define QUERY_AP "<access-point><mac>%s</mac><signal-strength>%d</signal-strength></access-point>"
-#define QUERY_END "</LocationRQ>"
+#define QUERY "<?xml version=\'1.0\'?><LocationRQ xmlns=\'http://skyhookwireless.com/wps/2005\' version=\'2.6\' street-address-lookup=\'full\'><authentication version=\'2.0\'><simple><username>beta</username><realm>js.loki.com</realm></simple></authentication><access-point><mac>%s</mac><signal-strength>-50</signal-strength></access-point></LocationRQ>"
 
 typedef struct _GeoclueSkyhook {
 	GcProvider parent;
 	GMainLoop *loop;
 	SoupSession *session;
-	GeoclueConnectivity *conn;
 } GeoclueSkyhook;
 
 typedef struct _GeoclueSkyhookClass {
@@ -77,38 +72,66 @@
 	g_main_loop_quit (skyhook->loop);
 }
 
-static void
-add_ap (gpointer key,
-	gpointer value,
-	gpointer data)
-{
-	char *mac;
-	char **split;
+#define MAC_LEN 18
 
-	/* Remove the ":" */
-	split = g_strsplit (key, ":", -1);
-	mac = g_strjoinv ("", split);
-	g_strfreev (split);
+static char *
+get_mac_address (void)
+	{
+	/* this is an ugly hack, but it seems there is no easy
+	 * ioctl-based way to get the mac address of the router. This
+	 * implementation expects the system to have netstat, grep and awk
+	 * */
+
+	FILE *in;
+	char mac[MAC_LEN];
+	int i;
+
+	/*for some reason netstat or /proc/net/arp isn't always ready
+	 * when a connection is already up... Try a couple of times */
+	for (i=0; i<10; i++) {
+		if (!(in = popen ("ROUTER_IP=`netstat -rn | grep '^0.0.0.0 ' | awk '{ print $2 }'` && grep \"^$ROUTER_IP \" /proc/net/arp | awk '{print $4}'", "r"))) {
+			g_warning ("popen failed");
+			return NULL;
+		}
 
-	g_string_append_printf (data, QUERY_AP, mac, GPOINTER_TO_INT (value));
-	g_free (mac);
+		if (!(fgets (mac, MAC_LEN, in))) {
+			if (errno != ENOENT && errno != EAGAIN) {
+				g_debug ("error %d", errno);
+				return NULL;
+			}
+			/* try again */
+			pclose (in);
+			g_debug ("trying again...");
+			g_usleep (200);
+			continue;
+		}
+		pclose (in);
+		return g_strdup (mac);
+	}
+	return NULL;
 }
 
 static char *
-create_post_query (GeoclueConnectivity *conn)
+create_post_query (void)
 {
-	GHashTable *ht;
-	GString *str;
+	char *mac, *query;
+	char **split;
 
-	ht = geoclue_connectivity_get_aps (conn);
-	if (ht == NULL)
+	mac = get_mac_address ();
+	if (mac == NULL)
+		return NULL;
+	/* Remove the ":" */
+	split = g_strsplit (mac, ":", -1);
+	g_free (mac);
+	if (split == NULL)
 		return NULL;
-	str = g_string_new (QUERY_START);
-	g_hash_table_foreach (ht, add_ap, str);
-	g_string_append (str, QUERY_END);
-	g_hash_table_destroy (ht);
+	mac = g_strjoinv ("", split);
+	g_strfreev (split);
+
+	query = g_strdup_printf (QUERY, mac);
+	g_free (mac);
 
-	return g_string_free (str, FALSE);
+	return query;
 }
 
 static gboolean
@@ -157,7 +180,7 @@
 
 /* Position interface implementation */
 
-static gboolean 
+static gboolean
 geoclue_skyhook_get_position (GcIfacePosition        *iface,
                              GeocluePositionFields  *fields,
                              int                    *timestamp,
@@ -170,16 +193,16 @@
 	GeoclueSkyhook *skyhook;
 	char *query;
 	SoupMessage *msg;
-	
+
 	skyhook = (GEOCLUE_SKYHOOK (iface));
-	
+
 	*fields = GEOCLUE_POSITION_FIELDS_NONE;
 	if (timestamp)
 		*timestamp = time (NULL);
-	
-	query = create_post_query (skyhook->conn);
+
+	query = create_post_query ();
 	if (query == NULL) {
-		g_set_error (error, GEOCLUE_ERROR, 
+		g_set_error (error, GEOCLUE_ERROR,
 			     GEOCLUE_ERROR_NOT_AVAILABLE,
 			     "Router mac address query failed");
 		/* TODO: set status == error ? */
@@ -228,8 +251,8 @@
 			*accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE,
 							  0, 0);
 		} else {
-			/* Educated guess. Skyhook are typically hand pointed on 
-			 * a map, or geocoded from address, so should be fairly 
+			/* Educated guess. Skyhook are typically hand pointed on
+			 * a map, or geocoded from address, so should be fairly
 			 * accurate */
 			*accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_STREET,
 							  0, 0);
@@ -244,12 +267,8 @@
 {
 	GeoclueSkyhook *skyhook = GEOCLUE_SKYHOOK (obj);
 
-	if (skyhook->conn != NULL) {
-		g_object_unref (skyhook->conn);
-		skyhook->conn = NULL;
-	}
 	g_object_unref (skyhook->session);
-	
+
 	((GObjectClass *) geoclue_skyhook_parent_class)->finalize (obj);
 }
 
@@ -261,22 +280,21 @@
 {
 	GcProviderClass *p_class = (GcProviderClass *)klass;
 	GObjectClass *o_class = (GObjectClass *)klass;
-	
+
 	p_class->shutdown = _shutdown;
 	p_class->get_status = geoclue_skyhook_get_status;
-	
+
 	o_class->finalize = geoclue_skyhook_finalize;
 }
 
 static void
 geoclue_skyhook_init (GeoclueSkyhook *skyhook)
 {
-	gc_provider_set_details (GC_PROVIDER (skyhook), 
+	gc_provider_set_details (GC_PROVIDER (skyhook),
 	                         GEOCLUE_DBUS_SERVICE_SKYHOOK,
 	                         GEOCLUE_DBUS_PATH_SKYHOOK,
 	                         "Skyhook", "Skyhook.com based provider, uses gateway mac address to locate");
 	skyhook->session = soup_session_sync_new ();
-	skyhook->conn = geoclue_connectivity_new ();
 }
 
 static void
@@ -285,7 +303,7 @@
 	iface->get_position = geoclue_skyhook_get_position;
 }
 
-int 
+int
 main()
 {
 	g_type_init();
@@ -295,9 +313,9 @@
 	o->loop = g_main_loop_new (NULL, TRUE);
 
 	g_main_loop_run (o->loop);
-	
+
 	g_main_loop_unref (o->loop);
 	g_object_unref (o);
-	
+
 	return 0;
 }
Index: geoclue/providers/skyhook/geoclue-skyhook.provider
===================================================================
--- geoclue.orig/providers/skyhook/geoclue-skyhook.provider	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/skyhook/geoclue-skyhook.provider	2011-12-29 16:40:38.926428900 +0900
@@ -1,5 +1,5 @@
 [Geoclue Provider]
-Name=Skyhook
+Name=Plazes
 Service=org.freedesktop.Geoclue.Providers.Skyhook
 Path=/org/freedesktop/Geoclue/Providers/Skyhook
 Accuracy=Street
Index: geoclue/providers/yahoo/Makefile.am
===================================================================
--- geoclue.orig/providers/yahoo/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/providers/yahoo/Makefile.am	2011-12-29 16:40:38.926428900 +0900
@@ -11,7 +11,7 @@
 
 geoclue_yahoo_LDADD = \
 	$(GEOCLUE_LIBS) \
-	$(top_builddir)/geoclue/libgeoclue.la 
+	$(top_builddir)/geoclue/libgeoclue.la
 
 providersdir = $(datadir)/geoclue-providers
 providers_DATA = geoclue-yahoo.provider
@@ -21,7 +21,7 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST = 			\
 	$(service_in_files)	\
Index: geoclue/src/Makefile.am
===================================================================
--- geoclue.orig/src/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/Makefile.am	2011-12-29 16:40:38.930428900 +0900
@@ -1,8 +1,6 @@
 libexec_PROGRAMS = geoclue-master
-noinst_LTLIBRARIES = libconnectivity.la
-noinst_PROGRAMS = test-connectivity
 
-AM_CFLAGS =			\
+geoclue_master_CFLAGS =		\
 	-I$(top_srcdir)		\
 	-I$(srcdir)		\
 	-I$(top_builddir)	\
@@ -11,39 +9,30 @@
 	$(MASTER_CFLAGS) \
 	$(CONNECTIVITY_CFLAGS)
 
-geoclue_master_LDADD =				\
+geoclue_master_LDADD =		\
 	$(top_builddir)/geoclue/libgeoclue.la	\
-	libconnectivity.la			\
-	$(GEOCLUE_LIBS)				\
-	$(MASTER_LIBS)
+	$(GEOCLUE_LIBS) \
+	$(MASTER_LIBS)  \
+	$(CONNECTIVITY_LIBS)
 
 NOINST_H_FILES =		\
 	main.h			\
 	master.h		\
-	master-provider.h	\
-	client.h
-
-libconnectivity_la_SOURCES =		\
-	connectivity.h			\
+	master-provider.h		\
+	client.h		\
+	connectivity.h		\
 	connectivity-networkmanager.h	\
-	connectivity-conic.h		\
-	connectivity-connman.h		\
-	connectivity.c			\
-	connectivity-networkmanager.c	\
-	connectivity-conic.c		\
-	connectivity-connman.c
-
-libconnectivity_la_LIBADD = $(CONNECTIVITY_LIBS)
-
-test_connectivity_SOURCES = test-connectivity.c
-test_connectivity_LDADD = libconnectivity.la $(GEOCLUE_LIBS)
+	connectivity-conic.h
 
 geoclue_master_SOURCES =	\
 	$(NOINST_H_FILES)	\
 	client.c		\
 	main.c			\
 	master.c		\
-	master-provider.c
+	master-provider.c	\
+	connectivity.c		\
+	connectivity-networkmanager.c	\
+	connectivity-conic.c
 
 BUILT_SOURCES =			\
 	gc-iface-master-glue.h	\
@@ -52,13 +41,13 @@
 %-glue.h: stamp-%-glue.h
 	@true
 stamp-gc-iface-master-glue.h: ../interfaces/gc-iface-master.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_master --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_master --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F)	\
 	&& echo timestamp > $(@F)
 
 stamp-gc-iface-master-client-glue.h: ../interfaces/gc-iface-master-client.xml
-	$(AM_V_GEN) $(DBUS_BINDING_TOOL) --prefix=gc_iface_master_client --mode=glib-server $< > xgen-$(@F) \
+	$(DBUS_BINDING_TOOL) --prefix=gc_iface_master_client --mode=glib-server $< > xgen-$(@F) \
 	&& (cmp -s xgen-$(@F) $(@F:stamp-%=%) || cp xgen-$(@F) $(@F:stamp-%=%)) \
 	&& rm -f xgen-$(@F)	\
 	&& echo timestamp > $(@F)
@@ -68,18 +57,10 @@
 service_DATA = $(service_in_files:.service.in=.service)
 
 $(service_DATA): $(service_in_files) Makefile
-	$(AM_V_GEN) sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
-
-convertdir = $(datadir)/GConf/gsettings
-convert_DATA = geoclue
-
-gsettings_SCHEMAS = org.freedesktop.Geoclue.gschema.xml
-@GSETTINGS_RULES@
+	@sed -e "s|\@libexecdir\@|$(libexecdir)|" $< > $@
 
 EXTRA_DIST =			\
-	$(service_in_files)	\
-	$(gsettings_SCHEMAS)	\
-	$(convert_DATA)
+	$(service_in_files)
 
 CLEANFILES = 				\
 	$(BUILT_SOURCES) 		\
Index: geoclue/src/client.c
===================================================================
--- geoclue.orig/src/client.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/client.c	2011-12-29 16:40:38.926428900 +0900
@@ -25,10 +25,10 @@
  */
 
 /** TODO
- * 
- * 	might want to write a testing-provider with a gui for 
+ *
+ * 	might want to write a testing-provider with a gui for
  * 	choosing what to emit...
- * 
+ *
  **/
 
 
@@ -72,13 +72,11 @@
 	GcMasterProvider *position_provider;
 	GList *position_providers;
 	gboolean position_provider_choice_in_progress;
-	time_t last_position_changed;
 
 	gboolean address_started;
 	GcMasterProvider *address_provider;
 	GList *address_providers;
 	gboolean address_provider_choice_in_progress;
-	time_t last_address_changed;
 
 } GcMasterClientPrivate;
 
@@ -86,11 +84,11 @@
 
 
 
-static gboolean gc_iface_master_client_set_requirements (GcMasterClient       *client, 
-                                                         GeoclueAccuracyLevel  min_accuracy, 
-                                                         int                   min_time, 
-                                                         gboolean              require_updates, 
-                                                         GeoclueResourceFlags  allowed_resources, 
+static gboolean gc_iface_master_client_set_requirements (GcMasterClient       *client,
+                                                         GeoclueAccuracyLevel  min_accuracy,
+                                                         int                   min_time,
+                                                         gboolean              require_updates,
+                                                         GeoclueResourceFlags  allowed_resources,
                                                          GError              **error);
 static gboolean gc_iface_master_client_position_start (GcMasterClient *client, GError **error);
 static gboolean gc_iface_master_client_address_start (GcMasterClient *client, GError **error);
@@ -128,9 +126,9 @@
                                                         GeoclueStatus     status);
 static void gc_master_client_emit_position_changed (GcMasterClient *client);
 static void gc_master_client_emit_address_changed (GcMasterClient *client);
-static gboolean gc_master_client_choose_position_provider (GcMasterClient  *client, 
+static gboolean gc_master_client_choose_position_provider (GcMasterClient  *client,
                                                            GList           *providers);
-static gboolean gc_master_client_choose_address_provider (GcMasterClient  *client, 
+static gboolean gc_master_client_choose_address_provider (GcMasterClient  *client,
                                                           GList           *providers);
 
 
@@ -140,29 +138,29 @@
                 GcMasterClient   *client)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	g_debug ("client: provider %s status changed: %d", gc_master_provider_get_name (provider), status);
-	
+
 	/* change providers if needed (and if we're not choosing provider already) */
-	
+
 	if (!priv->position_provider_choice_in_progress &&
 	    status_change_requires_provider_change (priv->position_providers,
 	                                            priv->position_provider,
 	                                            provider, status) &&
-	    gc_master_client_choose_position_provider (client, 
+	    gc_master_client_choose_position_provider (client,
 	                                               priv->position_providers)) {
-		
+
 		/* we have a new position provider, force-emit position_changed */
 		gc_master_client_emit_position_changed (client);
 	}
-	
+
 	if (!priv->address_provider_choice_in_progress &&
 	    status_change_requires_provider_change (priv->address_providers,
 	                                            priv->address_provider,
 	                                            provider, status) &&
-	    gc_master_client_choose_address_provider (client, 
+	    gc_master_client_choose_address_provider (client,
 	                                              priv->address_providers)) {
-		
+
 		/* we have a new address provider, force-emit address_changed */
 		gc_master_client_emit_address_changed (client);
 	}
@@ -176,40 +174,40 @@
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GcInterfaceAccuracy *accuracy_data;
-	
+
 	accuracy_data = g_new0 (GcInterfaceAccuracy, 1);
-	g_debug ("client: %s accuracy changed (%d)", 
+	g_debug ("client: %s accuracy changed (%d)",
 	         gc_master_provider_get_name (provider), level);
-	
+
 	accuracy_data->interface = interface;
 	accuracy_data->accuracy_level = priv->min_accuracy;
 	switch (interface) {
 		case GC_IFACE_POSITION:
-			priv->position_providers = 
-				g_list_sort_with_data (priv->position_providers, 
+			priv->position_providers =
+				g_list_sort_with_data (priv->position_providers,
 						       (GCompareDataFunc)gc_master_provider_compare,
 						       accuracy_data);
 			if (priv->position_provider_choice_in_progress) {
 				g_debug ("        ...but provider choice in progress");
-			} else if (gc_master_client_choose_position_provider (client, 
+			} else if (gc_master_client_choose_position_provider (client,
 									      priv->position_providers)) {
 				gc_master_client_emit_position_changed (client);
 			}
 			break;
-			
+
 		case GC_IFACE_ADDRESS:
-			priv->address_providers = 
-				g_list_sort_with_data (priv->address_providers, 
+			priv->address_providers =
+				g_list_sort_with_data (priv->address_providers,
 						       (GCompareDataFunc)gc_master_provider_compare,
 						       accuracy_data);
 			if (priv->address_provider_choice_in_progress) {
 				g_debug ("        ...but provider choice in progress");
-			} else if (gc_master_client_choose_address_provider (client, 
+			} else if (gc_master_client_choose_address_provider (client,
 								      priv->address_providers)) {
 				gc_master_client_emit_address_changed (client);
 			}
 			break;
-			
+
 		default:
 			g_assert_not_reached ();
 	}
@@ -226,17 +224,6 @@
                   GeoclueAccuracy      *accuracy,
                   GcMasterClient       *client)
 {
-	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	time_t now;
-
-	now = time (NULL);
-	if (priv->min_time > (now - priv->last_position_changed)) {
-		/* NOTE: currently no-one makes sure there is an emit
-		 * after min_time */
-		return;
-	}
-	priv->last_position_changed = now;
-
 	gc_iface_position_emit_position_changed
 		(GC_IFACE_POSITION (client),
 		 fields,
@@ -252,17 +239,6 @@
                  GeoclueAccuracy      *accuracy,
                  GcMasterClient       *client)
 {
-	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	time_t now;
-
-	now = time (NULL);
-	if (priv->min_time > (now - priv->last_address_changed)) {
-		/* NOTE: currently no-one makes sure there is an emit
-		 * after min_time */
-		return;
-	}
-	priv->last_address_changed = now;
-
 	gc_iface_address_emit_address_changed
 		(GC_IFACE_ADDRESS (client),
 		 timestamp,
@@ -279,18 +255,18 @@
 {
 	if (!provider_list) {
 		return FALSE;
-		
+
 	} else if (current_provider == NULL) {
 		return (status == GEOCLUE_STATUS_AVAILABLE);
-		
+
 	} else if (current_provider == changed_provider) {
 		return (status != GEOCLUE_STATUS_AVAILABLE);
-		
+
 	}else if (status != GEOCLUE_STATUS_AVAILABLE) {
 		return FALSE;
-		
+
 	}
-	
+
 	while (provider_list) {
 		GcMasterProvider *p = provider_list->data;
 		if (p == current_provider) {
@@ -311,7 +287,7 @@
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GList *l;
-	
+
 	/* connect to common signals if the provider is not already connected */
 	l = providers;
 	while (l) {
@@ -337,11 +313,11 @@
 {
 	while (provider_list) {
 		GcMasterProvider *provider = provider_list->data;
-		
+
 		gc_master_provider_unsubscribe (provider, client, iface);
 		provider_list = provider_list->next;
 	}
-	
+
 }
 
 /* get_best_provider will return the best provider with status == GEOCLUE_STATUS_AVAILABLE.
@@ -353,15 +329,15 @@
 {
 	GList *l = *provider_list;
 	/* TODO: should maybe choose a acquiring provider if better ones are are not available */
-	
+
 	g_debug ("client: choosing best provider");
-	
+
 	while (l) {
 		GcMasterProvider *provider = l->data;
-		
+
 		g_debug ("        ...trying provider %s", gc_master_provider_get_name (provider));
 		if (gc_master_provider_subscribe (provider, client, iface)) {
-			/* provider was started, so accuracy may have changed 
+			/* provider was started, so accuracy may have changed
 			   (which re-sorts provider lists), restart provider selection */
 			/* TODO re-think this: restarting provider selection leads to potentially
 			   never-ending looping */
@@ -372,7 +348,7 @@
 			continue;
 		}
 		/* provider did not need to be started */
-		
+
 		/* TODO: currently returning even providers that are worse than priv->min_accuracy,
 		 * if nothing else is available */
 		if (gc_master_provider_get_status (provider) == GEOCLUE_STATUS_AVAILABLE) {
@@ -382,7 +358,7 @@
 		}
 		l = l->next;
 	}
-	
+
 	/* no provider found */
 	gc_master_client_unsubscribe_providers (client, *provider_list, iface);
 	return NULL;
@@ -397,8 +373,8 @@
 	double latitude, longitude, altitude;
 	GeoclueAccuracy *accuracy = NULL;
 	GError *error = NULL;
-	
-	
+
+
 	if (priv->position_provider == NULL) {
 		accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0.0, 0.0);
 		gc_iface_position_emit_position_changed
@@ -410,7 +386,7 @@
 		geoclue_accuracy_free (accuracy);
 		return;
 	}
-	
+
 	fields = gc_master_provider_get_position
 		(priv->position_provider,
 		 &timestamp,
@@ -419,7 +395,7 @@
 		 &error);
 	if (error) {
 		/*TODO what now?*/
-		g_warning ("client: failed to get position from %s: %s", 
+		g_warning ("client: failed to get position from %s: %s",
 		           gc_master_provider_get_name (priv->position_provider),
 		           error->message);
 		g_error_free (error);
@@ -433,7 +409,7 @@
 		 accuracy);
 }
 
-static void 
+static void
 gc_master_client_emit_address_changed (GcMasterClient *client)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
@@ -441,7 +417,7 @@
 	GHashTable *details = NULL;
 	GeoclueAccuracy *accuracy = NULL;
 	GError *error = NULL;
-	
+
 	if (priv->address_provider == NULL) {
 		accuracy = geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0.0, 0.0);
 		details = g_hash_table_new (g_str_hash, g_str_equal);
@@ -461,7 +437,7 @@
 		 &accuracy,
 		 &error)) {
 		/*TODO what now?*/
-		g_warning ("client: failed to get address from %s: %s", 
+		g_warning ("client: failed to get address from %s: %s",
 		           gc_master_provider_get_name (priv->address_provider),
 		           error->message);
 		g_error_free (error);
@@ -476,40 +452,40 @@
 
 /* return true if a _new_ provider was chosen */
 static gboolean
-gc_master_client_choose_position_provider (GcMasterClient *client, 
+gc_master_client_choose_position_provider (GcMasterClient *client,
                                            GList *providers)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GcMasterProvider *new_p;
-	
+
 	/* choose and start provider */
 	priv->position_provider_choice_in_progress = TRUE;
-	new_p = gc_master_client_get_best_provider (client, 
-	                                            &priv->position_providers, 
+	new_p = gc_master_client_get_best_provider (client,
+	                                            &priv->position_providers,
 	                                            GC_IFACE_POSITION);
 	priv->position_provider_choice_in_progress = FALSE;
-	
+
 	if (priv->position_provider && new_p == priv->position_provider) {
 		return FALSE;
 	}
-	
+
 	if (priv->signals[POSITION_CHANGED] > 0) {
-		g_signal_handler_disconnect (priv->position_provider, 
+		g_signal_handler_disconnect (priv->position_provider,
 		                             priv->signals[POSITION_CHANGED]);
 		priv->signals[POSITION_CHANGED] = 0;
 	}
-	
+
 	priv->position_provider = new_p;
-	
+
 	if (priv->position_provider == NULL) {
 		g_debug ("client: position provider changed (to NULL)");
-		g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0, 
+		g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0,
 		               NULL, NULL, NULL, NULL);
 		return TRUE;
 	}
-	
+
 	g_debug ("client: position provider changed (to %s)", gc_master_provider_get_name (priv->position_provider));
-	g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0, 
+	g_signal_emit (client, signals[POSITION_PROVIDER_CHANGED], 0,
 		       gc_master_provider_get_name (priv->position_provider),
 		       gc_master_provider_get_description (priv->position_provider),
 		       gc_master_provider_get_service (priv->position_provider),
@@ -524,47 +500,47 @@
 
 /* return true if a _new_ provider was chosen */
 static gboolean
-gc_master_client_choose_address_provider (GcMasterClient *client, 
+gc_master_client_choose_address_provider (GcMasterClient *client,
                                           GList *providers)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GcMasterProvider *new_p;
-	
-	
+
+
 	/* choose and start provider */
 	priv->address_provider_choice_in_progress = TRUE;
-	new_p = gc_master_client_get_best_provider (client, 
-	                                            &priv->address_providers, 
+	new_p = gc_master_client_get_best_provider (client,
+	                                            &priv->address_providers,
 	                                            GC_IFACE_ADDRESS);
 	priv->address_provider_choice_in_progress = FALSE;
-	
+
 	if (priv->address_provider != NULL && new_p == priv->address_provider) {
 		/* keep using the same provider */
 		return FALSE;
 	}
-	
+
 	if (priv->address_provider && priv->signals[ADDRESS_CHANGED] > 0) {
-		g_signal_handler_disconnect (priv->address_provider, 
+		g_signal_handler_disconnect (priv->address_provider,
 					     priv->signals[ADDRESS_CHANGED]);
 		priv->signals[ADDRESS_CHANGED] = 0;
 	}
-	
+
 	priv->address_provider = new_p;
-	
+
 	if (priv->address_provider == NULL) {
 		g_debug ("client: address provider changed (to NULL)");
-		g_signal_emit (client, signals[ADDRESS_PROVIDER_CHANGED], 0, 
+		g_signal_emit (client, signals[ADDRESS_PROVIDER_CHANGED], 0,
 		               NULL, NULL, NULL, NULL);
 		return TRUE;
 	}
-	
+
 	g_debug ("client: address provider changed (to %s)", gc_master_provider_get_name (priv->address_provider));
-	g_signal_emit (client, signals[ADDRESS_PROVIDER_CHANGED], 0, 
+	g_signal_emit (client, signals[ADDRESS_PROVIDER_CHANGED], 0,
 		       gc_master_provider_get_name (priv->address_provider),
 		       gc_master_provider_get_description (priv->address_provider),
 		       gc_master_provider_get_service (priv->address_provider),
 		       gc_master_provider_get_path (priv->address_provider));
-	priv->signals[ADDRESS_CHANGED] = 
+	priv->signals[ADDRESS_CHANGED] =
 		g_signal_connect (G_OBJECT (priv->address_provider),
 				  "address-changed",
 				  G_CALLBACK (address_changed),
@@ -573,42 +549,42 @@
 }
 
 static void
-gc_master_provider_set_position_providers (GcMasterClient *client, 
+gc_master_provider_set_position_providers (GcMasterClient *client,
                                            GList *providers)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GcInterfaceAccuracy *accuracy_data;
-	
+
 	accuracy_data = g_new0(GcInterfaceAccuracy, 1);
 	accuracy_data->interface = GC_IFACE_POSITION;
 	accuracy_data->accuracy_level = priv->min_accuracy;
-	
+
 	gc_master_client_connect_common_signals (client, providers);
-	priv->position_providers = 
+	priv->position_providers =
 		g_list_sort_with_data (providers,
 		                       (GCompareDataFunc)gc_master_provider_compare,
 		                       accuracy_data);
-	
+
 	g_free (accuracy_data);
 }
 
 static void
-gc_master_provider_set_address_providers (GcMasterClient *client, 
+gc_master_provider_set_address_providers (GcMasterClient *client,
                                            GList *providers)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GcInterfaceAccuracy *accuracy_data;
-	
+
 	accuracy_data = g_new0(GcInterfaceAccuracy, 1);
 	accuracy_data->interface = GC_IFACE_ADDRESS;
 	accuracy_data->accuracy_level = priv->min_accuracy;
-	
+
 	gc_master_client_connect_common_signals (client, providers);
-	priv->address_providers = 
+	priv->address_providers =
 		g_list_sort_with_data (providers,
 		                       (GCompareDataFunc)gc_master_provider_compare,
 		                       accuracy_data);
-	
+
 	g_free (accuracy_data);
 }
 
@@ -617,21 +593,21 @@
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
 	GList *providers;
-	
+
 	if (!priv->position_started) {
 		return;
 	}
-	 
+
 	/* TODO: free priv->position_providers */
-	
+
 	providers = gc_master_get_providers (GC_IFACE_POSITION,
 	                                     priv->min_accuracy,
 	                                     priv->require_updates,
 	                                     priv->allowed_resources,
 	                                     NULL);
-	g_debug ("client: %d position providers matching requirements found, now choosing current provider", 
+	g_debug ("client: %d position providers matching requirements found, now choosing current provider",
 	         g_list_length (providers));
-	
+
 	gc_master_provider_set_position_providers (client, providers);
 	gc_master_client_choose_position_provider (client, priv->position_providers);
 }
@@ -640,21 +616,21 @@
 {
 	GList *providers;
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	if (!priv->address_started) {
 		return;
 	}
-	 
+
 	/* TODO: free priv->address_providers */
-	
+
 	providers = gc_master_get_providers (GC_IFACE_ADDRESS,
 	                                     priv->min_accuracy,
 	                                     priv->require_updates,
 	                                     priv->allowed_resources,
 	                                     NULL);
-	g_debug ("client: %d address providers matching requirements found, now choosing current provider", 
+	g_debug ("client: %d address providers matching requirements found, now choosing current provider",
 	         g_list_length (providers));
-	
+
 	gc_master_provider_set_address_providers (client, providers);
 	gc_master_client_choose_address_provider (client, priv->address_providers);
 }
@@ -668,25 +644,25 @@
 					 GError               **error)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	priv->min_accuracy = min_accuracy;
 	priv->min_time = min_time;
 	priv->require_updates = require_updates;
 	priv->allowed_resources = allowed_resources;
-	
+
 	gc_master_client_init_position_providers (client);
 	gc_master_client_init_address_providers (client);
-	
+
 	return TRUE;
 }
 
 
-static gboolean 
-gc_iface_master_client_position_start (GcMasterClient *client, 
+static gboolean
+gc_iface_master_client_position_start (GcMasterClient *client,
                                        GError         **error)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	if (priv->position_providers) {
 		if (error) {
 			*error = g_error_new (GEOCLUE_ERROR,
@@ -695,20 +671,20 @@
 		}
 		return FALSE;
 	}
-	
+
 	priv->position_started = TRUE;
-	
-	gc_master_client_init_position_providers (client); 
-	
+
+	gc_master_client_init_position_providers (client);
+
 	return TRUE;
 }
 
-static gboolean 
+static gboolean
 gc_iface_master_client_address_start (GcMasterClient *client,
                                       GError         **error)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	if (priv->address_providers) {
 		if (error) {
 			*error = g_error_new (GEOCLUE_ERROR,
@@ -717,7 +693,7 @@
 		}
 		return FALSE;
 	}
-	
+
 	priv->address_started = TRUE;
 	gc_master_client_init_address_providers (client);
 	return TRUE;
@@ -759,9 +735,9 @@
 		}
 	}
 }
-                             
 
-static gboolean 
+
+static gboolean
 gc_iface_master_client_get_address_provider (GcMasterClient  *client,
                                              char           **name,
                                              char           **description,
@@ -770,13 +746,13 @@
                                              GError         **error)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	get_master_provider_details (priv->address_provider,
 	                             name, description, service, path);
 	return TRUE;
 }
 
-static gboolean 
+static gboolean
 gc_iface_master_client_get_position_provider (GcMasterClient  *client,
                                               char           **name,
                                               char           **description,
@@ -785,7 +761,7 @@
                                               GError         **error)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	get_master_provider_details (priv->position_provider,
 	                             name, description, service, path);
 	return TRUE;
@@ -796,7 +772,7 @@
 {
 	GcMasterClient *client = GC_MASTER_CLIENT (object);
 	GcMasterClientPrivate *priv = GET_PRIVATE (object);
-	
+
 	/* do not free contents of the lists, Master takes care of them */
 	if (priv->position_providers) {
 		gc_master_client_unsubscribe_providers (client, priv->position_providers, GC_IFACE_ALL);
@@ -808,7 +784,7 @@
 		g_list_free (priv->address_providers);
 		priv->address_providers = NULL;
 	}
-	
+
 	((GObjectClass *) gc_master_client_parent_class)->finalize (object);
 }
 
@@ -816,12 +792,12 @@
 gc_master_client_class_init (GcMasterClientClass *klass)
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
-	
+
 	o_class->finalize = finalize;
-	
+
 	g_type_class_add_private (klass, sizeof (GcMasterClientPrivate));
-	
-	signals[ADDRESS_PROVIDER_CHANGED] = 
+
+	signals[ADDRESS_PROVIDER_CHANGED] =
 		g_signal_new ("address-provider-changed",
 		              G_OBJECT_CLASS_TYPE (klass),
 		              G_SIGNAL_RUN_LAST, 0,
@@ -829,7 +805,7 @@
 		              geoclue_marshal_VOID__STRING_STRING_STRING_STRING,
 		              G_TYPE_NONE, 4,
 		              G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-	signals[POSITION_PROVIDER_CHANGED] = 
+	signals[POSITION_PROVIDER_CHANGED] =
 		g_signal_new ("position-provider-changed",
 		              G_OBJECT_CLASS_TYPE (klass),
 		              G_SIGNAL_RUN_LAST, 0,
@@ -837,10 +813,10 @@
 		              geoclue_marshal_VOID__STRING_STRING_STRING_STRING,
 		              G_TYPE_NONE, 4,
 		              G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-	
+
 	dbus_g_object_type_install_info (gc_master_client_get_type (),
 					 &dbus_glib_gc_iface_master_client_object_info);
-	
+
 
 }
 
@@ -848,14 +824,14 @@
 gc_master_client_init (GcMasterClient *client)
 {
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	priv->position_provider_choice_in_progress = FALSE;
 	priv->address_provider_choice_in_progress = FALSE;
-	
+
 	priv->position_started = FALSE;
 	priv->position_provider = NULL;
 	priv->position_providers = NULL;
-	
+
 	priv->address_started = FALSE;
 	priv->address_provider = NULL;
 	priv->address_providers = NULL;
@@ -873,7 +849,7 @@
 {
 	GcMasterClient *client = GC_MASTER_CLIENT (iface);
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	if (priv->position_provider == NULL) {
 		if (error) {
 			*error = g_error_new (GEOCLUE_ERROR,
@@ -882,7 +858,7 @@
 		}
 		return FALSE;
 	}
-	
+
 	*fields = gc_master_provider_get_position
 		(priv->position_provider,
 		 timestamp,
@@ -892,7 +868,7 @@
 	return (!*error);
 }
 
-static gboolean 
+static gboolean
 get_address (GcIfaceAddress   *iface,
              int              *timestamp,
              GHashTable      **address,
@@ -901,7 +877,7 @@
 {
 	GcMasterClient *client = GC_MASTER_CLIENT (iface);
 	GcMasterClientPrivate *priv = GET_PRIVATE (client);
-	
+
 	if (priv->address_provider == NULL) {
 		if (error) {
 			*error = g_error_new (GEOCLUE_ERROR,
@@ -910,7 +886,7 @@
 		}
 		return FALSE;
 	}
-	
+
 	return gc_master_provider_get_address
 		(priv->address_provider,
 		 timestamp,
@@ -935,12 +911,12 @@
              GError        **error)
 {
 	/* not meaningful, options come from master */
-	
+
 	/* It is not an error to not have a SetOptions implementation */
 	return TRUE;
 }
 
-static gboolean 
+static gboolean
 get_provider_info (GcIfaceGeoclue  *geoclue,
 		   gchar          **name,
 		   gchar          **description,
Index: geoclue/src/connectivity-networkmanager.c
===================================================================
--- geoclue.orig/src/connectivity-networkmanager.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/connectivity-networkmanager.c	2011-12-29 16:40:38.930428900 +0900
@@ -27,19 +27,11 @@
 
 
 #include <dbus/dbus-glib.h>
-#include <string.h>
-
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
 #include <NetworkManager.h> /*for DBus strings */
 
+#ifdef HAVE_NETWORK_MANAGER
 #include <nm-client.h>
 #include <nm-device-wifi.h>
-#include <nm-setting-ip4-config.h>
-
-#if !defined(NM_CHECK_VERSION)
-#define NM_CHECK_VERSION(x,y,z) 0
 #endif
 
 #include "connectivity-networkmanager.h"
@@ -65,158 +57,7 @@
 {
 	GeoclueNetworkManager *self = GEOCLUE_NETWORKMANAGER (iface);
 
-	return g_strdup (self->cache_ap_mac);
-}
-
-static int
-strength_to_dbm (int strength)
-{
-	/* Hackish linear strength to dBm conversion.
-	 * 0% is -90 dBm
-	 * 100% is -20 dBm */
-	return (strength * 0.7) - 90;
-}
-
-static GHashTable *
-get_aps (GeoclueConnectivity *iface)
-{
-	GeoclueNetworkManager *self = GEOCLUE_NETWORKMANAGER (iface);
-	const GPtrArray *devices;
-	GHashTable *ht;
-	guint i;
-
-	devices = nm_client_get_devices (self->client);
-	if (devices == NULL)
-		return NULL;
-
-	ht = g_hash_table_new_full (g_str_hash, g_str_equal,
-				    (GDestroyNotify) g_free, NULL);
-
-	for (i = 0; i < devices->len; i++) {
-		NMDevice *device = g_ptr_array_index (devices, i);
-		if (NM_IS_DEVICE_WIFI (device)) {
-			const GPtrArray *aps;
-			guint j;
-
-			aps = nm_device_wifi_get_access_points (NM_DEVICE_WIFI (device));
-			if (aps == NULL || aps->len == 0)
-				continue;
-			for (j = 0; j < aps->len; j++) {
-				NMAccessPoint *ap = NM_ACCESS_POINT (g_ptr_array_index (aps, j));
-				char *ap_mac;
-				int strength;
-
-				ap_mac = g_strdup (nm_access_point_get_hw_address (ap));
-				strength = nm_access_point_get_strength (ap);
-				g_hash_table_insert (ht, ap_mac, GINT_TO_POINTER (strength_to_dbm (strength)));
-			}
-		}
-	}
-	if (g_hash_table_size (ht) == 0) {
-		g_hash_table_destroy (ht);
-		return NULL;
-	}
-
-	return ht;
-}
-
-static char *
-mac_strup (char *mac)
-{
-	guint i;
-	for (i = 0; mac[i] != '\0' ; i++) {
-		if (g_ascii_isalpha (mac[i]))
-			mac[i] = g_ascii_toupper (mac[i]);
-	}
-	return mac;
-}
-
-static char *
-get_mac_for_gateway (const char *gateway)
-{
-	char *cmd, *out, *mac, **split;
-
-	cmd = g_strdup_printf ("ip neigh show %s", gateway);
-
-	if (g_spawn_command_line_sync (cmd, &out, NULL, NULL, NULL) == FALSE) {
-		g_free (out);
-		g_free (cmd);
-		return NULL;
-	}
-	g_free (cmd);
-
-	/* 192.168.1.1 dev eth0 lladdr 00:00:00:00:00:00 STALE */
-	split = g_strsplit (out, " ", -1);
-	g_free (out);
-
-	if (split == NULL)
-		return NULL;
-	if (g_strv_length (split) != 6) {
-		g_strfreev (split);
-		return NULL;
-	}
-	mac = g_strdup (split[4]);
-	g_strfreev (split);
-
-	return mac_strup (mac);
-}
-
-static gchar *
-ip4_address_as_string (guint32 ip)
-{
-	struct in_addr tmp_addr;
-	char buf[INET_ADDRSTRLEN+1];
-
-	memset (&buf, '\0', sizeof (buf));
-	tmp_addr.s_addr = ip;
-
-	if (inet_ntop (AF_INET, &tmp_addr, buf, INET_ADDRSTRLEN))
-		return g_strdup (buf);
-
-	return NULL;
-}
-
-static char *
-get_router_mac (GeoclueConnectivity *iface)
-{
-	GeoclueNetworkManager *self = GEOCLUE_NETWORKMANAGER (iface);
-	const GPtrArray *devices;
-	char *gateway, *mac;
-	guint i;
-
-	devices = nm_client_get_devices (self->client);
-	if (devices == NULL)
-		return NULL;
-
-	gateway = NULL;
-
-	for (i = 0; i < devices->len; i++) {
-		NMDevice *device = g_ptr_array_index (devices, i);
-		NMIP4Config *cfg4;
-		GSList *iter;
-
-		if (nm_device_get_state (device) != NM_DEVICE_STATE_ACTIVATED)
-			continue;
-
-		cfg4 = nm_device_get_ip4_config (device);
-		if (cfg4 == NULL)
-			continue;
-
-		for (iter = (GSList *) nm_ip4_config_get_addresses (cfg4); iter; iter = g_slist_next (iter)) {
-			NMIP4Address *addr = (NMIP4Address *) iter->data;
-
-			gateway = ip4_address_as_string (nm_ip4_address_get_gateway (addr));
-			if (gateway != NULL)
-				break;
-		}
-	}
-	if (gateway == NULL)
-		return NULL;
-
-	mac = get_mac_for_gateway (gateway);
-	g_free (gateway);
-
-	return mac;
+	return self->cache_ap_mac;
 }
 
 static void
@@ -248,12 +89,16 @@
 	guint i;
 
 	devices = nm_client_get_devices (self->client);
+	if (devices == NULL) {
+		g_free (self->cache_ap_mac);
+		self->cache_ap_mac = NULL;
+	}
 
 	g_free (self->cache_ap_mac);
 	self->cache_ap_mac = NULL;
 	self->ap_strength = 0;
 
-	for (i = 0; devices != NULL && i < devices->len; i++) {
+	for (i = 0; i < devices->len; i++) {
 		NMDevice *device = g_ptr_array_index (devices, i);
 		if (NM_IS_DEVICE_WIFI (device)) {
 			get_best_ap (self, device);
@@ -262,10 +107,19 @@
 }
 
 static void
+finalize (GObject *object)
+{
+	/* free everything */
+
+	((GObjectClass *) geoclue_networkmanager_parent_class)->finalize (object);
+}
+
+static void
 dispose (GObject *object)
 {
 	GeoclueNetworkManager *self = GEOCLUE_NETWORKMANAGER (object);
-	
+
+	dbus_g_connection_unref (self->connection);
 	g_free (self->cache_ap_mac);
 	self->cache_ap_mac = NULL;
 	g_object_unref (self->client);
@@ -277,11 +131,12 @@
 geoclue_networkmanager_class_init (GeoclueNetworkManagerClass *klass)
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
-	
+
+	o_class->finalize = finalize;
 	o_class->dispose = dispose;
 }
 
-static GeoclueNetworkStatus 
+static GeoclueNetworkStatus
 nmstate_to_geocluenetworkstatus (NMState status)
 {
 	switch (status) {
@@ -289,19 +144,10 @@
 			return GEOCLUE_CONNECTIVITY_UNKNOWN;
 		case NM_STATE_ASLEEP:
 		case NM_STATE_DISCONNECTED:
-#if NM_CHECK_VERSION(0,8,992)
-		case NM_STATE_DISCONNECTING:
-#endif
 			return GEOCLUE_CONNECTIVITY_OFFLINE;
 		case NM_STATE_CONNECTING:
 			return GEOCLUE_CONNECTIVITY_ACQUIRING;
-#if NM_CHECK_VERSION(0,8,992)
-		case NM_STATE_CONNECTED_LOCAL:
-		case NM_STATE_CONNECTED_SITE:
-		case NM_STATE_CONNECTED_GLOBAL:
-#else
 		case NM_STATE_CONNECTED:
-#endif
 			return GEOCLUE_CONNECTIVITY_ONLINE;
 		default:
 			g_warning ("Unknown NMStatus: %d", status);
@@ -310,60 +156,72 @@
 }
 
 static void
-update_status (GeoclueNetworkManager *self, gboolean do_signal)
+geoclue_networkmanager_state_changed (DBusGProxy *proxy,
+                                      NMState status,
+                                      gpointer userdata)
 {
-	GeoclueNetworkStatus old_status;
-	NMState state;
+	GeoclueNetworkManager *self = GEOCLUE_NETWORKMANAGER (userdata);
+	GeoclueNetworkStatus gc_status;
 
-	old_status = self->status;
+	gc_status = nmstate_to_geocluenetworkstatus (status);
 
-	if (nm_client_get_manager_running (self->client)) {
-		state = nm_client_get_state (self->client);
-		self->status = nmstate_to_geocluenetworkstatus (state);
+	if (gc_status != self->status) {
 		cache_ap_mac (self);
-	} else {
-		self->status = GEOCLUE_CONNECTIVITY_OFFLINE;
-	}
-
-	if ((self->status != old_status) && do_signal) {
+		self->status = gc_status;
 		geoclue_connectivity_emit_status_changed (GEOCLUE_CONNECTIVITY (self),
 		                                          self->status);
 	}
 }
 
-static void
-nm_update_status_cb (GObject *obj, GParamSpec *spec, gpointer userdata)
-{
-	update_status (GEOCLUE_NETWORKMANAGER (userdata), TRUE);
-}
+
+#define NM_DBUS_SIGNAL_STATE_CHANGE "StateChange"
 
 static void
 geoclue_networkmanager_init (GeoclueNetworkManager *self)
 {
+	GError *error = NULL;
+	DBusGProxy *proxy;
+	NMState state;
+
 	self->status = GEOCLUE_CONNECTIVITY_UNKNOWN;
-	self->client = nm_client_new ();
-	if (self->client == NULL) {
-		g_warning ("%s was unable to create a connection to NetworkManager",
-			   G_OBJECT_TYPE_NAME (self));
+
+	self->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (self->connection == NULL) {
+		g_warning ("%s was unable to create a connection to D-Bus: %s",
+			   G_OBJECT_TYPE_NAME (self), error->message);
+		g_error_free (error);
 		return;
 	}
 
-	g_signal_connect (G_OBJECT (self->client), "notify::running",
-	                  G_CALLBACK (nm_update_status_cb), self);
-	g_signal_connect (G_OBJECT (self->client), "notify::state",
-	                  G_CALLBACK (nm_update_status_cb), self);
+	proxy = dbus_g_proxy_new_for_name (self->connection,
+	                                   NM_DBUS_SERVICE,
+	                                   NM_DBUS_PATH,
+	                                   NM_DBUS_INTERFACE);
+	dbus_g_proxy_add_signal (proxy, NM_DBUS_SIGNAL_STATE_CHANGE,
+	                         G_TYPE_UINT, G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (proxy, NM_DBUS_SIGNAL_STATE_CHANGE,
+	                             G_CALLBACK (geoclue_networkmanager_state_changed),
+	                             self, NULL);
+
+	if (dbus_g_proxy_call (proxy, "state", &error,
+	                       G_TYPE_INVALID,
+	                       G_TYPE_UINT, &state, G_TYPE_INVALID)){
+		self->status = nmstate_to_geocluenetworkstatus (state);
+	} else {
+		g_warning ("Could not get connectivity state from NetworkManager: %s", error->message);
+		g_error_free (error);
+	}
 
-	/* get initial status */
-	update_status (self, FALSE);
+	self->client = nm_client_new ();
+	cache_ap_mac (self);
 }
 
+
 static void
 geoclue_networkmanager_connectivity_init (GeoclueConnectivityInterface *iface)
 {
 	iface->get_status = get_status;
 	iface->get_ap_mac = get_ap_mac;
-	iface->get_router_mac = get_router_mac;
-	iface->get_aps    = get_aps;
 }
 
 #endif /* HAVE_NETWORK_MANAGER */
Index: geoclue/src/connectivity-networkmanager.h
===================================================================
--- geoclue.orig/src/connectivity-networkmanager.h	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/connectivity-networkmanager.h	2011-12-29 16:40:38.930428900 +0900
@@ -37,9 +37,10 @@
 
 typedef struct {
 	GObject parent;
-	
+
 	/* private */
 	GeoclueNetworkStatus status;
+	DBusGConnection *connection;
 	NMClient *client;
 	char *cache_ap_mac;
 	int ap_strength;
Index: geoclue/src/connectivity.c
===================================================================
--- geoclue.orig/src/connectivity.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/connectivity.c	2011-12-29 16:40:38.926428900 +0900
@@ -21,28 +21,9 @@
  * Boston, MA 02111-1307, USA.
  *
  */
-#include <config.h>
-
 #include <glib.h>
-#include <string.h>
-#include <stdio.h>
-
 #include "connectivity.h"
 
-#ifdef HAVE_NETWORK_MANAGER
-#include "connectivity-networkmanager.h"
-#else
-#ifdef HAVE_CONIC
-#include "connectivity-conic.h"
-#else
-#ifdef HAVE_CONNMAN
-#include "connectivity-connman.h"
-#endif
-#endif
-#endif
-
-#define DEFAULT_DBM -50
-
 enum {
 	STATUS_CHANGED,
 	LAST_SIGNAL
@@ -54,16 +35,16 @@
 geoclue_connectivity_base_init (gpointer klass)
 {
 	static gboolean initialized = FALSE;
-	
+
 	if (initialized) {
 		return;
 	}
-	
+
 	initialized = TRUE;
 	signals[STATUS_CHANGED] = g_signal_new ("status-changed",
 	                          G_OBJECT_CLASS_TYPE (klass),
 	                          G_SIGNAL_RUN_LAST,
-	                          G_STRUCT_OFFSET (GeoclueConnectivityInterface, 
+	                          G_STRUCT_OFFSET (GeoclueConnectivityInterface,
 	                                           status_changed),
 	                          NULL, NULL,
 	                          g_cclosure_marshal_VOID__INT,
@@ -74,39 +55,20 @@
 geoclue_connectivity_get_type (void)
 {
 	static GType type = 0;
-	
+
 	if (!type) {
 		const GTypeInfo info = {
 			sizeof (GeoclueConnectivityInterface),
 			geoclue_connectivity_base_init,
 			NULL,
 		};
-		
+
 		type = g_type_register_static (G_TYPE_INTERFACE,
-		                               "GeoclueConnectivity", 
+		                               "GeoclueConnectivity",
 		                               &info, 0);
 	}
-	
-	return type;
-}
-
-GeoclueConnectivity *
-geoclue_connectivity_new (void)
-{
-	GeoclueConnectivity *connectivity = NULL;
 
-#ifdef HAVE_NETWORK_MANAGER
-	connectivity = GEOCLUE_CONNECTIVITY (g_object_new (GEOCLUE_TYPE_NETWORKMANAGER, NULL));
-#else
-#ifdef HAVE_CONIC
-	connectivity = GEOCLUE_CONNECTIVITY (g_object_new (GEOCLUE_TYPE_CONIC, NULL));
-#else
-#ifdef HAVE_CONNMAN
-	connectivity = GEOCLUE_CONNECTIVITY (g_object_new (GEOCLUE_TYPE_CONNMAN, NULL));
-#endif
-#endif
-#endif
-	return connectivity;
+	return type;
 }
 
 GeoclueNetworkStatus
@@ -115,156 +77,11 @@
 	return GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_status (self);
 }
 
-/* Parse /proc/net/route to get default gateway address and then parse
- * /proc/net/arp to find matching mac address.
- *
- * There are some problems with this. First, it's IPv4 only.
- * Second, there must be a way to do this with ioctl, but that seemed really
- * complicated... even /usr/sbin/arp parses /proc/net/arp
- *
- * returns:
- *   1 : on success
- *   0 : no success, no errors
- *  <0 : error
- */
-static int
-get_router_mac_fallback (char **mac)
-{
-	char *content;
-	char **lines, **entry;
-	GError *error = NULL;
-	char *route_gateway = NULL;
-
-	g_assert (*mac == NULL);
-
-	if (!g_file_get_contents ("/proc/net/route", &content, NULL, &error)) {
-		g_warning ("Failed to read /proc/net/route: %s", error->message);
-		g_error_free (error);
-		return -1;
-	}
-
-	lines = g_strsplit (content, "\n", 0);
-	g_free (content);
-	entry = lines + 1;
-
-	while (*entry && strlen (*entry) > 0) {
-		char dest[9];
-		char gateway[9];
-		if (sscanf (*entry,
-			    "%*s %8[0-9A-Fa-f] %8[0-9A-Fa-f] %*s",
-			    dest, gateway) != 2) {
-			g_warning ("Failed to parse /proc/net/route entry '%s'", *entry);
-		} else if (strcmp (dest, "00000000") == 0) {
-			route_gateway = g_strdup (gateway);
-			break;
-		}
-		entry++;
-	}
-	g_strfreev (lines);
-
-	if (!route_gateway) {
-		g_warning ("Failed to find default route in /proc/net/route");
-		return -1;
-	}
-
-	if (!g_file_get_contents ("/proc/net/arp", &content, NULL, &error)) {
-		g_warning ("Failed to read /proc/net/arp: %s", error->message);
-		g_error_free (error);
-		return -1;
-	}
-
-	lines = g_strsplit (content, "\n", 0);
-	g_free (content);
-	entry = lines+1;
-	while (*entry && strlen (*entry) > 0) {
-		char hwa[100];
-		char *arp_gateway;
-		int ip[4];
-
-		if (sscanf(*entry,
-			   "%d.%d.%d.%d 0x%*x 0x%*x %100s %*s %*s\n",
-			   &ip[0], &ip[1], &ip[2], &ip[3], hwa) != 5) {
-			g_warning ("Failed to parse /proc/net/arp entry '%s'", *entry);
-		} else {
-			arp_gateway = g_strdup_printf ("%02X%02X%02X%02X", ip[3], ip[2], ip[1], ip[0]);
-			if (strcmp (arp_gateway, route_gateway) == 0) {
-				g_free (arp_gateway);
-				*mac = g_strdup (hwa);
-				break;
-			}
-			g_free (arp_gateway);
-
-		}
-		entry++;
-	}
-	g_free (route_gateway);
-	g_strfreev (lines);
-
-	return *mac ? 1 : 0;
-}
-
-static char *
-mac_strup (char *mac)
-{
-	guint i;
-	for (i = 0; mac[i] != '\0' ; i++) {
-		if (g_ascii_isalpha (mac[i]))
-			mac[i] = g_ascii_toupper (mac[i]);
-	}
-	return mac;
-}
-
-char *
-geoclue_connectivity_get_router_mac (GeoclueConnectivity *self)
-{
-	if (self == NULL ||
-	    GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_router_mac == NULL) {
-		char *mac = NULL;
-		guint i;
-		int ret_val;
-
-		for (i = 0; i < 5; i++) {
-			ret_val = get_router_mac_fallback (&mac);
-			if (ret_val < 0)
-				return NULL;
-			else if (ret_val == 1)
-				break;
-			g_usleep (G_USEC_PER_SEC / 10);
-		}
-		return mac_strup (mac);
-	}
-
-	return GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_router_mac (self);
-}
-
 char *
 geoclue_connectivity_get_ap_mac (GeoclueConnectivity *self)
 {
-	if (self != NULL &&
-	    GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_ap_mac != NULL)
+	if (GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_ap_mac != NULL)
 		return GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_ap_mac (self);
-
-	/* Hack when not using NetworkManager */
-	return geoclue_connectivity_get_router_mac (self);
-}
-
-GHashTable *
-geoclue_connectivity_get_aps (GeoclueConnectivity *self)
-{
-	char *ap;
-	GHashTable *ht;
-
-	if (self != NULL &&
-	    GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_aps != NULL)
-		return GEOCLUE_CONNECTIVITY_GET_INTERFACE (self)->get_aps (self);
-
-	/* Fallback if the backend does not support get_aps */
-	ap = geoclue_connectivity_get_ap_mac (self);
-	if (ap == NULL)
-		return NULL;
-	ht = g_hash_table_new_full (g_str_hash, g_str_equal,
-				    (GDestroyNotify) g_free, NULL);
-	g_hash_table_insert (ht, ap, GINT_TO_POINTER (DEFAULT_DBM));
 	return NULL;
 }
 
Index: geoclue/src/connectivity.h
===================================================================
--- geoclue.orig/src/connectivity.h	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/connectivity.h	2011-12-29 16:40:38.926428900 +0900
@@ -1,6 +1,6 @@
 /*
  * Geoclue
- * geoclue-connectivity.h 
+ * geoclue-connectivity.h
  *
  * Author: Jussi Kukkonen <jku@o-hand.com>
  * Copyright 2007 by Garmin Ltd. or its subsidiaries
@@ -41,28 +41,22 @@
 
 struct _GeoclueConnectivityInterface {
 	GTypeInterface parent;
-	
+
 	/* signals */
 	void (* status_changed) (GeoclueConnectivity *self,
 	                         GeoclueNetworkStatus status);
-	
+
 	/* vtable */
 	int (*get_status) (GeoclueConnectivity *self);
-	GHashTable * (*get_aps) (GeoclueConnectivity *self);
 	char * (*get_ap_mac) (GeoclueConnectivity *self);
-	char * (*get_router_mac) (GeoclueConnectivity *self);
 };
 
 GType geoclue_connectivity_get_type (void);
 
-GeoclueConnectivity *geoclue_connectivity_new (void);
 
 GeoclueNetworkStatus geoclue_connectivity_get_status (GeoclueConnectivity *self);
 
 char *geoclue_connectivity_get_ap_mac (GeoclueConnectivity *self);
-char *geoclue_connectivity_get_router_mac (GeoclueConnectivity *self);
-
-GHashTable *geoclue_connectivity_get_aps (GeoclueConnectivity *self);
 
 void
 geoclue_connectivity_emit_status_changed (GeoclueConnectivity *self,
Index: geoclue/src/main.c
===================================================================
--- geoclue.orig/src/main.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/main.c	2011-12-29 16:40:38.930428900 +0900
@@ -27,7 +27,8 @@
 #endif
 
 #include <glib.h>
-#include <gio/gio.h>
+
+#include <gconf/gconf-client.h>
 
 #include <dbus/dbus-protocol.h>
 #include <dbus/dbus-glib.h>
@@ -37,141 +38,84 @@
 
 static GMainLoop *mainloop;
 static GHashTable *options;
-static GSettings *settings;
 static GcMaster *master;
 
 
-#define GEOCLUE_SCHEMA_NAME "org.freedesktop.Geoclue"
+#define GEOCLUE_GCONF_TOP "/apps/geoclue/master"
 #define GEOCLUE_MASTER_NAME "org.freedesktop.Geoclue.Master"
 
-static GValue *
-gvariant_value_to_value (GVariant *value)
-{
-	GValue *gvalue;
-	const GVariantType *type;
-
-	g_return_val_if_fail (value != NULL, NULL);
-	type = g_variant_get_type (value);
-
-	if (g_variant_type_is_subtype_of (type, G_VARIANT_TYPE_STRING)) {
-		const char *str;
-
-		gvalue = g_new0 (GValue, 1);
-		str = g_variant_get_string (value, NULL);
-
-		/* Don't add empty strings in the hashtable */
-		if (str != NULL && str[0] == '\0')
-			str = NULL;
-
-		g_value_init (gvalue, G_TYPE_STRING);
-		g_value_set_string (gvalue, str);
-	} else if (g_variant_type_is_subtype_of (type, G_VARIANT_TYPE_UINT32)) {
-		int i;
-
-		gvalue = g_new0 (GValue, 1);
-		i = g_variant_get_uint32 (value);
-		g_value_init (gvalue, G_TYPE_INT);
-		g_value_set_int (gvalue, i);
-	} else {
-		gvalue = NULL;
-		g_warning ("Value is of unknown type");
-	}
-
-	return gvalue;
-}
-
 static void
-debug_print_key (gboolean init,
-		 const char *key,
-		 GValue     *gvalue)
-{
-	const char *message;
-	char *string;
-
-	if (init)
-		message = "GSettings key '%s' initialised to '%s'";
-	else
-		message = "GSettings key '%s' changed to '%s'";
-
-	if (G_VALUE_TYPE (gvalue) == G_TYPE_STRING) {
-		string = g_value_dup_string (gvalue);
-	} else if (G_VALUE_TYPE (gvalue) == G_TYPE_INT) {
-		string = g_strdup_printf ("%d", g_value_get_int (gvalue));
-	} else {
+gconf_key_changed (GConfClient *client,
+		   guint cnxn_id,
+		   GConfEntry *entry,
+		   gpointer user_data)
+{
+	const char *key, *value;
+	GConfValue *v;
+
+	key = gconf_entry_get_key (entry);
+	v = gconf_entry_get_value (entry);
+	if (v->type != GCONF_VALUE_STRING)
 		return;
-	}
+	value = gconf_value_get_string (v);
 
-	g_message (message, key, string);
-	g_free (string);
-}
+	g_message ("gconf key changed %s", key);
 
-static void
-gsettings_key_changed (GSettings *settings,
-		       char *key,
-		       gpointer user_data)
-{
-	GVariant *v;
-	GValue *gvalue;
-
-	v = g_settings_get_value (settings, key);
-	gvalue = gvariant_value_to_value (v);
-	if (gvalue == NULL) {
-		g_variant_unref (v);
-		return;
-	}
+	/* Don't add empty strings in the hashtable */
+	if (value != NULL && value[0] == '\0')
+		value = NULL;
 
-	debug_print_key (FALSE, key, gvalue);
-
-	g_hash_table_insert (options, g_strdup (key), gvalue);
+	g_hash_table_insert (options, g_path_get_basename (key),
+			     g_strdup (value));
 
 	g_signal_emit_by_name (G_OBJECT (master), "options-changed", options);
 }
 
-static void
-free_gvalue (GValue *value)
-{
-	if (value == NULL)
-		return;
-	g_value_unset (value);
-	g_free (value);
-}
-
 static GHashTable *
 load_options (void)
 {
         GHashTable *ht = NULL;
-        guint i;
-        const char const * keys[] = {
-		"gps-baudrate",
-		"gps-device"
-	};
+        GConfClient *client = gconf_client_get_default ();
+        GSList *entries, *e;
+        GError *error = NULL;
+
+        gconf_client_add_dir (client, GEOCLUE_GCONF_TOP,
+        		      GCONF_CLIENT_PRELOAD_RECURSIVE, NULL);
+
+        entries = gconf_client_all_entries (client, GEOCLUE_GCONF_TOP, &error);
+        if (error != NULL) {
+                g_warning ("Error loading master options: %s", error->message);
+                g_error_free (error);
+                return NULL;
+        }
 
         /* Setup keys monitoring */
-        g_signal_connect (G_OBJECT (settings), "changed",
-			  G_CALLBACK (gsettings_key_changed), NULL);
-
-        ht = g_hash_table_new_full (g_str_hash, g_str_equal,
-				    g_free, (GDestroyNotify) free_gvalue);
+	gconf_client_notify_add (client, GEOCLUE_GCONF_TOP,
+				 (GConfClientNotifyFunc) gconf_key_changed,
+				 NULL, NULL, NULL);
 
+        ht = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
         g_print ("Master options:\n");
-        for (i = 0; i < G_N_ELEMENTS (keys); i++) {
-		GVariant *v;
-		GValue *gvalue;
-		const char *key = keys[i];
-
-		v = g_settings_get_value (settings, key);
-		gvalue = gvariant_value_to_value (v);
-
-		if (gvalue == NULL) {
-			g_variant_unref (v);
-			continue;
-		}
-
-		debug_print_key (TRUE, key, gvalue);
-
-                g_hash_table_insert (ht, g_strdup (key), gvalue);
-                g_variant_unref (v);
+        for (e = entries; e; e = e->next) {
+                GConfEntry *entry = e->data;
+                const char *key, *value;
+                GConfValue *v;
+
+                key = gconf_entry_get_key (entry);
+                v = gconf_entry_get_value (entry);
+                if (v->type != GCONF_VALUE_STRING)
+                	continue;
+                value = gconf_value_get_string (v);
+
+                if (value != NULL && value[0] == '\0')
+                	value = NULL;
+
+                g_print ("  %s = %s\n", key, value);
+                g_hash_table_insert (ht, g_path_get_basename (key),
+                                     g_strdup (value));
+                 gconf_entry_free (entry);
          }
+         g_slist_free (entries);
 
          return ht;
  }
@@ -218,12 +162,11 @@
 	}
 
         /* Load options */
-        settings = g_settings_new (GEOCLUE_SCHEMA_NAME);
         options = load_options ();
 
 	master = g_object_new (GC_TYPE_MASTER, NULL);
-	dbus_g_connection_register_g_object (conn, 
-					     "/org/freedesktop/Geoclue/Master", 
+	dbus_g_connection_register_g_object (conn,
+					     "/org/freedesktop/Geoclue/Master",
 					     G_OBJECT (master));
 
 	g_main_loop_run (mainloop);
Index: geoclue/src/master-provider.c
===================================================================
--- geoclue.orig/src/master-provider.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/master-provider.c	2011-12-29 16:40:38.926428900 +0900
@@ -3,7 +3,7 @@
  * master-provider.c - Provider object for master and master client
  *
  * Author: Jussi Kukkonen <jku@o-hand.com>
- * 
+ *
  * Copyright 2007-2008 by Garmin Ltd. or its subsidiaries
  *                2008 OpenedHand Ltd
  *
@@ -25,22 +25,22 @@
  */
 
 /**
- *  Provider object for GcMaster. Takes care of cacheing 
+ *  Provider object for GcMaster. Takes care of cacheing
  *  queried data.
- * 
+ *
  *  Should probably start/stop the actual providers as needed
  *  in the future
- *  
- *  Cache could also be used to save "stale" data for situations when 
- *  current data is not available (MasterClient api would have to 
+ *
+ *  Cache could also be used to save "stale" data for situations when
+ *  current data is not available (MasterClient api would have to
  *  have a "allowOldData" setting)
- * 
- * TODO: 
+ *
+ * TODO:
  * 	figure out what to do if get_* returns GEOCLUE_ERROR_NOT_AVAILABLE.
  * 	Should try again, but when?
- * 
+ *
  * 	implement velocity
- * 
+ *
  * 	implement other (non-updating) ifaces
  **/
 
@@ -78,30 +78,30 @@
 typedef struct _GcMasterProviderPrivate {
 	char *name;
 	char *description;
-	
+
 	char *service;
 	char *path;
 	GcInterfaceFlags interfaces;
-	
+
 	GList *position_clients; /* list of clients currently using this provider */
 	GList *address_clients;
-	
+
 	GeoclueAccuracyLevel expected_accuracy;
-	
+
 	GeoclueResourceFlags required_resources;
 	GeoclueProvideFlags provides;
-	
+
 	GeoclueStatus master_status; /* net_status and status affect this */
 	GeoclueNetworkStatus net_status;
-	
+
 	GeoclueStatus status; /* cached status from actual provider */
-	
+
 	GeocluePosition *position;
 	GcPositionCache position_cache;
-	
+
 	GeoclueAddress *address;
 	GcAddressCache address_cache;
-	
+
 } GcMasterProviderPrivate;
 
 enum {
@@ -109,6 +109,7 @@
 	ACCURACY_CHANGED,
 	POSITION_CHANGED,
 	ADDRESS_CHANGED,
+	NMEA_CHANGED,
 	LAST_SIGNAL
 };
 static guint32 signals[LAST_SIGNAL] = {0, };
@@ -146,7 +147,7 @@
 gc_master_provider_get_provider (GcMasterProvider *master_provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (master_provider);
-	
+
 	if (priv->address) {
 		return GEOCLUE_PROVIDER (priv->address);
 	}
@@ -162,7 +163,7 @@
 	return (gc_master_provider_get_provider (master_provider) != NULL);
 }
 
-static void 
+static void
 gc_master_provider_handle_new_position_accuracy (GcMasterProvider *provider,
                                                  GeoclueAccuracy  *accuracy)
 {
@@ -170,7 +171,7 @@
 	GeoclueAccuracyLevel old_level;
 	GeoclueAccuracyLevel new_level = GEOCLUE_ACCURACY_LEVEL_NONE;
 	double new_hor_acc, new_vert_acc;
-	
+
 	geoclue_accuracy_get_details (priv->position_cache.accuracy,
 	                              &old_level, NULL, NULL);
 	if (accuracy) {
@@ -179,14 +180,14 @@
 	}
 	geoclue_accuracy_set_details (priv->position_cache.accuracy,
 	                              new_level, new_hor_acc, new_vert_acc);
-	
+
 	if (old_level != new_level) {
 		g_signal_emit (provider, signals[ACCURACY_CHANGED], 0,
 		               GC_IFACE_POSITION, new_level);
 	}
 }
 
-static void 
+static void
 gc_master_provider_handle_new_address_accuracy (GcMasterProvider *provider,
                                                 GeoclueAccuracy  *accuracy)
 {
@@ -194,7 +195,7 @@
 	GeoclueAccuracyLevel old_level;
 	GeoclueAccuracyLevel new_level = GEOCLUE_ACCURACY_LEVEL_NONE;
 	double new_hor_acc, new_vert_acc;
-	
+
 	geoclue_accuracy_get_details (priv->address_cache.accuracy,
 	                              &old_level, NULL, NULL);
 	if (accuracy) {
@@ -203,7 +204,7 @@
 	}
 	geoclue_accuracy_set_details (priv->address_cache.accuracy,
 	                              new_level, new_hor_acc, new_vert_acc);
-	
+
 	if (old_level != new_level) {
 		g_signal_emit (provider, signals[ACCURACY_CHANGED], 0,
 		               GC_IFACE_ADDRESS, new_level);
@@ -221,23 +222,23 @@
                                  GError                *error)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	priv->position_cache.timestamp = timestamp;
 	priv->position_cache.fields = fields;
 	priv->position_cache.latitude = latitude;
 	priv->position_cache.longitude = longitude;
 	priv->position_cache.altitude = altitude;
-	
+
 	copy_error (&priv->position_cache.error, error);
-	
-	/* emit accuracy-changed if needed, so masterclient can re-choose providers 
+
+	/* emit accuracy-changed if needed, so masterclient can re-choose providers
 	 * before we emit position-changed */
 	gc_master_provider_handle_new_position_accuracy (provider, accuracy);
-	
+
 	if (!error) {
-		g_signal_emit (provider, signals[POSITION_CHANGED], 0, 
-		               fields, timestamp, 
-		               latitude, longitude, altitude, 
+		g_signal_emit (provider, signals[POSITION_CHANGED], 0,
+		               fields, timestamp,
+		               latitude, longitude, altitude,
 		               priv->position_cache.accuracy);
 	}
 }
@@ -250,9 +251,9 @@
                                 GError           *error)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	priv->address_cache.timestamp = timestamp;
-	
+
 	g_hash_table_destroy (priv->address_cache.details);
 	if (details) {
 		priv->address_cache.details = geoclue_address_details_copy (details);
@@ -260,15 +261,15 @@
 		priv->address_cache.details = geoclue_address_details_new ();
 	}
 	copy_error (&priv->address_cache.error, error);
-	
-	/* emit accuracy-changed if needed, so masterclient can re-choose providers 
+
+	/* emit accuracy-changed if needed, so masterclient can re-choose providers
 	 * before we emit position-changed */
 	gc_master_provider_handle_new_address_accuracy (provider, accuracy);
-	
+
 	if (!error) {
-		g_signal_emit (provider, signals[ADDRESS_CHANGED], 0, 
-		               priv->address_cache.timestamp, 
-		               priv->address_cache.details, 
+		g_signal_emit (provider, signals[ADDRESS_CHANGED], 0,
+		               priv->address_cache.timestamp,
+		               priv->address_cache.details,
 		               priv->address_cache.accuracy);
 	}
 }
@@ -280,7 +281,7 @@
 {
 	GeoclueResourceFlags resources = GEOCLUE_RESOURCE_NONE;
 	int i;
-	
+
 	for (i = 0; flags[i]; i++) {
 		if (strcmp (flags[i], "RequiresNetwork") == 0) {
 			resources |= GEOCLUE_RESOURCE_NETWORK;
@@ -290,7 +291,7 @@
 			resources |= GEOCLUE_RESOURCE_GPS;
 		}
 	}
-	
+
 	return resources;
 }
 
@@ -299,7 +300,7 @@
 {
 	GeoclueProvideFlags provides = GEOCLUE_PROVIDE_NONE;
 	int i;
-	
+
 	for (i = 0; flags[i]; i++) {
 		if (strcmp (flags[i], "ProvidesUpdates") == 0) {
 			provides |= GEOCLUE_PROVIDE_UPDATES;
@@ -307,7 +308,7 @@
 			provides |= GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION;
 		}
 	}
-	
+
 	return provides;
 }
 
@@ -316,7 +317,7 @@
 {
 	GcInterfaceFlags ifaces = GC_IFACE_GEOCLUE;
 	int i;
-	
+
 	for (i = 0; strs[i]; i++) {
 		if (strcmp (strs[i], GEOCLUE_POSITION_INTERFACE_NAME) == 0) {
 			ifaces |= GC_IFACE_POSITION;
@@ -347,7 +348,7 @@
 		level = GEOCLUE_ACCURACY_LEVEL_DETAILED;
 	} else {
 		g_warning ("'%s' is not a recognised accuracy level value", str);
-	} 
+	}
 	return level;
 }
 
@@ -355,14 +356,14 @@
 gc_master_provider_handle_error (GcMasterProvider *provider, GError *error)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	g_assert (error);
-	
+
 	priv = GET_PRIVATE (provider);
 	g_debug ("%s handling error %d", priv->name, error->code);
-	
+
 	/* web service providers that are unavailable */
-	if (priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION && 
+	if (priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION &&
 	    error->code == GEOCLUE_ERROR_NOT_AVAILABLE) {
 		priv->master_status = GEOCLUE_STATUS_UNAVAILABLE;
 		/* TODO set timer to re-check availability */
@@ -375,9 +376,9 @@
 gc_master_provider_handle_status_change (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	GeoclueStatus new_master_status;
-	
+
 	/* calculate new master status */
 	if (priv->required_resources & GEOCLUE_RESOURCE_NETWORK ||
 	    priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION) {
@@ -400,47 +401,47 @@
 			default:
 				g_assert_not_reached ();
 		}
-		
+
 	} else {
 		new_master_status = priv->status;
 	}
-	
+
 	if (new_master_status != priv->master_status) {
 		priv->master_status = new_master_status;
-		
+
 		g_signal_emit (provider, signals[STATUS_CHANGED], 0, new_master_status);
 	}
 }
 
 
-static void 
+static void
 gc_master_provider_update_cache (GcMasterProvider *master_provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (master_provider);
-	
+
 	if ((!(priv->provides & GEOCLUE_PROVIDE_UPDATES)) ||
 	    (!gc_master_provider_get_provider (master_provider))) {
 		/* non-cacheable provider or provider not running */
 		return;
 	}
-	
+
 	g_debug ("%s: Updating cache ", priv->name);
 	priv->master_status = GEOCLUE_STATUS_ACQUIRING;
 	g_signal_emit (master_provider, signals[STATUS_CHANGED], 0, priv->master_status);
-	
+
 	if (priv->position) {
 		int timestamp;
 		double lat, lon, alt;
 		GeocluePositionFields fields;
 		GeoclueAccuracy *accuracy = NULL;
 		GError *error = NULL;
-		
+
 		fields = geoclue_position_get_position (priv->position,
 							&timestamp,
 							&lat, &lon, &alt,
-							&accuracy, 
+							&accuracy,
 							&error);
 		if (error){
 			g_warning ("Error updating position cache: %s", error->message);
@@ -451,13 +452,13 @@
 		                                 lat, lon, alt,
 		                                 accuracy, error);
 	}
-	
+
 	if (priv->address) {
 		int timestamp;
 		GHashTable *details = NULL;
 		GeoclueAccuracy *accuracy = NULL;
 		GError *error = NULL;
-		
+
 		if (!geoclue_address_get_address (priv->address,
 		                                  &timestamp,
 		                                  &details,
@@ -472,7 +473,7 @@
 		                                accuracy,
 		                                error);
 	}
-	
+
 	gc_master_provider_handle_status_change (master_provider);
 }
 
@@ -484,7 +485,7 @@
                          GcMasterProvider *master_provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (master_provider);
-	
+
 	priv->status = status;
 	gc_master_provider_handle_status_change (master_provider);
 }
@@ -499,7 +500,7 @@
                   GeoclueAccuracy      *accuracy,
                   GcMasterProvider     *provider)
 {
-	/* is there a situation when we'd need to check against cache 
+	/* is there a situation when we'd need to check against cache
 	 * if data has really changed? probably not */
 	gc_master_provider_set_position (provider,
 	                                 fields, timestamp,
@@ -514,7 +515,7 @@
                  GeoclueAccuracy  *accuracy,
                  GcMasterProvider *provider)
 {
-	/* is there a situation when we'd need to check against cache 
+	/* is there a situation when we'd need to check against cache
 	 * if data has really changed? probably not */
 	gc_master_provider_set_address (provider,
 	                                timestamp,
@@ -528,7 +529,7 @@
 finalize (GObject *object)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	geoclue_accuracy_free (priv->position_cache.accuracy);
 	geoclue_accuracy_free (priv->address_cache.accuracy);
 	if (priv->position_cache.error) {
@@ -537,15 +538,15 @@
 	if (priv->address_cache.error) {
 		g_error_free (priv->address_cache.error);
 	}
-	
+
 	g_free (priv->name);
 	g_free (priv->description);
 	g_free (priv->service);
 	g_free (priv->path);
-	
+
 	g_free (priv->position_clients);
 	g_free (priv->address_clients);
-	
+
 	G_OBJECT_CLASS (gc_master_provider_parent_class)->finalize (object);
 }
 
@@ -553,12 +554,12 @@
 dispose (GObject *object)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (object);
-	
+
 	if (priv->position) {
 		g_object_unref (priv->position);
 		priv->position = NULL;
 	}
-	
+
 	if (priv->address) {
 		g_object_unref (priv->address);
 		priv->address = NULL;
@@ -567,7 +568,7 @@
 		g_hash_table_destroy (priv->address_cache.details);
 		priv->address_cache.details = NULL;
 	}
-	
+
 	G_OBJECT_CLASS (gc_master_provider_parent_class)->dispose (object);
 }
 
@@ -575,17 +576,17 @@
 gc_master_provider_class_init (GcMasterProviderClass *klass)
 {
 	GObjectClass *o_class = (GObjectClass *) klass;
-	
+
 	o_class->finalize = finalize;
 	o_class->dispose = dispose;
-	
+
 	g_type_class_add_private (klass, sizeof (GcMasterProviderPrivate));
-	
+
 	signals[STATUS_CHANGED] = g_signal_new ("status-changed",
 						  G_TYPE_FROM_CLASS (klass),
 						  G_SIGNAL_RUN_FIRST |
 						  G_SIGNAL_NO_RECURSE,
-						  G_STRUCT_OFFSET (GcMasterProviderClass, status_changed), 
+						  G_STRUCT_OFFSET (GcMasterProviderClass, status_changed),
 						  NULL, NULL,
 						  g_cclosure_marshal_VOID__INT,
 						  G_TYPE_NONE, 1,
@@ -594,7 +595,7 @@
 						  G_TYPE_FROM_CLASS (klass),
 						  G_SIGNAL_RUN_FIRST |
 						  G_SIGNAL_NO_RECURSE,
-						  G_STRUCT_OFFSET (GcMasterProviderClass, accuracy_changed), 
+						  G_STRUCT_OFFSET (GcMasterProviderClass, accuracy_changed),
 						  NULL, NULL,
 						  geoclue_marshal_VOID__INT_INT,
 						  G_TYPE_NONE, 2,
@@ -603,7 +604,7 @@
 						  G_TYPE_FROM_CLASS (klass),
 						  G_SIGNAL_RUN_FIRST |
 						  G_SIGNAL_NO_RECURSE,
-						  G_STRUCT_OFFSET (GcMasterProviderClass, position_changed), 
+						  G_STRUCT_OFFSET (GcMasterProviderClass, position_changed),
 						  NULL, NULL,
 						  geoclue_marshal_VOID__INT_INT_DOUBLE_DOUBLE_DOUBLE_BOXED,
 						  G_TYPE_NONE, 6,
@@ -614,11 +615,11 @@
 						 G_TYPE_FROM_CLASS (klass),
 						 G_SIGNAL_RUN_FIRST |
 						 G_SIGNAL_NO_RECURSE,
-						 G_STRUCT_OFFSET (GcMasterProviderClass, address_changed), 
+						 G_STRUCT_OFFSET (GcMasterProviderClass, address_changed),
 						 NULL, NULL,
 						 geoclue_marshal_VOID__INT_BOXED_BOXED,
 						 G_TYPE_NONE, 3,
-						 G_TYPE_INT, 
+						 G_TYPE_INT,
 						 G_TYPE_POINTER,
 						 G_TYPE_POINTER);
 }
@@ -627,19 +628,19 @@
 gc_master_provider_init (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	priv->position_clients = NULL;
 	priv->address_clients = NULL;
-	
+
 	priv->master_status = GEOCLUE_STATUS_UNAVAILABLE;
-	
+
 	priv->position = NULL;
-	priv->position_cache.accuracy = 
+	priv->position_cache.accuracy =
 		geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0 ,0);
 	priv->position_cache.error = NULL;
-	
+
 	priv->address = NULL;
-	priv->address_cache.accuracy = 
+	priv->address_cache.accuracy =
 		geoclue_accuracy_new (GEOCLUE_ACCURACY_LEVEL_NONE, 0 ,0);
 	priv->address_cache.details = geoclue_address_details_new ();
 	priv->address_cache.error = NULL;
@@ -654,15 +655,15 @@
 	int time;
 	double lat, lon, alt;
 	GError *error = NULL;
-	
+
 	priv = GET_PRIVATE (provider);
-	
-	
+
+
 	g_print ("     Position Information:\n");
 	g_print ("     ---------------------\n");
-	
+
 	fields = gc_master_provider_get_position (provider,
-	                                          &time, 
+	                                          &time,
 	                                          &lat, &lon, &alt,
 	                                          NULL, &error);
 	if (error) {
@@ -677,7 +678,7 @@
 		 fields & GEOCLUE_POSITION_FIELDS_LONGITUDE ? "" : "(not set)");
 	g_print ("       Altitude: %.2f %s\n", alt,
 		 fields & GEOCLUE_POSITION_FIELDS_ALTITUDE ? "" : "(not set)");
-	
+
 }
 
 static void
@@ -692,11 +693,11 @@
 	int time;
 	GHashTable *details;
 	GError *error = NULL;
-	
+
 	g_print ("     Address Information:\n");
 	g_print ("     --------------------\n");
 	if (!gc_master_provider_get_address (provider,
-	                                     &time, 
+	                                     &time,
 	                                     &details,
 	                                     NULL, &error)) {
 		g_print ("      Error: %s", error->message);
@@ -705,14 +706,14 @@
 	}
 	g_print ("       Timestamp: %d\n", time);
 	g_hash_table_foreach (details, (GHFunc)dump_address_key_and_value, NULL);
-	
+
 }
 
 static void
 gc_master_provider_dump_required_resources (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (provider);
 	g_print ("   Requires\n");
 	if (priv->required_resources & GEOCLUE_RESOURCE_GPS) {
@@ -728,7 +729,7 @@
 gc_master_provider_dump_provides (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (provider);
 	g_print ("   Provides\n");
 	if (priv->provides & GEOCLUE_PROVIDE_UPDATES) {
@@ -743,20 +744,20 @@
 gc_master_provider_dump_provider_details (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (provider);
 	g_print ("\n   Name - %s\n", priv->name);
 	g_print ("   Description - %s\n", priv->description);
 	g_print ("   Service - %s\n", priv->service);
 	g_print ("   Path - %s\n", priv->path);
 	g_print ("   Accuracy level - %d\n", priv->expected_accuracy);
-	g_print ("   Provider is currently %srunning, status %d\n", 
+	g_print ("   Provider is currently %srunning, status %d\n",
 	         gc_master_provider_get_provider (master_provider) ? "" : "not ",
 	         priv->master_status);
 	gc_master_provider_dump_required_resources (provider);
 	gc_master_provider_dump_provides (provider);
-	
-	
+
+
 	if (priv->interfaces & GC_IFACE_POSITION) {
 		g_print ("   Interface - Position\n");
 		gc_master_provider_dump_position (provider);
@@ -774,9 +775,9 @@
 	GcMasterProviderPrivate *priv = GET_PRIVATE (master_provider);
 	GeoclueProvider *geoclue;
 	GError *error = NULL;
-	
+
 	geoclue = gc_master_provider_get_provider (master_provider);
-	
+
 	if (!geoclue_provider_set_options (geoclue,
 	                                   geoclue_get_main_options (),
 	                                   &error)) {
@@ -784,20 +785,20 @@
 		g_error_free (error);
 		return FALSE;
 	}
-	
+
 	/* priv->name has been read from .provider-file earlier...
 	 * could ask the provider anyway, just to be consistent */
-	if (!geoclue_provider_get_provider_info (geoclue, NULL, 
+	if (!geoclue_provider_get_provider_info (geoclue, NULL,
 	                                         &priv->description, &error)) {
 		g_warning ("Error getting provider info: %s\n", error->message);
 		g_error_free (error);
 		return FALSE;
 	}
-	
+
 	g_signal_connect (G_OBJECT (geoclue), "status-changed",
 			  G_CALLBACK (provider_status_changed), master_provider);
-	
-	
+
+
 	if (!geoclue_provider_get_status (geoclue, &priv->status, &error)) {
 		g_warning ("Error getting provider status: %s\n", error->message);
 		g_error_free (error);
@@ -810,35 +811,35 @@
 gc_master_provider_initialize_interfaces (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (provider);
-	
+
 	if (priv->interfaces <= GC_IFACE_GEOCLUE) {
 		g_warning ("No interfaces defined for %s", priv->name);
 		return FALSE;
 	}
-	
+
 	if (priv->interfaces & GC_IFACE_POSITION) {
 		g_assert (priv->position == NULL);
-		
-		priv->position = geoclue_position_new (priv->service, 
+
+		priv->position = geoclue_position_new (priv->service,
 		                                       priv->path);
 		g_signal_connect (G_OBJECT (priv->position), "position-changed",
 		                  G_CALLBACK (position_changed), provider);
 	}
 	if (priv->interfaces & GC_IFACE_ADDRESS) {
 		g_assert (priv->address == NULL);
-		
-		priv->address = geoclue_address_new (priv->service, 
+
+		priv->address = geoclue_address_new (priv->service,
 		                                     priv->path);
 		g_signal_connect (G_OBJECT (priv->address), "address-changed",
 		                  G_CALLBACK (address_changed), provider);
 	}
-	
+
 	if (!gc_master_provider_initialize_geoclue (provider)) {
 		return FALSE;
 	}
-	
+
 	return TRUE;
 }
 
@@ -846,10 +847,14 @@
 static gboolean
 gc_master_provider_initialize (GcMasterProvider *provider)
 {
+	GcMasterProviderPrivate *priv;
+
+	priv = GET_PRIVATE (provider);
+
 	if (!gc_master_provider_initialize_interfaces (provider)) {
 		return FALSE;
 	}
-	
+
 	gc_master_provider_update_cache (provider);
 #if DEBUG_INFO
 	gc_master_provider_dump_provider_details (provider);
@@ -861,7 +866,7 @@
 gc_master_provider_deinitialize (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	if (priv->position) {
 		g_object_unref (priv->position);
 		priv->position = NULL;
@@ -874,14 +879,14 @@
 }
 
 static void
-network_status_changed (gpointer *connectivity, 
-                        GeoclueNetworkStatus status, 
+network_status_changed (gpointer *connectivity,
+                        GeoclueNetworkStatus status,
                         GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv;
-	
+
 	priv = GET_PRIVATE (provider);
-	
+
 	priv->net_status = status;
 	/* update connection-cacheable providers */
 	if (status == GEOCLUE_CONNECTIVITY_ONLINE &&
@@ -909,7 +914,7 @@
 
 /* public methods (for GcMaster and GcMasterClient) */
 
-/* Loads provider details from 'filename' */ 
+/* Loads provider details from 'filename' */
 GcMasterProvider *
 gc_master_provider_new (const char *filename,
                         GeoclueConnectivity *connectivity)
@@ -919,11 +924,11 @@
 	GKeyFile *keyfile;
 	GError *error = NULL;
 	gboolean ret;
-	char *accuracy_str; 
+	char *accuracy_str;
 	char **flags, **interfaces;
-	
+
 	keyfile = g_key_file_new ();
-	ret = g_key_file_load_from_file (keyfile, filename, 
+	ret = g_key_file_load_from_file (keyfile, filename,
 	                                 G_KEY_FILE_NONE, &error);
 	if (ret == FALSE) {
 		g_warning ("Error loading %s: %s", filename, error->message);
@@ -931,31 +936,31 @@
 		g_key_file_free (keyfile);
 		return NULL;
 	}
-	
+
 	provider = g_object_new (GC_TYPE_MASTER_PROVIDER, NULL);
 	priv = GET_PRIVATE (provider);
-	
+
 	priv->name = g_key_file_get_value (keyfile, "Geoclue Provider",
 	                                   "Name", NULL);
 	priv->service = g_key_file_get_value (keyfile, "Geoclue Provider",
 	                                      "Service", NULL);
 	priv->path = g_key_file_get_value (keyfile, "Geoclue Provider",
 	                                   "Path", NULL);
-	
+
 	accuracy_str = g_key_file_get_value (keyfile, "Geoclue Provider",
 	                                     "Accuracy", NULL);
 	priv->expected_accuracy = parse_accuracy_string (accuracy_str);
 	if (accuracy_str){
 		g_free (accuracy_str);
 	}
-	
+
 	/* set cached accuracies to a default value */
 	geoclue_accuracy_set_details (priv->position_cache.accuracy,
 	                              priv->expected_accuracy, 0.0, 0.0);
 	geoclue_accuracy_set_details (priv->address_cache.accuracy,
 	                              priv->expected_accuracy, 0.0, 0.0);
 
-	
+
 	flags = g_key_file_get_string_list (keyfile, "Geoclue Provider",
 	                                    "Requires", NULL, NULL);
 	if (flags != NULL) {
@@ -964,7 +969,7 @@
 	} else {
 		priv->required_resources = GEOCLUE_RESOURCE_NONE;
 	}
-	
+
 	flags = g_key_file_get_string_list (keyfile, "Geoclue Provider",
 	                                    "Provides", NULL, NULL);
 	if (flags != NULL) {
@@ -974,30 +979,30 @@
 		priv->provides = GEOCLUE_PROVIDE_NONE;
 	}
 
-    if (!connectivity && 
+    if (!connectivity &&
          (priv->required_resources & GEOCLUE_RESOURCE_NETWORK)) {
 	    priv->provides &= ~GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION;
 		priv->net_status = GEOCLUE_CONNECTIVITY_ONLINE;
 		priv->status = GEOCLUE_STATUS_AVAILABLE;
         gc_master_provider_handle_status_change (provider);
     }
-	
-	if (connectivity && 
+
+	if (connectivity &&
 	    (priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION)) {
-		
-		/* we have network status events: mark network provider 
+
+		/* we have network status events: mark network provider
 		 * with update flag, set the callback and set use_cache */
 		priv->provides |= GEOCLUE_PROVIDE_UPDATES;
-		
-		g_signal_connect (connectivity, 
+
+		g_signal_connect (connectivity,
 		                  "status-changed",
-		                  G_CALLBACK (network_status_changed), 
+		                  G_CALLBACK (network_status_changed),
 		                  provider);
 		priv->net_status = geoclue_connectivity_get_status (connectivity);
 	}
-	
+
 	priv->interfaces = GC_IFACE_GEOCLUE;
-	interfaces = g_key_file_get_string_list (keyfile, 
+	interfaces = g_key_file_get_string_list (keyfile,
 	                                         "Geoclue Provider",
 	                                         "Interfaces",
 	                                         NULL, NULL);
@@ -1005,7 +1010,7 @@
 		priv->interfaces = parse_interface_strings (interfaces);
 		g_strfreev (interfaces);
 	}
-	
+
 	if (priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION &&
 	    priv->net_status == GEOCLUE_CONNECTIVITY_ONLINE) {
 		/* do this as idle so we can return without waiting for http queries */
@@ -1014,26 +1019,26 @@
 	return provider;
 }
 
-/* client calls this when it wants to use the provider. 
-   Returns true if provider was actually started, and 
-   client should assume accuracy has changed. 
+/* client calls this when it wants to use the provider.
+   Returns true if provider was actually started, and
+   client should assume accuracy has changed.
    Returns false if provider was not started (it was either already
    running or starting the provider failed). */
-gboolean 
-gc_master_provider_subscribe (GcMasterProvider *provider, 
+gboolean
+gc_master_provider_subscribe (GcMasterProvider *provider,
                               gpointer          client,
                               GcInterfaceFlags  interface)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
 	gboolean started = FALSE;
-	
+
 	/* decide wether to run initialize or not */
 	if (!gc_master_provider_is_running (provider)) {
 		if (!(priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION)) {
 			started = gc_master_provider_initialize (provider);
 		}
 	}
-	
+
 	/* add subscription */
 	if (interface & GC_IFACE_POSITION) {
 		if (!g_list_find (priv->position_clients, client)) {
@@ -1045,7 +1050,7 @@
 			priv->address_clients = g_list_prepend (priv->address_clients, client);
 		}
 	}
-	
+
 	return started;
 }
 
@@ -1056,20 +1061,20 @@
                                 GcInterfaceFlags  interface)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	if (interface & GC_IFACE_POSITION) {
 		priv->position_clients = g_list_remove (priv->position_clients, client);
 	}
 	if (interface & GC_IFACE_ADDRESS) {
 		priv->address_clients = g_list_remove (priv->address_clients, client);
 	}
-	
+
 	if (!priv->position_clients &&
 	    !priv->address_clients) {
 		/* no one is using this provider, shutdown... */
 		/* not clearing cached accuracies on purpose */
 		g_debug ("%s without clients", priv->name);
-		
+
 		/* gc_master_provider_deinitialize (provider); */
 	}
 }
@@ -1085,10 +1090,10 @@
                                  GError          **error)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
-	g_assert (priv->position || 
+
+	g_assert (priv->position ||
 	          priv->provides & GEOCLUE_PROVIDE_CACHEABLE_ON_CONNECTION);
-	
+
 	if (priv->provides & GEOCLUE_PROVIDE_UPDATES) {
 		if (timestamp != NULL) {
 			*timestamp = priv->position_cache.timestamp;
@@ -1113,15 +1118,15 @@
 	} else {
 		return geoclue_position_get_position (priv->position,
 		                                      timestamp,
-		                                      latitude, 
-		                                      longitude, 
+		                                      latitude,
+		                                      longitude,
 		                                      altitude,
-		                                      accuracy, 
+		                                      accuracy,
 		                                      error);
 	}
 }
 
-gboolean 
+gboolean
 gc_master_provider_get_address (GcMasterProvider  *provider,
                                 int               *timestamp,
                                 GHashTable       **details,
@@ -1130,7 +1135,7 @@
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
 	if (priv->provides & GEOCLUE_PROVIDE_UPDATES) {
-		
+
 		if (timestamp != NULL) {
 			*timestamp = priv->address_cache.timestamp;
 		}
@@ -1149,8 +1154,8 @@
 		g_assert (priv->address);
 		return geoclue_address_get_address (priv->address,
 		                                    timestamp,
-		                                    details, 
-		                                    accuracy, 
+		                                    details,
+		                                    accuracy,
 		                                    error);
 	}
 }
@@ -1165,19 +1170,19 @@
 	GcMasterProviderPrivate *priv;
 	GcInterfaceFlags supported_ifaces;
 	GeoclueProvideFlags required_flags = GEOCLUE_PROVIDE_NONE;
-	
+
 	priv = GET_PRIVATE (provider);
-	
+
 	if (need_update) {
 		required_flags |= GEOCLUE_PROVIDE_UPDATES;
 	}
-	
+
 	supported_ifaces = priv->interfaces;
-	
+
 	/* provider must provide all that is required and
 	 * cannot require a resource that is not allowed */
 	/* TODO: really, we need to change some of those terms... */
-	
+
 	return (((supported_ifaces & iface_type) == iface_type) &&
 	        ((priv->provides & required_flags) == required_flags) &&
 	        (priv->expected_accuracy >= min_accuracy) &&
@@ -1189,9 +1194,9 @@
 {
 	GeoclueProvider *geoclue;
 	GError *error = NULL;
-	
+
 	geoclue = gc_master_provider_get_provider (provider);
-	
+
 	if (!geoclue_provider_set_options (geoclue,
 	                                   geoclue_get_main_options (),
 	                                   &error)) {
@@ -1200,20 +1205,20 @@
 	}
 }
 
-GeoclueStatus 
+GeoclueStatus
 gc_master_provider_get_status (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return priv->master_status;
 }
 
-GeoclueAccuracyLevel 
+GeoclueAccuracyLevel
 gc_master_provider_get_accuracy (GcMasterProvider *provider, GcInterfaceFlags iface)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
 	GeoclueAccuracyLevel acc_level;
-	
+
 	switch (iface) {
 		case GC_IFACE_POSITION:
 			geoclue_accuracy_get_details (priv->position_cache.accuracy,
@@ -1230,49 +1235,49 @@
 }
 
 /*returns a reference, but is not meant for editing...*/
-char * 
+char *
 gc_master_provider_get_name (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return priv->name;
 }
-char * 
+char *
 gc_master_provider_get_description (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return priv->description;
 }
-char * 
+char *
 gc_master_provider_get_service (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return priv->service;
 }
-char * 
+char *
 gc_master_provider_get_path (GcMasterProvider *provider)
 {
 	GcMasterProviderPrivate *priv = GET_PRIVATE (provider);
-	
+
 	return priv->path;
 }
 
 /* GCompareDataFunc for sorting providers by accuracy and required resources */
 int
-gc_master_provider_compare (GcMasterProvider *a, 
+gc_master_provider_compare (GcMasterProvider *a,
                             GcMasterProvider *b,
                             GcInterfaceAccuracy *iface_min_accuracy)
 {
 	int diff;
 	GeoclueAccuracy *acc_a, *acc_b;
 	GeoclueAccuracyLevel level_a, level_b, min_level;
-	
-	
+
+
 	GcMasterProviderPrivate *priv_a = GET_PRIVATE (a);
 	GcMasterProviderPrivate *priv_b = GET_PRIVATE (b);
-	
+
 	/* get the current accuracylevels */
 	switch (iface_min_accuracy->interface) {
 		case GC_IFACE_POSITION:
@@ -1287,12 +1292,12 @@
 			g_warning("iface: %d", iface_min_accuracy->interface);
 			g_assert_not_reached ();
 	}
-	
+
 
 	geoclue_accuracy_get_details (acc_a, &level_a, NULL, NULL);
 	geoclue_accuracy_get_details (acc_b, &level_b, NULL, NULL);
 	min_level = iface_min_accuracy->accuracy_level;
-	
+
 	/* sort by resource requirements and accuracy, but only if both
 	 * providers meet the minimum accuracy requirement  */
 	if ((level_b >= min_level) &&
@@ -1303,7 +1308,7 @@
 		}
 		return level_b - level_a;
 	}
-	
+
 	/* one or both do not meet req's, sort by accuracy */
 	return level_b - level_a;
 }
Index: geoclue/src/master.c
===================================================================
--- geoclue.orig/src/master.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/src/master.c	2011-12-29 16:40:38.926428900 +0900
@@ -37,10 +37,6 @@
 #else
 #ifdef HAVE_CONIC
 #include "connectivity-conic.h"
-#else
-#ifdef HAVE_CONNMAN
-#include "connectivity-connman.h"
-#endif
 #endif
 #endif
 
@@ -75,7 +71,7 @@
 	client = g_object_new (GC_TYPE_MASTER_CLIENT, NULL);
 	dbus_g_connection_register_g_object (master->connection, path,
 					     G_OBJECT (client));
-	
+
 	if (object_path) {
 		*object_path = path;
 	}
@@ -92,7 +88,7 @@
 						  G_TYPE_FROM_CLASS (klass),
 						  G_SIGNAL_RUN_FIRST |
 						  G_SIGNAL_NO_RECURSE,
-						  G_STRUCT_OFFSET (GcMasterClass, options_changed), 
+						  G_STRUCT_OFFSET (GcMasterClass, options_changed),
 						  NULL, NULL,
 						  g_cclosure_marshal_VOID__BOXED,
 						  G_TYPE_NONE, 1,
@@ -105,15 +101,15 @@
                             const char *filename)
 {
 	GcMasterProvider *provider;
-	
-	provider = gc_master_provider_new (filename, 
+
+	provider = gc_master_provider_new (filename,
 	                                   master->connectivity);
-	
+
 	if (!provider) {
 		g_warning ("Loading from %s failed", filename);
 		return;
 	}
-	
+
 	providers = g_list_prepend (providers, provider);
 }
 
@@ -152,11 +148,11 @@
 			continue;
 		}
 
-		fullname = g_build_filename (GEOCLUE_PROVIDERS_DIR, 
+		fullname = g_build_filename (GEOCLUE_PROVIDERS_DIR,
 					     filename, NULL);
 		gc_master_add_new_provider (master, fullname);
 		g_free (fullname);
-		
+
 		filename = g_dir_read_name (dir);
 	}
 
@@ -167,16 +163,23 @@
 gc_master_init (GcMaster *master)
 {
 	GError *error = NULL;
-	
-	
+
+
 	master->connection = dbus_g_bus_get (GEOCLUE_DBUS_BUS, &error);
 	if (master->connection == NULL) {
-		g_warning ("Could not get %s: %s", GEOCLUE_DBUS_BUS, 
+		g_warning ("Could not get %s: %s", GEOCLUE_DBUS_BUS,
 			   error->message);
 		g_error_free (error);
 	}
-	
-	master->connectivity = geoclue_connectivity_new ();
+
+	master->connectivity = NULL;
+#ifdef HAVE_NETWORK_MANAGER
+	master->connectivity = GEOCLUE_CONNECTIVITY (g_object_new (GEOCLUE_TYPE_NETWORKMANAGER, NULL));
+#else
+#ifdef HAVE_CONIC
+	master->connectivity = GEOCLUE_CONNECTIVITY (g_object_new (GEOCLUE_TYPE_CONIC, NULL));
+#endif
+#endif
 
 	gc_master_load_providers (master);
 }
@@ -190,22 +193,22 @@
                          GError              **error)
 {
 	GList *l, *p = NULL;
-	
+
 	if (providers == NULL) {
 		return NULL;
 	}
-	
+
 	for (l = providers; l; l = l->next) {
 		GcMasterProvider *provider = l->data;
-		
+
 		if (gc_master_provider_is_good (provider,
-		                                iface_type, 
-		                                min_accuracy, 
-		                                can_update, 
+		                                iface_type,
+		                                min_accuracy,
+		                                can_update,
 		                                allowed)) {
 			p = g_list_prepend (p, provider);
 		}
 	}
-	
+
 	return p;
 }
Index: geoclue/test/Makefile.am
===================================================================
--- geoclue.orig/test/Makefile.am	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/test/Makefile.am	2011-12-29 16:40:38.930428900 +0900
@@ -1,6 +1,6 @@
 if HAVE_GTK
 
-noinst_PROGRAMS = geoclue-test-gui
+bin_PROGRAMS = geoclue-test-gui
 
 geoclue_test_gui_LDADD = \
 	$(GTK_LIBS) \
Index: geoclue/test/geoclue-test-gui.c
===================================================================
--- geoclue.orig/test/geoclue-test-gui.c	2011-12-29 16:41:40.362430014 +0900
+++ geoclue/test/geoclue-test-gui.c	2011-12-29 16:40:38.930428900 +0900
@@ -3,7 +3,7 @@
  * client-test-gui.c - Geoclue Test GUI
  *
  * Authors: Jussi Kukkonen <jku@linux.intel.com>
- * 
+ *
  * Copyright 2008 OpenedHand Ltd
  *           2008 Intel Corporation
  *
@@ -66,19 +66,19 @@
 
 typedef struct {
 	GObject parent;
-	
+
 	GtkWidget *window;
 	GtkTextBuffer *buffer;
-	
+
 	GeoclueMasterClient *client;
 	char *master_client_path;
 	GeoclueAccuracyLevel master_accuracy;
 	GeoclueResourceFlags master_resources;
-	
+
 	GtkListStore *position_store;
 	GList *position_providers; /* PositionProviders, first one is master */
-	
-	GtkListStore *address_store; 
+
+	GtkListStore *address_store;
 	GList *address_providers; /* AddressProviders, first one is master */
 } GeoclueTestGui;
 
@@ -92,7 +92,7 @@
 static void
 geoclue_test_gui_dispose (GObject *object)
 {
-	
+
 	G_OBJECT_CLASS (geoclue_test_gui_parent_class)->dispose (object);
 }
 
@@ -101,7 +101,7 @@
 geoclue_test_gui_class_init (GeoclueTestGuiClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-	
+
 	object_class->dispose = geoclue_test_gui_dispose;
 }
 
@@ -114,16 +114,16 @@
 	time_t rawtime;
 	struct tm *timeinfo;
 	char time_buffer [20];
-	
+
 	time (&rawtime);
 	timeinfo = localtime (&rawtime);
-	
+
 	strftime (time_buffer, 19, "%X", timeinfo);
 	line = g_strdup_printf ("%s: %s\n", time_buffer, message);
-	
+
 	gtk_text_buffer_get_end_iter (gui->buffer, &iter);
 	gtk_text_buffer_insert (gui->buffer, &iter, line, -1);
-	
+
 	g_free (line);
 }
 
@@ -132,10 +132,10 @@
 {
 	GeoclueProvider *p = NULL;
 	gboolean valid;
-	
+
 	g_assert (model);
 	g_assert (provider);
-	
+
 	valid = gtk_tree_model_get_iter_first (model, iter);
 	while (valid) {
 		gtk_tree_model_get (model, iter,
@@ -144,10 +144,10 @@
 		if (p == provider) {
 			return TRUE;
 		}
-		
+
 		valid = gtk_tree_model_iter_next (model, iter);
 	}
-	
+
 	return FALSE;
 }
 
@@ -155,9 +155,9 @@
 update_address (GeoclueTestGui *gui, GeoclueAddress *address, GHashTable *details)
 {
 	GtkTreeIter iter;
-	
+
 	g_assert (details);
-	
+
 	if (get_matching_tree_iter (GTK_TREE_MODEL (gui->address_store),
 	                            GEOCLUE_PROVIDER (address),
 	                            &iter)) {
@@ -175,11 +175,11 @@
 
 
 static void
-update_position (GeoclueTestGui *gui, GeocluePosition *position, 
+update_position (GeoclueTestGui *gui, GeocluePosition *position,
                  double lat, double lon, double alt)
 {
 	GtkTreeIter iter;
-	
+
 	if (get_matching_tree_iter (GTK_TREE_MODEL (gui->position_store),
 	                            GEOCLUE_PROVIDER (position),
 	                            &iter)) {
@@ -216,53 +216,24 @@
 	update_position (gui, position, latitude, longitude, altitude);
 }
 
-typedef struct {
-	GeoclueTestGui *gui;
-	char *name;
-} cb_data;
-
-static void 
-position_callback (GeocluePosition *position,
-                   GeocluePositionFields fields,
-                   int timestamp,
-                   double lat, double lon, double alt,
-                   GeoclueAccuracy *accuracy,
-                   GError *error,
-                   cb_data *data)
-{
-	if (error) {
-		g_warning ("Error getting position from %s: %s\n", data->name, error->message);
-		g_error_free (error);
-		lat = lon = alt = 0.0/0.0;
-	}
-
-	update_position (data->gui, position, lat, lon, alt);
-
-	g_free (data->name);
-	g_free (data);
-}
-
 static void
 address_callback (GeoclueAddress *address,
                   int timestamp,
                   GHashTable *details,
                   GeoclueAccuracy *accuracy,
                   GError *error,
-                  cb_data *data)
+                  gpointer userdata)
 {
 	if (error) {
-		g_warning ("Error getting address for %s: %s\n", data->name, error->message);
+		g_warning ("Error getting address: %s\n", error->message);
 		g_error_free (error);
 		details = geoclue_address_details_new ();
 	}
 
-	update_address (data->gui, address, details);
-
-	g_free (data->name);
-	g_free (data);
+	update_address (GEOCLUE_TEST_GUI (userdata), address, details);
 }
 
-static void 
+static void
 info_callback (GeoclueProvider *provider,
                char *name,
                char *description,
@@ -271,14 +242,13 @@
 {
 	GtkTreeIter iter;
 	GeoclueTestGui *gui = GEOCLUE_TEST_GUI (userdata);
-	cb_data *data;
-	
+
 	if (error) {
 		g_warning ("Error getting provider info: %s\n", error->message);
 		g_error_free (error);
 		return;
 	}
-	
+
 	if (get_matching_tree_iter (GTK_TREE_MODEL (gui->address_store),
 	                            provider,
 	                            &iter)) {
@@ -288,15 +258,8 @@
 					    COL_ADDRESS_PROVIDER_NAME, name,
 					    -1);
 		}
-
-		data = g_new0 (cb_data, 1);
-		data->gui = gui;
-		data->name = g_strdup (name);
-		geoclue_address_get_address_async (GEOCLUE_ADDRESS (provider),
-	                                     (GeoclueAddressCallback)address_callback,
-	                                     data);
 	}
-	
+
 	if (get_matching_tree_iter (GTK_TREE_MODEL (gui->position_store),
 	                            provider,
 	                            &iter)) {
@@ -306,24 +269,17 @@
 			                    COL_POSITION_PROVIDER_NAME, name,
 			                    -1);
 		}
-
-		data = g_new0 (cb_data, 1);
-		data->gui = gui;
-		data->name = g_strdup (name);
-		geoclue_position_get_position_async (GEOCLUE_POSITION (provider),
-	                                       (GeocluePositionCallback)position_callback,
-	                                       data);
 	}
 }
 
-static void 
+static void
 add_to_address_store (GeoclueTestGui *gui, GeoclueAddress *address, gboolean is_master)
 {
 	GtkTreeIter iter;
-	
+
 	g_assert (gui->address_store);
 	g_assert (address);
-	
+
 	if (is_master) {
 		/* master is already on the first line */
 		gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->address_store), &iter);
@@ -334,14 +290,15 @@
 	                    COL_ADDRESS_PROVIDER, address,
 	                    COL_ADDRESS_IS_MASTER, is_master,
 	                    -1);
-	
+
 	g_signal_connect (G_OBJECT (address), "address-changed",
 				G_CALLBACK (address_changed), gui);
-	
-	/* callback will call get_address */
-	geoclue_provider_get_provider_info_async (GEOCLUE_PROVIDER (address), 
+
+	geoclue_provider_get_provider_info_async (GEOCLUE_PROVIDER (address),
 	                                          info_callback,
 	                                          gui);
+	geoclue_address_get_address_async (address, address_callback, gui);
+
 }
 
 static gboolean
@@ -352,26 +309,26 @@
 	GKeyFile *keyfile;
 	gboolean ret;
 	GError *error;
-	
+
 	filename = g_dir_read_name (dir);
 	if (!filename) {
 		return FALSE;
 	}
-	
-	fullname = g_build_filename (GEOCLUE_PROVIDERS_DIR, 
+
+	fullname = g_build_filename (GEOCLUE_PROVIDERS_DIR,
 	                             filename, NULL);
 	keyfile = g_key_file_new ();
-	ret = g_key_file_load_from_file (keyfile, fullname, 
+	ret = g_key_file_load_from_file (keyfile, fullname,
 	                                 G_KEY_FILE_NONE, &error);
 	g_free (fullname);
-	
+
 	if (!ret) {
 		g_warning ("Error loading %s: %s", filename, error->message);
 		g_error_free (error);
 	} else {
 		*name = g_key_file_get_value (keyfile, "Geoclue Provider",
 		                              "Name", NULL);
-		
+
 		*service = g_key_file_get_value (keyfile, "Geoclue Provider",
 		                                 "Service", NULL);
 		*path = g_key_file_get_value (keyfile, "Geoclue Provider",
@@ -379,19 +336,36 @@
 		*ifaces = g_key_file_get_value (keyfile, "Geoclue Provider",
 		                              "Interfaces", NULL);
 	}
-	
+
 	g_key_file_free (keyfile);
 	return TRUE;
 }
 
-static void 
+static void
+position_callback (GeocluePosition *position,
+                   GeocluePositionFields fields,
+                   int timestamp,
+                   double lat, double lon, double alt,
+                   GeoclueAccuracy *accuracy,
+                   GError *error,
+                   gpointer userdata)
+{
+	if (error) {
+		g_warning ("Error getting position: %s\n", error->message);
+		g_error_free (error);
+		lat = lon = alt = 0.0/0.0;
+	}
+	update_position (GEOCLUE_TEST_GUI (userdata), position, lat, lon, alt);
+}
+
+static void
 add_to_position_store (GeoclueTestGui *gui, GeocluePosition *position, gboolean is_master)
 {
 	GtkTreeIter iter;
-	
+
 	g_assert (gui->position_store);
 	g_assert (position);
-	
+
 	if (is_master) {
 		/* master is already on the first line */
 		gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->position_store), &iter);
@@ -402,14 +376,14 @@
 	                    COL_POSITION_PROVIDER, position,
 	                    COL_POSITION_IS_MASTER, is_master,
 	                    -1);
-	
+
 	g_signal_connect (G_OBJECT (position), "position-changed",
 				G_CALLBACK (position_changed), gui);
-	
-	/* callback will call get_position */
-	geoclue_provider_get_provider_info_async (GEOCLUE_PROVIDER (position), 
+
+	geoclue_provider_get_provider_info_async (GEOCLUE_PROVIDER (position),
 	                                          info_callback,
 	                                          gui);
+	geoclue_position_get_position_async (position, position_callback, gui);
 }
 
 
@@ -418,69 +392,69 @@
 {
 	GtkTreeView *view;
 	GtkCellRenderer *renderer;
-	
+
 	view = GTK_TREE_VIEW (gtk_tree_view_new ());
-	
+
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             "Provider",  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             "Provider",
 	                                             renderer,
 	                                             "text",
 	                                             COL_ADDRESS_PROVIDER_NAME,
 	                                             NULL);
-	
+
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_COUNTRY,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_COUNTRY,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_COUNTRY,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_COUNTRYCODE,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_COUNTRYCODE,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_COUNTRYCODE,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_REGION,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_REGION,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_REGION,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_LOCALITY,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_LOCALITY,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_LOCALITY,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_AREA,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_AREA,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_AREA,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_POSTALCODE,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_POSTALCODE,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_POSTALCODE,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             GEOCLUE_ADDRESS_KEY_STREET,  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             GEOCLUE_ADDRESS_KEY_STREET,
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_ADDRESS_STREET,
 	                                             NULL);
-	
-	gui->address_store = gtk_list_store_new (NUM_ADDRESS_COLS, 
-	                            G_TYPE_POINTER, 
+
+	gui->address_store = gtk_list_store_new (NUM_ADDRESS_COLS,
+	                            G_TYPE_POINTER,
 	                            G_TYPE_STRING,
 	                            G_TYPE_BOOLEAN,
 	                            G_TYPE_STRING,
@@ -490,9 +464,9 @@
 	                            G_TYPE_STRING,
 	                            G_TYPE_STRING,
 	                            G_TYPE_STRING);
-	
+
 	gtk_tree_view_set_model (view, GTK_TREE_MODEL(gui->address_store));
-	
+
 	return GTK_WIDGET (view);
 }
 
@@ -502,63 +476,63 @@
 {
 	GtkTreeView *view;
 	GtkCellRenderer *renderer;
-	
+
 	view = GTK_TREE_VIEW (gtk_tree_view_new ());
-	
+
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             "Provider",  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             "Provider",
 	                                             renderer,
 	                                             "text",
 	                                             COL_POSITION_PROVIDER_NAME,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             "latitude",  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             "latitude",
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_POSITION_LAT,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             "longitude",  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             "longitude",
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_POSITION_LON,
 	                                             NULL);
 	renderer = gtk_cell_renderer_text_new ();
-	gtk_tree_view_insert_column_with_attributes (view, -1,      
-	                                             "altitude",  
+	gtk_tree_view_insert_column_with_attributes (view, -1,
+	                                             "altitude",
 	                                             renderer,
-	                                             "text", 
+	                                             "text",
 	                                             COL_POSITION_ALT,
 	                                             NULL);
-	
-	gui->position_store = gtk_list_store_new (NUM_POSITION_COLS, 
-	                            G_TYPE_POINTER, 
+
+	gui->position_store = gtk_list_store_new (NUM_POSITION_COLS,
+	                            G_TYPE_POINTER,
 	                            G_TYPE_STRING,
 	                            G_TYPE_BOOLEAN,
 	                            G_TYPE_DOUBLE,
 	                            G_TYPE_DOUBLE,
 	                            G_TYPE_DOUBLE);
-	
+
 	gtk_tree_view_set_model (view, GTK_TREE_MODEL(gui->position_store));
-	
+
 	return GTK_WIDGET (view);
 }
 
 static void
 master_position_provider_changed (GeoclueMasterClient *client,
                                   char *name,
-                                  char *description, 
+                                  char *description,
                                   char *service,
                                   char *path,
                                   GeoclueTestGui *gui)
 {
 	GtkTreeIter iter;
 	char *msg;
-	
-	if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->position_store), 
+
+	if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->position_store),
 					   &iter)) {
 		gtk_list_store_set (gui->position_store, &iter,
 				    COL_POSITION_PROVIDER_NAME, g_strdup_printf ("Master (%s)", name),
@@ -572,15 +546,15 @@
 static void
 master_address_provider_changed (GeoclueMasterClient *client,
                                  char *name,
-                                 char *description, 
+                                 char *description,
                                  char *service,
                                  char *path,
                                  GeoclueTestGui *gui)
 {
 	GtkTreeIter iter;
 	char *msg;
-	
-	if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->address_store), 
+
+	if (gtk_tree_model_get_iter_first (GTK_TREE_MODEL (gui->address_store),
 					   &iter)) {
 		gtk_list_store_set (gui->address_store, &iter,
 				    COL_ADDRESS_PROVIDER_NAME, g_strdup_printf ("Master (%s)", name),
@@ -605,7 +579,7 @@
 static void
 update_master_requirements (GeoclueTestGui *gui)
 {
-	geoclue_master_client_set_requirements_async (gui->client, 
+	geoclue_master_client_set_requirements_async (gui->client,
 	                                              gui->master_accuracy,
 	                                              0,
 	                                              FALSE,
@@ -614,14 +588,14 @@
 	                                              NULL);
 }
 
-static void 
+static void
 create_address_callback (GeoclueMasterClient *client,
                          GeoclueAddress      *address,
                          GError              *error,
                          gpointer             userdata)
 {
 	GeoclueTestGui *gui = GEOCLUE_TEST_GUI (userdata);
-	
+
 	if (error) {
 		g_printerr ("Master Client: Failed to create address: %s", error->message);
 		g_error_free (error);
@@ -630,14 +604,14 @@
 	add_to_address_store (gui, address, TRUE);
 }
 
-static void 
+static void
 create_position_callback (GeoclueMasterClient *client,
                           GeocluePosition     *position,
                           GError              *error,
                           gpointer             userdata)
 {
 	GeoclueTestGui *gui = GEOCLUE_TEST_GUI (userdata);
-	
+
 	if (error) {
 		g_printerr ("Master Client: Failed to create position: %s", error->message);
 		g_error_free (error);
@@ -658,40 +632,40 @@
 	char *name, *path, *service, *ifaces;
 	GtkTreeIter iter;
 	GeoclueTestGui *gui = GEOCLUE_TEST_GUI (userdata);
-	
+
 	if (error) {
 		g_printerr ("Failed to create master client: %s", error->message);
 		g_error_free (error);
 		return;
 	}
-	
+
 	gui->client = client;
-	
+
 	g_signal_connect (G_OBJECT (gui->client), "position-provider-changed",
 	                  G_CALLBACK (master_position_provider_changed), gui);
 	g_signal_connect (G_OBJECT (gui->client), "address-provider-changed",
 	                  G_CALLBACK (master_address_provider_changed), gui);
 	update_master_requirements (gui);
-	
+
 	/* add master providers to the lists */
 	gtk_list_store_append (gui->position_store, &iter);
-	geoclue_master_client_create_position_async (gui->client, 
+	geoclue_master_client_create_position_async (gui->client,
 	                                             create_position_callback,
 	                                             gui);
 	gtk_list_store_append (gui->address_store, &iter);
-	geoclue_master_client_create_address_async (gui->client, 
+	geoclue_master_client_create_address_async (gui->client,
 	                                            create_address_callback,
 	                                            gui);
-	
+
 	/* add individual providers based on files in GEOCLUE_PROVIDERS_DIR  */
 	dir = g_dir_open (GEOCLUE_PROVIDERS_DIR, 0, &error);
 	if (!dir) {
-		g_warning ("Error opening %s: %s\n", 
+		g_warning ("Error opening %s: %s\n",
 		           GEOCLUE_PROVIDERS_DIR, error->message);
 		g_error_free (error);
 		return;
 	}
-	
+
 	name = service = path = ifaces = NULL;
 	while (get_next_provider (dir, &name, &service, &path, &ifaces)) {
 		if (ifaces && strstr (ifaces, "org.freedesktop.Geoclue.Position")) {
@@ -705,7 +679,7 @@
 		g_free (service);
 		g_free (ifaces);
 	}
-	
+
 	g_dir_close (dir);
 	g_object_unref (master);
 }
@@ -714,9 +688,9 @@
 geoclue_test_gui_load_providers (GeoclueTestGui *gui)
 {
 	GeoclueMaster *master;
-	
+
 	master = geoclue_master_get_default ();
-	geoclue_master_create_client_async (master, 
+	geoclue_master_create_client_async (master,
 	                                    create_client_callback,
 	                                    gui);
 }
@@ -725,13 +699,13 @@
 accuracy_combo_changed (GtkComboBox *combo, GeoclueTestGui *gui)
 {
 	GtkTreeIter iter;
-	
+
 	if (gtk_combo_box_get_active_iter (combo, &iter)) {
 		GtkTreeModel *model;
-		
+
 		model = gtk_combo_box_get_model (combo);
-		gtk_tree_model_get (model, &iter, 0, &gui->master_accuracy, -1); 
-		
+		gtk_tree_model_get (model, &iter, 0, &gui->master_accuracy, -1);
+
 		update_master_requirements (gui);
 	}
 }
@@ -776,49 +750,49 @@
 	GtkWidget *combo;
 	GtkTreeIter iter;
 	GtkCellRenderer *renderer;
-	
+
 	store = gtk_list_store_new (2, G_TYPE_UINT, G_TYPE_STRING);
-	
+
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_COUNTRY, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_COUNTRY,
 	                    1, "Country",
 	                    -1);
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_REGION, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_REGION,
 	                    1, "Region",
 	                    -1);
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_LOCALITY, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_LOCALITY,
 	                    1, "Locality",
 	                    -1);
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_POSTALCODE, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_POSTALCODE,
 	                    1, "Postalcode",
 	                    -1);
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_STREET, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_STREET,
 	                    1, "Street",
 	                    -1);
 	gtk_list_store_append (store, &iter);
-	gtk_list_store_set (store, &iter, 
-	                    0, GEOCLUE_ACCURACY_LEVEL_DETAILED, 
+	gtk_list_store_set (store, &iter,
+	                    0, GEOCLUE_ACCURACY_LEVEL_DETAILED,
 	                    1, "Detailed",
 	                    -1);
-	
+
 	combo = gtk_combo_box_new_with_model (GTK_TREE_MODEL (store));
 	renderer = gtk_cell_renderer_text_new ();
 	gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (combo), renderer, TRUE);
 	gtk_cell_layout_set_attributes (GTK_CELL_LAYOUT (combo), renderer,
 	                                "text", 1, NULL);
-	
+
 	gtk_combo_box_set_active (GTK_COMBO_BOX (combo), 0);
 	gui->master_accuracy = GEOCLUE_ACCURACY_LEVEL_COUNTRY;
-	
+
 	return combo;
 }
 
@@ -836,88 +810,88 @@
 	GtkWidget *combo, *check;
 	GtkWidget *scrolled_win;
 	GtkWidget *view;
-	
+
 	gui->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
 	g_signal_connect (G_OBJECT (gui->window), "destroy",
 	                  G_CALLBACK (gtk_main_quit), NULL);
-	
+
 	view = gtk_text_view_new ();
 	gtk_widget_set_size_request (GTK_WIDGET (view), 500, 200);
 	g_object_set (G_OBJECT (view), "editable", FALSE, NULL);
 	gui->buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (view));
-	
-	
+
+
 	box = gtk_vbox_new (FALSE, 8);
 	gtk_container_add (GTK_CONTAINER (gui->window), box);
-	
+
 	frame = gtk_frame_new ("Master settings");
 	gtk_box_pack_start (GTK_BOX (box), frame, FALSE, FALSE, 4);
-	
-	
+
+
 	hbox = gtk_hbox_new (FALSE, 24);
 	gtk_container_add (GTK_CONTAINER (frame), hbox);
-	
+
 	vbox = gtk_vbox_new (FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (hbox), vbox, FALSE, FALSE, 8);
 	label = gtk_label_new ("Required accuracy level:");
 	gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 0);
-	
-	combo = get_accuracy_combo (gui); 
+
+	combo = get_accuracy_combo (gui);
 	g_signal_connect (combo, "changed",
 	                  G_CALLBACK (accuracy_combo_changed), gui);
 	gtk_box_pack_start (GTK_BOX (vbox), combo, FALSE, FALSE, 0);
-	
+
 	vbox = gtk_vbox_new (FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (hbox), vbox, FALSE, FALSE, 0);
 	label = gtk_label_new ("Allow resources:");
 	gtk_box_pack_start (GTK_BOX (vbox), label, FALSE, FALSE, 0);
-	
+
 	check = gtk_check_button_new_with_label ("Network");
 	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), TRUE);
 	gui->master_resources |= GEOCLUE_RESOURCE_NETWORK;
 	g_signal_connect (check, "toggled",
 	                  G_CALLBACK (network_check_toggled), gui);
 	gtk_box_pack_start (GTK_BOX (vbox), check, FALSE, FALSE, 0);
-	
+
 	check = gtk_check_button_new_with_label ("GPS");
 	g_signal_connect (check, "toggled",
 	                  G_CALLBACK (gps_check_toggled), gui);
 	gtk_box_pack_start (GTK_BOX (vbox), check, FALSE, FALSE, 0);
-	
+
 	check = gtk_check_button_new_with_label ("Cell");
 	g_signal_connect (check, "toggled",
 	                  G_CALLBACK (cell_check_toggled), gui);
 	gtk_box_pack_start (GTK_BOX (vbox), check, FALSE, FALSE, 0);
-	
+
 	notebook = gtk_notebook_new ();
 	gtk_box_pack_start (GTK_BOX (box), notebook, FALSE, FALSE, 0);
 	gtk_notebook_set_show_tabs (GTK_NOTEBOOK (notebook), TRUE);
 	gtk_notebook_set_show_border (GTK_NOTEBOOK (notebook), TRUE);
-	
+
 	address_view = get_address_tree_view (gui);
 	label = gtk_label_new ("Address");
 	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), address_view, label);
-	
+
 	position_view = get_position_tree_view (gui);
 	label = gtk_label_new ("Position");
 	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), position_view, label);
-	
-	
+
+
 	hbox = gtk_hbox_new (FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (box), hbox, FALSE, FALSE, 0);
 	label = gtk_label_new ("Master log");
 	gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
-	
+
 	scrolled_win = gtk_scrolled_window_new (NULL, NULL);
-	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_win), 
+	gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolled_win),
 	                                GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
 	gtk_container_add (GTK_CONTAINER (box), scrolled_win);
 	gtk_container_add (GTK_CONTAINER (scrolled_win), view);
-	
+
 	geoclue_test_gui_load_providers (gui);
-	
+
 	geoclue_test_gui_master_log_message (gui, "Started Geoclue test UI");
-	
+
 	gtk_widget_show_all (gui->window);
 }
 
@@ -925,13 +899,13 @@
 int main (int argc, char **argv)
 {
 	GeoclueTestGui *gui;
-	
+
 	gtk_init (&argc, &argv);
-	
+
 	gui = g_object_new (GEOCLUE_TYPE_TEST_GUI, NULL);
 	gtk_main ();
-	
+
 	g_object_unref (gui);
-	
+
 	return 0;
 }
Index: geoclue/AUTHORS
===================================================================
--- geoclue.orig/AUTHORS	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/AUTHORS	2011-12-29 16:40:58.662429311 +0900
@@ -1,3 +1,8 @@
 Keith Preston <keithpre@gmail.com>
 Jussi Kukkonen <jku@o-hand.com>
 Iain Holmes <Iain@openedhand.com>
+Sangho Park <sangho.g.park@samsung.com>
+Tae-Hwan Kim <the81.kim@samsung.com>
+Youngae Kang <youngae.kang@samsung.com>
+Yunhan Kim <yhan.kim@samsung.com>
+Genie Kim <daejins.kim@samsung.com>
Index: geoclue/Makefile.am
===================================================================
--- geoclue.orig/Makefile.am	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/Makefile.am	2011-12-29 16:44:31.974432915 +0900
@@ -1,4 +1,4 @@
-SUBDIRS = interfaces geoclue src providers example test docs
+SUBDIRS = interfaces geoclue providers src
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = geoclue.pc
Index: geoclue/autogen.sh
===================================================================
--- geoclue.orig/autogen.sh	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/autogen.sh	2011-12-29 16:40:58.662429311 +0900
@@ -5,7 +5,6 @@
 ACLOCAL=aclocal
 AUTOCONF=autoconf
 AUTOHEADER=autoheader
-GTKDOCIZE=gtkdocize
 
 # Check for binaries
 
@@ -29,17 +28,8 @@
     exit 1
 }
 
-[ "x$(which ${GTKDOCIZE})x" = "xx" ] && {
-    echo "${GTKDOCIZE} not found. Please install it."
-    exit 1
-}
-
-gtkdocize || exit 1
-
 "${ACLOCAL}" \
-&& "${LIBTOOLIZE}" \
+&& "${LIBTOOLIZE}" --force \
 && "${AUTOHEADER}" \
-&& "${AUTOMAKE}" --add-missing \
-&& "${AUTOCONF}"
-
-$(dirname "${0}")/configure "$@"
+&& "${AUTOCONF}" \
+&& "${AUTOMAKE}" --add-missing
Index: geoclue/configure.ac
===================================================================
--- geoclue.orig/configure.ac	2011-12-29 16:41:40.358430015 +0900
+++ geoclue/configure.ac	2011-12-29 16:40:58.662429311 +0900
@@ -6,9 +6,6 @@
 AM_INIT_AUTOMAKE([1.9 foreign])
 GEOCLUE_VERSION=0.12.0
 
-# Enable silent build when available (Automake 1.11)
-m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])])
-
 AC_PROG_CC
 AC_ISC_POSIX
 
@@ -17,9 +14,8 @@
 AC_PROG_MAKE_SET
 AC_PROG_GCC_TRADITIONAL
 AM_PROG_LIBTOOL
-GLIB_GSETTINGS
 
-GTK_DOC_CHECK(1.0)
+#GTK_DOC_CHECK(1.0)
 AC_CHECK_PROGS(XSLT, xsltproc)
 
 AC_ARG_ENABLE(system-bus,
@@ -38,15 +34,14 @@
 PKG_CHECK_MODULES(GEOCLUE, [
 		  glib-2.0
 		  gobject-2.0
-		  dbus-glib-1 >= 0.86
+		  dbus-glib-1 >= 0.60
 		  libxml-2.0
 ])
 AC_SUBST(GEOCLUE_LIBS)
 AC_SUBST(GEOCLUE_CFLAGS)
 
 PKG_CHECK_MODULES(MASTER, [
-		  gio-2.0 >= 2.25.7
-		  glib-2.0
+		  gconf-2.0
 ])
 AC_SUBST(MASTER_LIBS)
 AC_SUBST(MASTER_CFLAGS)
@@ -66,7 +61,7 @@
 AC_ARG_ENABLE(gtk,
               AS_HELP_STRING([--enable-gtk=@<:@no/yes/auto@:>@],
                              [build with gtk support]), ,
-                             enable_gtk=auto)
+                             enable_gtk=no)
  
 if test "x$enable_gtk" != "xno"; then
    PKG_CHECK_MODULES(GTK,
@@ -82,7 +77,7 @@
 fi
 
 if test "x$enable_gtk" = "xyes" -a "x$have_gtk" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find gtk dependencies.])
+   AC_MSG_ERROR(["Couldn't find gtk dependencies."])
 fi
 
 AM_CONDITIONAL(HAVE_GTK, test "x$have_gtk" = "xyes")
@@ -117,19 +112,7 @@
 fi
 
 if test "x$enable_conic" = "xyes" -a "x$have_conic" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find conic dependencies.])
-fi
-
-AC_ARG_ENABLE(connman,
-              AS_HELP_STRING([--enable-connman=@<:@no/yes/auto@:>@],
-                             [build with connman support]), ,
-                             enable_connman=auto)
-
-if test "x$enable_connman" != "xno"; then
-    CONNECTIVITY="ConnMan"
-    AC_DEFINE(HAVE_CONNMAN, 1, [define if libconmann is installed])
-else
-   have_connman=no
+   AC_MSG_ERROR(["Couldn't find conic dependencies."])
 fi
 
 AC_ARG_ENABLE(networkmanager,
@@ -140,7 +123,7 @@
 if test "x$enable_networkmanager" != "xno"; then
    PKG_CHECK_MODULES(NETWORK_MANAGER,
    [
-      NetworkManager libnm-glib libnm-util
+      NetworkManager libnm_glib
    ], have_networkmanager="yes", have_networkmanager="no")
 
    if test "x$have_networkmanager" = "xyes"; then
@@ -154,44 +137,13 @@
 fi
 
 if test "x$enable_networkmanager" = "xyes" -a "x$have_networkmanager" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find Network Manager dependencies.])
+   AC_MSG_ERROR(["Couldn't find Network Manager dependencies."])
 fi
 
 AC_SUBST(CONNECTIVITY_LIBS)
 AC_SUBST(CONNECTIVITY_CFLAGS)
 
-PROVIDER_SUBDIRS="example hostip geonames nominatim manual plazes localnet yahoo gsmloc"
-
-# -----------------------------------------------------------
-# gypsy / gpsd / skyhook
-# -----------------------------------------------------------
-
-GYPSY_REQUIRED=0.7.1
-AC_ARG_ENABLE(gypsy,
-              AS_HELP_STRING([--enable-gypsy=@<:@no/yes/auto@:>@],
-                             [build with gypsy support]), ,
-                             enable_gypsy=auto)
-
-if test "x$enable_gypsy" != "xno"; then
-   PKG_CHECK_MODULES(GYPSY,
-   [
-      gypsy >= $GYPSY_REQUIRED
-   ], have_gypsy="yes", have_gypsy="no")
-
-   if test "x$have_gypsy" = "xyes"; then
-      PROVIDER_SUBDIRS="$PROVIDER_SUBDIRS gypsy"
-   else
-      NO_BUILD_PROVIDERS="$NO_BUILD_PROVIDERS gypsy"
-   fi
- else
-   have_gypsy=no
-fi
-
-if test "x$enable_gypsy" = "xyes" -a "x$have_gypsy" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find gypsy dependencies.])
-fi
-AC_SUBST(GYPSY_LIBS)
-AC_SUBST(GYPSY_CFLAGS)
+PROVIDER_SUBDIRS="nominatim"
 
 AC_ARG_ENABLE(gpsd,
               AS_HELP_STRING([--enable-gpsd=@<:@no/yes/auto@:>@],
@@ -210,65 +162,27 @@
 fi
 
 if test "x$enable_gpsd" = "xyes" -a "x$have_gpsd" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find gpsd dependencies - libgps >= 2.90.])
+   AC_MSG_ERROR(["Couldn't find gpsd dependencies - libgps >= 2.90."])
 fi
 AC_SUBST(GPSD_LIBS)
 AC_SUBST(GPSD_CFLAGS)
 
-AC_ARG_ENABLE(skyhook,
-              AS_HELP_STRING([--enable-skyhook=@<:@no/yes/auto@:>@],
-                             [build with skyhook support]), ,
-                             enable_skyhook=auto)
-
-if test "x$enable_skyhook" != "xno"; then
-    PKG_CHECK_MODULES(SKYHOOK, [
-		  libsoup-gnome-2.4
-    ], have_skyhook=yes, have_skyhook=no)
-
-   if test "x$have_skyhook" = "xyes"; then
-      PROVIDER_SUBDIRS="$PROVIDER_SUBDIRS skyhook"
-      GPSD_LIBS="-lgps"
-   else
-      NO_BUILD_PROVIDERS="$NO_BUILD_PROVIDERS skyhook"
-   fi
- else
-   have_skyhook=no
-fi
-
-if test "x$enable_skyhook" = "xyes" -a "x$have_skyhook" != "xyes"; then
-   AC_MSG_ERROR([Couldn't find gpsd dependencies.])
-fi
-AC_SUBST(SKYHOOK_LIBS)
-AC_SUBST(SKYHOOK_CFLAGS)
-
 AC_SUBST(PROVIDER_SUBDIRS)
 AC_SUBST(NO_BUILD_PROVIDERS)
 
 AC_CONFIG_FILES([
 geoclue.pc
 Makefile
-docs/Makefile
-docs/reference/Makefile
-docs/tools/Makefile
 interfaces/Makefile
 geoclue/Makefile
-example/Makefile
-test/Makefile
 providers/Makefile
-providers/example/Makefile
-providers/gypsy/Makefile
 providers/gpsd/Makefile
-providers/hostip/Makefile
-providers/geonames/Makefile
-providers/manual/Makefile
 providers/nominatim/Makefile
-providers/plazes/Makefile
-providers/localnet/Makefile
-providers/yahoo/Makefile
-providers/gsmloc/Makefile
-providers/skyhook/Makefile
 src/Makefile
 ])
+#docs/Makefile
+#docs/reference/Makefile
+#docs/tools/Makefile
 
 AC_OUTPUT
 
Index: geoclue/gtk-doc.make
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ geoclue/gtk-doc.make	2011-12-29 16:40:58.666429311 +0900
@@ -0,0 +1,224 @@
+# -*- mode: makefile -*-
+
+####################################
+# Everything below here is generic #
+####################################
+
+if GTK_DOC_USE_LIBTOOL
+GTKDOC_CC = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(LIBTOOL) --tag=CC --mode=link $(CC) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+GTKDOC_RUN = $(LIBTOOL) --mode=execute
+else
+GTKDOC_CC = $(CC) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+GTKDOC_LD = $(CC) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS)
+GTKDOC_RUN =
+endif
+
+# We set GPATH here; this gives us semantics for GNU make
+# which are more like other make's VPATH, when it comes to
+# whether a source that is a target of one rule is then
+# searched for in VPATH/GPATH.
+#
+GPATH = $(srcdir)
+
+TARGET_DIR=$(HTML_DIR)/$(DOC_MODULE)
+
+EXTRA_DIST = 				\
+	$(content_files)		\
+	$(HTML_IMAGES)			\
+	$(DOC_MAIN_SGML_FILE)		\
+	$(DOC_MODULE)-sections.txt	\
+	$(DOC_MODULE)-overrides.txt
+
+DOC_STAMPS=scan-build.stamp tmpl-build.stamp sgml-build.stamp html-build.stamp \
+	pdf-build.stamp \
+	$(srcdir)/tmpl.stamp $(srcdir)/sgml.stamp $(srcdir)/html.stamp \
+	$(srcdir)/pdf.stamp
+
+SCANOBJ_FILES = 		 \
+	$(DOC_MODULE).args 	 \
+	$(DOC_MODULE).hierarchy  \
+	$(DOC_MODULE).interfaces \
+	$(DOC_MODULE).prerequisites \
+	$(DOC_MODULE).signals
+
+REPORT_FILES = \
+	$(DOC_MODULE)-undocumented.txt \
+	$(DOC_MODULE)-undeclared.txt \
+	$(DOC_MODULE)-unused.txt
+
+CLEANFILES = $(SCANOBJ_FILES) $(REPORT_FILES) $(DOC_STAMPS)
+
+if ENABLE_GTK_DOC
+if GTK_DOC_BUILD_HTML
+HTML_BUILD_STAMP=html-build.stamp
+else
+HTML_BUILD_STAMP=
+endif
+if GTK_DOC_BUILD_PDF
+PDF_BUILD_STAMP=pdf-build.stamp
+else
+PDF_BUILD_STAMP=
+endif
+
+all-local: $(HTML_BUILD_STAMP) $(PDF_BUILD_STAMP)
+else
+all-local:
+endif
+
+docs: $(HTML_BUILD_STAMP) $(PDF_BUILD_STAMP)
+
+$(REPORT_FILES): sgml-build.stamp
+
+#### scan ####
+
+scan-build.stamp: $(HFILE_GLOB) $(CFILE_GLOB)
+	@echo 'gtk-doc: Scanning header files'
+	@-chmod -R u+w $(srcdir)
+	@cd $(srcdir) && \
+	  gtkdoc-scan --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --ignore-headers="$(IGNORE_HFILES)" $(SCAN_OPTIONS) $(EXTRA_HFILES)
+	@if grep -l '^..*$$' $(srcdir)/$(DOC_MODULE).types > /dev/null 2>&1 ; then \
+	    CC="$(GTKDOC_CC)" LD="$(GTKDOC_LD)" RUN="$(GTKDOC_RUN)" CFLAGS="$(GTKDOC_CFLAGS) $(CFLAGS)" LDFLAGS="$(GTKDOC_LIBS) $(LDFLAGS)" gtkdoc-scangobj $(SCANGOBJ_OPTIONS) --module=$(DOC_MODULE) --output-dir=$(srcdir) ; \
+	else \
+	    cd $(srcdir) ; \
+	    for i in $(SCANOBJ_FILES) ; do \
+               test -f $$i || touch $$i ; \
+	    done \
+	fi
+	@touch scan-build.stamp
+
+$(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt: scan-build.stamp
+	@true
+
+#### templates ####
+
+tmpl-build.stamp: $(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt
+	@echo 'gtk-doc: Rebuilding template files'
+	@-chmod -R u+w $(srcdir)
+	@cd $(srcdir) && gtkdoc-mktmpl --module=$(DOC_MODULE) $(MKTMPL_OPTIONS)
+	@touch tmpl-build.stamp
+
+tmpl.stamp: tmpl-build.stamp
+	@true
+
+$(srcdir)/tmpl/*.sgml:
+	@true
+
+#### xml ####
+
+sgml-build.stamp: tmpl.stamp $(DOC_MODULE)-sections.txt $(srcdir)/tmpl/*.sgml $(expand_content_files)
+	@echo 'gtk-doc: Building XML'
+	@-chmod -R u+w $(srcdir)
+	@cd $(srcdir) && \
+	gtkdoc-mkdb --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --output-format=xml --expand-content-files="$(expand_content_files)" --main-sgml-file=$(DOC_MAIN_SGML_FILE) $(MKDB_OPTIONS)
+	@touch sgml-build.stamp
+
+sgml.stamp: sgml-build.stamp
+	@true
+
+#### html ####
+
+html-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
+	@echo 'gtk-doc: Building HTML'
+	@-chmod -R u+w $(srcdir)
+	@rm -rf $(srcdir)/html
+	@mkdir $(srcdir)/html
+	@mkhtml_options=""; \
+	gtkdoc-mkhtml 2>&1 --help | grep  >/dev/null "\-\-path"; \
+	if test "$(?)" = "0"; then \
+	  mkhtml_options=--path="$(srcdir)"; \
+	fi; \
+	cd $(srcdir)/html && gtkdoc-mkhtml $$mkhtml_options $(MKHTML_OPTIONS) $(DOC_MODULE) ../$(DOC_MAIN_SGML_FILE)
+	@test "x$(HTML_IMAGES)" = "x" || ( cd $(srcdir) && cp $(HTML_IMAGES) html )
+	@echo 'gtk-doc: Fixing cross-references'
+	@cd $(srcdir) && gtkdoc-fixxref --module=$(DOC_MODULE) --module-dir=html --html-dir=$(HTML_DIR) $(FIXXREF_OPTIONS)
+	@touch html-build.stamp
+
+#### pdf ####
+
+pdf-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
+	@echo 'gtk-doc: Building PDF'
+	@-chmod -R u+w $(srcdir)
+	@rm -rf $(srcdir)/$(DOC_MODULE).pdf
+	@mkpdf_imgdirs=""; \
+	if test "x$(HTML_IMAGES)" != "x"; then \
+	  for img in $(HTML_IMAGES); do \
+	    part=`dirname $$img`; \
+	    echo $$mkpdf_imgdirs | grep >/dev/null "\-\-imgdir=$$part "; \
+	    if test $$? != 0; then \
+	      mkpdf_imgdirs="$$mkpdf_imgdirs --imgdir=$$part"; \
+	    fi; \
+	  done; \
+	fi; \
+	cd $(srcdir) && gtkdoc-mkpdf --path="$(abs_srcdir)" $$mkpdf_imgdirs $(DOC_MODULE) $(DOC_MAIN_SGML_FILE) $(MKPDF_OPTIONS)
+	@touch pdf-build.stamp
+
+##############
+
+clean-local:
+	rm -f *~ *.bak
+	rm -rf .libs
+
+distclean-local:
+	cd $(srcdir) && \
+	  rm -rf xml $(REPORT_FILES) $(DOC_MODULE).pdf \
+	         $(DOC_MODULE)-decl-list.txt $(DOC_MODULE)-decl.txt
+
+maintainer-clean-local: clean
+	cd $(srcdir) && rm -rf xml html
+
+install-data-local:
+	@installfiles=`echo $(srcdir)/html/*`; \
+	if test "$$installfiles" = '$(srcdir)/html/*'; \
+	then echo '-- Nothing to install' ; \
+	else \
+	  if test -n "$(DOC_MODULE_VERSION)"; then \
+	    installdir="$(DESTDIR)$(TARGET_DIR)-$(DOC_MODULE_VERSION)"; \
+	  else \
+	    installdir="$(DESTDIR)$(TARGET_DIR)"; \
+	  fi; \
+	  $(mkinstalldirs) $${installdir} ; \
+	  for i in $$installfiles; do \
+	    echo '-- Installing '$$i ; \
+	    $(INSTALL_DATA) $$i $${installdir}; \
+	  done; \
+	  if test -n "$(DOC_MODULE_VERSION)"; then \
+	    mv -f $${installdir}/$(DOC_MODULE).devhelp2 \
+	      $${installdir}/$(DOC_MODULE)-$(DOC_MODULE_VERSION).devhelp2; \
+	    mv -f $${installdir}/$(DOC_MODULE).devhelp \
+	      $${installdir}/$(DOC_MODULE)-$(DOC_MODULE_VERSION).devhelp; \
+	  fi; \
+	  $(GTKDOC_REBASE) --relative --dest-dir=$(DESTDIR) --html-dir=$${installdir}; \
+	fi
+
+uninstall-local:
+	@if test -n "$(DOC_MODULE_VERSION)"; then \
+	  installdir="$(DESTDIR)$(TARGET_DIR)-$(DOC_MODULE_VERSION)"; \
+	else \
+	  installdir="$(DESTDIR)$(TARGET_DIR)"; \
+	fi; \
+	rm -rf $${installdir}
+
+#
+# Require gtk-doc when making dist
+#
+if ENABLE_GTK_DOC
+dist-check-gtkdoc:
+else
+dist-check-gtkdoc:
+	@echo "*** gtk-doc must be installed and enabled in order to make dist"
+	@false
+endif
+
+dist-hook: dist-check-gtkdoc dist-hook-local
+	mkdir $(distdir)/tmpl
+	mkdir $(distdir)/html
+	-cp $(srcdir)/tmpl/*.sgml $(distdir)/tmpl
+	cp $(srcdir)/html/* $(distdir)/html
+	-cp $(srcdir)/$(DOC_MODULE).pdf $(distdir)/
+	-cp $(srcdir)/$(DOC_MODULE).types $(distdir)/
+	-cp $(srcdir)/$(DOC_MODULE)-sections.txt $(distdir)/
+	cd $(distdir) && rm -f $(DISTCLEANFILES)
+	$(GTKDOC_REBASE) --online --relative --html-dir=$(distdir)/html
+
+.PHONY : dist-hook-local docs
Index: geoclue/src/connectivity-connman.c
===================================================================
--- geoclue.orig/src/connectivity-connman.c	2011-12-29 16:40:38.930428900 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,739 +0,0 @@
-/*
- * Geoclue
- * connectivity-connman.c
- *
- * Author: Javier Fernandez <jfernandez@igalia.com>
- * Copyright (C) 2010 Igalia S.L
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- *
- */
-#include <config.h>
-
-#ifdef HAVE_CONNMAN
-
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include "connectivity-connman.h"
-
-#define CONNMAN_SERVICE           "org.moblin.connman"
-#define CONNMAN_MANAGER_PATH      "/"
-#define CONNMAN_MANAGER_INTERFACE CONNMAN_SERVICE ".Manager"
-#define CONNMAN_TECHNOLOGY_INTERFACE CONNMAN_SERVICE ".Technology"
-#define CONNMAN_DEVICE_INTERFACE CONNMAN_SERVICE ".Device"
-#define CONNMAN_NETWORK_INTERFACE CONNMAN_SERVICE ".Network"
-#define CONNMAN_SERVICE_INTERFACE CONNMAN_SERVICE ".Service"
-
-typedef void (*ConnmanFunc) (GeoclueConnman *self,
-			     const gchar *path,
-			     gpointer out);
-
-static void geoclue_connman_connectivity_init (GeoclueConnectivityInterface *iface);
-
-static int _strength_to_dbm (int strength);
-static char *_get_mac_for_gateway (const char *gateway);
-static char *_mac_strup (char *mac);
-static gchar *_get_gateway (GeoclueConnman *self, const gchar *service);
-static void _get_best_ap (GeoclueConnman *self, const gchar *network);
-static void _get_aps_info (GeoclueConnman *self, const gchar *network, GHashTable **out);
-static const GPtrArray *_get_technologies (GeoclueConnman *self, GHashTable **props);
-static const GPtrArray *_get_services (GeoclueConnman *self, GHashTable **props);
-static const GPtrArray *_get_devices (GeoclueConnman *self, GHashTable **props, const gchar *technology);
-static const GPtrArray *_get_networks (GeoclueConnman *self, GHashTable **props, const gchar *device, const gchar *type_filter);
-static void _explore_available_aps (GeoclueConnman *self, ConnmanFunc func, gpointer out);
-
-
-G_DEFINE_TYPE_WITH_CODE (GeoclueConnman, geoclue_connman, G_TYPE_OBJECT,
-                         G_IMPLEMENT_INTERFACE (GEOCLUE_TYPE_CONNECTIVITY,
-                                                geoclue_connman_connectivity_init))
-
-
-/* GeoclueConnectivity iface methods */
-static int
-_get_status (GeoclueConnectivity *iface)
-{
-	GeoclueConnman *connman = GEOCLUE_CONNMAN (iface);
-
-	return connman->status;
-}
-
-static char *
-_get_ap_mac (GeoclueConnectivity *iface)
-{
-	GeoclueConnman *connman = GEOCLUE_CONNMAN (iface);
-
-	return g_strdup (connman->cache_ap_mac);
-}
-
-static GHashTable *
-_get_aps (GeoclueConnectivity *iface)
-{
-	GeoclueConnman *self = GEOCLUE_CONNMAN (iface);
-	GHashTable *ht = NULL;
-
-	/* Explore the active networks to collect the APs. */
-	_explore_available_aps (self, (ConnmanFunc) _get_aps_info, &ht);
-
-	return ht;
-}
-
-static char *
-_get_router_mac (GeoclueConnectivity *iface)
-{
-	GeoclueConnman *self = GEOCLUE_CONNMAN (iface);
-	GHashTable *props = NULL;
-	const GPtrArray *servs = NULL;
-	const gchar *serv = NULL;
-	gchar *gateway = NULL;
-	char *mac = NULL;
-	guint i;
-
-	/* Get available services and iterate over them */
-	/* to get the MAC of the connected router. */
-	servs = _get_services (self, &props);
-	if (servs != NULL) {
-		for (i = 0; gateway == NULL && servs->len; i++) {
-			serv = g_ptr_array_index (servs, i);
-			gateway = _get_gateway (self, serv);
-		}
-	}
-
-	/* Check the result. */
-	if (gateway != NULL) {
-		mac = _get_mac_for_gateway (gateway);
-		g_free (gateway);
-	}
-
-	/* Free */
-	g_hash_table_destroy (props);
-
-	return mac;
-}
-
-/* internal private GObject methods */
-static void
-dispose (GObject *object)
-{
-	GeoclueConnman *self = GEOCLUE_CONNMAN (object);
-
-	g_object_unref (self->client);
-	self->client = NULL;
-
-	dbus_g_connection_unref (self->conn);
-	self->conn = NULL;
-
-	g_free (self->cache_ap_mac);
-	self->cache_ap_mac = NULL;
-
-	((GObjectClass *) geoclue_connman_parent_class)->dispose (object);
-}
-
-static void
-geoclue_connman_class_init (GeoclueConnmanClass *klass)
-{
-	GObjectClass *o_class = (GObjectClass *) klass;
-
-	o_class->dispose = dispose;
-}
-
-static int
-_strength_to_dbm (int strength)
-{
-	/* Hackish linear strength to dBm conversion.
-	 * 0% is -90 dBm
-	 * 100% is -20 dBm */
-	return (strength * 0.7) - 90;
-}
-
-static char *
-_get_mac_for_gateway (const char *gateway)
-{
-	char *cmd, *out, *mac, **split;
-
-	cmd = g_strdup_printf ("ip neigh show %s", gateway);
-
-	if (g_spawn_command_line_sync (cmd, &out, NULL, NULL, NULL) == FALSE) {
-		g_free (out);
-		g_free (cmd);
-		return NULL;
-	}
-	g_free (cmd);
-
-	/* 192.168.1.1 dev eth0 lladdr 00:00:00:00:00:00 STALE */
-	split = g_strsplit (out, " ", -1);
-	g_free (out);
-
-	if (split == NULL)
-		return NULL;
-	if (g_strv_length (split) != 6) {
-		g_strfreev (split);
-		return NULL;
-	}
-	mac = g_strdup (split[4]);
-	g_strfreev (split);
-
-	return _mac_strup (mac);
-}
-
-static char *
-_mac_strup (char *mac)
-{
-	guint i;
-
-	g_assert (mac != NULL);
-
-	for (i = 0; mac[i] != '\0' ; i++) {
-		if (g_ascii_isalpha (mac[i]))
-			mac[i] = g_ascii_toupper (mac[i]);
-	}
-	return mac;
-}
-
-static GeoclueNetworkStatus
-connmanstatus_to_geocluenetworkstatus (const gchar *status)
-{
-	if (g_strcmp0 (status, "online")) {
-		return GEOCLUE_CONNECTIVITY_OFFLINE;
-	} else {
-		return GEOCLUE_CONNECTIVITY_ONLINE;
-	}
-}
-
-static gchar *
-_get_gateway (GeoclueConnman *self,
-	      const gchar *service)
-{
-	DBusGProxy *proxy = NULL;
-	GHashTable *props = NULL;
-	gchar *gateway = NULL;
-	const GHashTable *ht = NULL;
-	const GValue *value = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-
-	/* Create proxy. */
-	proxy = dbus_g_proxy_new_for_name (self->conn,
-					   CONNMAN_SERVICE,
-					   service,
-					   CONNMAN_SERVICE_INTERFACE);
-	if (proxy == NULL) {
-		g_warning ("%s was unable to create connection to Service iface.",
-			   G_OBJECT_TYPE_NAME (self));
-		return NULL;
-	}
-
-	/* Get Service properties to get the gateway address. */
-	if (dbus_g_proxy_call (proxy, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       &props,
-			       G_TYPE_INVALID)) {
-
-		/* Get the mac of the connected router. */
-		value = g_hash_table_lookup (props, "IPv4");
-		if (value != NULL) {
-			ht = g_value_get_boxed (value);
-			value = g_hash_table_lookup ((GHashTable *) ht, "Gateway");
-			if (value != NULL) {
-				gateway = g_value_dup_string (value);
-			}
-		}
-	} else {
-		msg = "Error getting Service properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	/* Free */
-	g_hash_table_destroy (props);
-	g_object_unref (proxy);
-
-	return gateway;
-}
-
-static void
-_get_aps_info (GeoclueConnman *self,
-	       const gchar *network,
-	       GHashTable **out)
-{
-	DBusGProxy *proxy = NULL;
-	GHashTable *props = NULL;
-	gchar *ap_mac = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-	int strength;
-
-	g_assert (out != NULL);
-
-	/* Create proxy. */
-	proxy = dbus_g_proxy_new_for_name (self->conn,
-					   CONNMAN_SERVICE,
-					   network,
-					   CONNMAN_NETWORK_INTERFACE);
-	if (proxy == NULL) {
-		g_warning ("%s was unable to create connection to Network iface.",
-			   G_OBJECT_TYPE_NAME (self));
-		return;
-	}
-
-	/* Collect available APs into a HasTable. */
-	if (dbus_g_proxy_call (proxy, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       &props,
-			       G_TYPE_INVALID)) {
-
-		/* Store the AP information. */
-		ap_mac = g_value_dup_string (g_hash_table_lookup (props, "Address"));
-		strength = g_value_get_uchar (g_hash_table_lookup (props, "Strength"));
-		if (ap_mac != NULL) {
-			/* Create storage for the first case. */
-			if (*out == NULL) {
-				*out = g_hash_table_new_full (g_str_hash, g_str_equal,
-							      (GDestroyNotify) g_free, NULL);
-			}
-			g_hash_table_insert (*out, ap_mac,
-					     GINT_TO_POINTER (_strength_to_dbm (strength)));
-		}
-	} else {
-		msg = "Error getting Network properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	/* Free */
-	g_hash_table_destroy (props);
-	g_object_unref (proxy);
-}
-
-static void
-_get_best_ap (GeoclueConnman *self,
-	      const gchar *network)
-{
-	DBusGProxy *proxy = NULL;
-	GHashTable *props = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-	int strength;
-
-	/* Create proxy. */
-	proxy = dbus_g_proxy_new_for_name (self->conn,
-					   CONNMAN_SERVICE,
-					   network,
-					   CONNMAN_NETWORK_INTERFACE);
-
-	if (proxy == NULL) {
-		g_warning ("%s was unable to create connection to Network iface.",
-			   G_OBJECT_TYPE_NAME (self));
-		return;
-	}
-
-	/* Evaluate Network properties and update best AP. */
-	if (dbus_g_proxy_call (proxy, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       &props,
-			       G_TYPE_INVALID)) {
-
-		strength = g_value_get_uchar (g_hash_table_lookup (props, "Strength"));
-		if (strength > self->ap_strength) {
-			g_free (self->cache_ap_mac);
-			self->cache_ap_mac = g_value_dup_string (g_hash_table_lookup (props, "Address"));
-			self->ap_strength = strength;
-		}
-	} else {
-		msg = "Error getting Network properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	/* Free */
-	g_hash_table_destroy (props);
-	g_object_unref (proxy);
-}
-
-static const GPtrArray *
-_get_networks (GeoclueConnman *self,
-	       GHashTable **props,
-	       const gchar *device,
-	       const gchar *type_filter)
-{
-	DBusGProxy *proxy = NULL;
-	const GPtrArray *nets = NULL;
-	const GValue *value = NULL;
-	const gchar *type = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-
-	/* Create proxy. */
-	proxy = dbus_g_proxy_new_for_name (self->conn,
-					   CONNMAN_SERVICE,
-					   device,
-					   CONNMAN_DEVICE_INTERFACE);
-
-	if (proxy == NULL) {
-		g_warning ("%s was unable to create connection to Device iface.",
-			   G_OBJECT_TYPE_NAME (self));
-		return NULL;
-	}
-
-	/* Get available Networks for a specific Device. */
-	if (dbus_g_proxy_call (proxy, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       props,
-			       G_TYPE_INVALID)) {
-
-		/* Check only specific networks. */
-		if (type_filter != NULL) {
-			type = g_value_get_string (g_hash_table_lookup (*props, "Type"));
-			if (g_strcmp0 (type, type_filter)) {
-                            goto frees;
-                        }
-                }
-                value = g_hash_table_lookup (*props, "Networks");
-                nets = g_value_get_boxed (value);
-	} else {
-		msg = "Error getting Device properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	/* Free */
- frees:
-	g_object_unref (proxy);
-
-	return nets;
-}
-
-static const GPtrArray *
-_get_devices (GeoclueConnman *self,
-	      GHashTable **props,
-	      const gchar *technology)
-{
-	DBusGProxy *proxy = NULL;
-	const GPtrArray *devs = NULL;
-	const GValue *value = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-
-	/* Create proxy. */
-	proxy = dbus_g_proxy_new_for_name (self->conn,
-					   CONNMAN_SERVICE,
-					   technology,
-					   CONNMAN_TECHNOLOGY_INTERFACE);
-
-	if (proxy == NULL) {
-		g_warning ("%s was unable to create connection to Technology iface.",
-			   G_OBJECT_TYPE_NAME (self));
-		return NULL;
-	}
-
-	/* Get available Devices for a specific Technology. */
-	if (dbus_g_proxy_call (proxy, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       props,
-			       G_TYPE_INVALID)) {
-
-		value = g_hash_table_lookup (*props, "Devices");
-		devs = g_value_get_boxed (value);
-	} else {
-		msg = "Error getting Technologies properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	/* Free */
-	g_object_unref (proxy);
-
-	return devs;
-}
-
-static const GPtrArray *
-_get_technologies (GeoclueConnman *self,
-		   GHashTable **props)
-{
-	const GPtrArray *techs = NULL;
-	const GValue *value = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-
-	/* Get available technologies (Wifi, Eth, ...). */
-	if (dbus_g_proxy_call (self->client, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       props,
-			       G_TYPE_INVALID)) {
-
-		value = g_hash_table_lookup (*props, "Technologies");
-		techs = g_value_get_boxed (value);
-	} else {
-		msg = "Error getting Manager properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	return techs;
-}
-
-static const GPtrArray *
-_get_services (GeoclueConnman *self,
-	       GHashTable **props)
-{
-	const GPtrArray *servs = NULL;
-	const GValue *value = NULL;
-	const gchar *msg = NULL;
-	GError *error = NULL;
-
-	/* Get available services. */
-	if (dbus_g_proxy_call (self->client, "GetProperties",
-			       &error,
-			       G_TYPE_INVALID,
-			       dbus_g_type_get_map ("GHashTable", G_TYPE_STRING, G_TYPE_VALUE),
-			       props,
-			       G_TYPE_INVALID)) {
-
-		value = g_hash_table_lookup (*props, "Services");
-		servs = g_value_get_boxed (value);
-	} else {
-		msg = "Error getting Manager properties: %s";
-		if (error != NULL) {
-			g_warning (msg, error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, "Unknown error");
-		}
-	}
-
-	return servs;
-}
-
-static void
-_explore_available_aps (GeoclueConnman *self,
-			ConnmanFunc func,
-			gpointer out)
-{
-	GHashTable *mgr_props = NULL;
-	GHashTable *tech_props = NULL;
-	GHashTable *dev_props = NULL;
-	const GPtrArray *techs = NULL;
-	const GPtrArray *devs = NULL;
-	const GPtrArray *nets = NULL;
-	const gchar *tech = NULL;
-	const gchar *dev = NULL;
-	const gchar *net = NULL;
-	guint i, j, k;
-
-	techs = _get_technologies (self, &mgr_props);
-	if (techs  == NULL) {
-		goto frees;
-	}
-	for (i = 0; i < techs->len; i++) {
-		tech = g_ptr_array_index (techs, i);
-		devs = _get_devices (self, &tech_props, tech);
-		if (devs == NULL) {
-			continue;
-		}
-		for (j = 0; j < devs->len; j++) {
-			dev = g_ptr_array_index (devs, j);
-			nets = _get_networks (self, &dev_props, dev, "wifi");
-			if (nets == NULL) {
-				continue;
-			}
-			for (k = 0; k < nets->len; k++) {
-				net = g_ptr_array_index (nets, k);
-
-				/* Perform specific actions. */
-				func (self, net, out);
-			}
-		}
-	}
-
-	/* Free */
- frees:
-	if (mgr_props != NULL) {
-		g_hash_table_destroy (mgr_props);
-	}
-	if (tech_props != NULL) {
-		g_hash_table_destroy (tech_props);
-	}
-	if (dev_props != NULL) {
-		g_hash_table_destroy (dev_props);
-	}
-}
-
-static void
-_cache_ap_mac (GeoclueConnman *self)
-{
-	/* Cleanup the cache. */
-	g_free (self->cache_ap_mac);
-	self->cache_ap_mac = NULL;
-	self->ap_strength = 0;
-
-	/* Explore the active networks to get the best AP. */
-	_explore_available_aps (self, (ConnmanFunc) _get_best_ap, NULL);
-}
-
-
-
-static void
-_geoclue_connman_state_changed (DBusGProxy *proxy,
-				const gchar *status,
-				gpointer userdata)
-{
-	GeoclueConnman *self = GEOCLUE_CONNMAN (userdata);
-	GeoclueNetworkStatus gc_status;
-
-	gc_status = connmanstatus_to_geocluenetworkstatus (status);
-
-	if (gc_status != self->status) {
-		/* Update status. */
-		self->status = gc_status;
-
-		/* Update AP cache. */
-		_cache_ap_mac (self);
-
-		/* Notification. */
-		geoclue_connectivity_emit_status_changed (GEOCLUE_CONNECTIVITY (self),
-		                                          self->status);
-	}
-}
-
-
-static void
-_method_call_notify_cb (DBusGProxy *proxy,
-                        DBusGProxyCall *call,
-                        gpointer user_data)
-{
-	GeoclueConnman *self = GEOCLUE_CONNMAN (user_data);
-	const gchar *msg = NULL;
-	GError *error = NULL;
-	gchar *state = NULL;
-
-	/* Collect output data. */
-	if (dbus_g_proxy_end_call (proxy,
-				   call,
-				   &error,
-				   G_TYPE_STRING,
-				   &state,
-				   G_TYPE_INVALID)) {
-
-		/* Set current status. */
-		_geoclue_connman_state_changed (proxy,
-						(const gchar *) state,
-						self);
-	} else {
-		msg = "%s was unable to get the current network status: %s.";
-		if (error != NULL) {
-			g_warning (msg, G_OBJECT_TYPE_NAME (self),
-				   error->message);
-			g_error_free (error);
-		} else {
-			g_warning (msg, G_OBJECT_TYPE_NAME (self),
-				   "Unknown error");
-		}
-	}
-
-	/* Free */
-	g_free (state);
-}
-
-static void
-geoclue_connman_init (GeoclueConnman *self)
-{
-	GError *error = NULL;
-
-	/* Get DBus connection to the System bus. */
-	self->conn = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);
-	if (self->conn == NULL) {
-		g_warning ("%s was unable to create a connection to D-Bus: %s",
-			   G_OBJECT_TYPE_NAME (self), error->message);
-		g_error_free (error);
-		return;
-	}
-
-	/* Create proxy. */
-	self->client = dbus_g_proxy_new_for_name (self->conn,
-						  CONNMAN_SERVICE,
-						  CONNMAN_MANAGER_PATH,
-						  CONNMAN_MANAGER_INTERFACE);
-
-	if (self->client == NULL) {
-		g_warning ("%s was unable to create connection to Connman Manager.",
-			   G_OBJECT_TYPE_NAME (self));
-		return;
-	}
-
-	/* Get current state (async). */
-	dbus_g_proxy_begin_call (self->client, "GetState",
-				 _method_call_notify_cb,
-				 self,
-				 NULL,
-				 G_TYPE_INVALID,
-				 G_TYPE_STRING);
-
-	/* Be aware of State changes. */
-	dbus_g_proxy_add_signal (self->client, "StateChanged",
-	                         G_TYPE_STRING, G_TYPE_INVALID);
-	dbus_g_proxy_connect_signal (self->client,
-				     "StateChanged",
-				     G_CALLBACK (_geoclue_connman_state_changed),
-				     self,
-				     NULL);
-}
-
-
-static void
-geoclue_connman_connectivity_init (GeoclueConnectivityInterface *iface)
-{
-	iface->get_status = _get_status;
-	iface->get_ap_mac = _get_ap_mac;
-	iface->get_router_mac = _get_router_mac;
-	iface->get_aps    = _get_aps;
-}
-
-#endif /* HAVE_CONNMAN*/
Index: geoclue/src/connectivity-connman.h
===================================================================
--- geoclue.orig/src/connectivity-connman.h	2011-12-29 16:40:38.930428900 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-/*
- * Geoclue
- * connectivity-connman.h
- *
- * Author: Javier Fernandez <jfernandez@igalia.com>
- * Copyright (C) 2010 Igalia S.L
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- *
- */
-
-#ifndef _CONNECTIVITY_CONNMAN_H
-#define _CONNECTIVITY_CONNMAN_H
-
-#include <glib-object.h>
-#include <dbus/dbus-glib.h>
-#include "connectivity.h"
-
-G_BEGIN_DECLS
-
-#define GEOCLUE_TYPE_CONNMAN (geoclue_connman_get_type ())
-#define GEOCLUE_CONNMAN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOCLUE_TYPE_CONNMAN, GeoclueConnman))
-
-typedef struct {
-	GObject parent;
-
-	/* private */
-	GeoclueNetworkStatus status;
-	DBusGConnection *conn;
-	DBusGProxy *client;
-	gchar *cache_ap_mac;
-	int ap_strength;
-} GeoclueConnman;
-
-typedef struct {
-	GObjectClass parent_class;
-} GeoclueConnmanClass;
-
-GType geoclue_connman_get_type (void);
-
-G_END_DECLS
-
-#endif
Index: geoclue/src/geoclue
===================================================================
--- geoclue.orig/src/geoclue	2011-12-29 16:40:38.930428900 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-[org.freedesktop.Geoclue]
-gps-baudrate = /apps/geoclue/master/org.freedesktop.Geoclue.GPSBaudRate
-gps-device = /apps/geoclue/master/org.freedesktop.Geoclue.GPSDevice
Index: geoclue/src/org.freedesktop.Geoclue.gschema.xml
===================================================================
--- geoclue.orig/src/org.freedesktop.Geoclue.gschema.xml	2011-12-29 16:40:38.930428900 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,15 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<schemalist>
-  <schema path="/apps/geoclue/" id="org.freedesktop.Geoclue">
-    <key type="u" name="gps-baudrate">
-      <default>0</default>
-      <summary>The baud rate for the attached GPS device</summary>
-      <description>The baud rate for the attached GPS device.</description>
-    </key>
-    <key type="s" name="gps-device">
-      <default>''</default>
-      <summary>The device node or Bluetooth address for the attached GPS device</summary>
-      <description>The device node or Bluetooth address for the attached GPS device.</description>
-    </key>
-  </schema>
-</schemalist>
Index: geoclue/src/test-connectivity.c
===================================================================
--- geoclue.orig/src/test-connectivity.c	2011-12-29 16:40:38.930428900 +0900
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-
-#include <connectivity.h>
-
-static void
-print_ap (gpointer key,
-	  gpointer value,
-	  gpointer data)
-{
-	g_message ("\t%s : %d dBm",
-		   key,
-		   GPOINTER_TO_INT (value));
-}
-
-static void
-print_aps (GeoclueConnectivity *conn)
-{
-	GHashTable *ht;
-
-	ht = geoclue_connectivity_get_aps (conn);
-	if (ht == NULL) {
-		g_message ("No Access Points available");
-		return;
-	}
-	g_message ("APs:");
-	g_hash_table_foreach (ht, print_ap, NULL);
-}
-
-static void
-print_if_avail (GeoclueConnectivity *self,
-		GeoclueNetworkStatus status)
-{
-	char *router, *ap;
-	if (status != GEOCLUE_CONNECTIVITY_ONLINE)
-		return;
-	print_aps (self);
-	ap = geoclue_connectivity_get_ap_mac (self);
-	g_message ("AP is '%s'", ap ? ap : "Unavailable");
-	g_free (ap);
-
-	router = geoclue_connectivity_get_router_mac (self);
-	g_message ("Router is '%s'", router);
-	g_free (router);
-}
-
-static void
-status_changed_cb (GeoclueConnectivity *self,
-		   GeoclueNetworkStatus status,
-		   gpointer data)
-{
-	const char *str;
-
-	switch (status) {
-	case GEOCLUE_CONNECTIVITY_UNKNOWN:
-		str = "GEOCLUE_CONNECTIVITY_UNKNOWN";
-		break;
-	case GEOCLUE_CONNECTIVITY_OFFLINE:
-		str = "GEOCLUE_CONNECTIVITY_OFFLINE";
-		break;
-	case GEOCLUE_CONNECTIVITY_ACQUIRING:
-		str = "GEOCLUE_CONNECTIVITY_ACQUIRING";
-		break;
-	case GEOCLUE_CONNECTIVITY_ONLINE:
-		str = "GEOCLUE_CONNECTIVITY_ONLINE";
-		break;
-	default:
-		g_assert_not_reached ();
-	}
-
-	g_message ("Connectivity status switch to '%s'", str);
-
-	print_if_avail (self, status);
-}
-
-int main (int argc, char **argv)
-{
-	GMainLoop *mainloop;
-	GeoclueConnectivity *conn;
-	char *router;
-
-	g_type_init ();
-	mainloop = g_main_loop_new (NULL, FALSE);
-	conn = geoclue_connectivity_new ();
-
-	if (conn == NULL) {
-		router = geoclue_connectivity_get_router_mac (conn);
-		g_message ("Router MAC is detected as '%s'", router ? router : "empty");
-
-		return 1;
-	}
-	print_if_avail (conn, geoclue_connectivity_get_status (conn));
-	g_signal_connect (conn, "status-changed",
-			  G_CALLBACK (status_changed_cb), NULL);
-
-	g_main_loop_run (mainloop);
-
-	return 0;
-}
